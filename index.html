<!DOCTYPE html>   
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="loading" content="eager">
	<meta name="referrer" content="no-referrer-when-downgrade">
	<meta http-equiv="Content-Security-Policy" content="img-src 'self' data: https: http:;">

    <title>ระบบแผนที่โรงเรียนอัจฉริยะ Version1.3 - User Interface</title>
    
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
	<style id="gallery-enhanced-styles">
	
	/* =================== Loading Overlay =================== */
		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0,0,0,0.8);
			z-index: 9999;
			display: none;
			align-items: center;
			justify-content: center;
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		.loading-content {
			background: var(--card-background);
			border-radius: var(--border-radius);
			padding: 40px;
			text-align: center;
			max-width: 400px;
			margin: 20px;
			box-shadow: 0 25px 50px rgba(0,0,0,0.3);
		}

		.loading-spinner {
			width: 50px;
			height: 50px;
			border: 4px solid #f3f3f3;
			border-top: 4px solid var(--primary-color);
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin: 0 auto 20px;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}


    /* Gallery Container */
    #overlayRoomGallery {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--border-color, #ddd);
        border-radius: 8px;
        padding: 15px;
        background: var(--background-color, #fff);
        margin-top: 15px;
        display: none; /* เริ่มต้นซ่อนไว้ */
    }
    
    /* Gallery Items */
    .gallery-item {
        position: relative;
        margin-bottom: 15px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .gallery-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    }
    
    .gallery-item:last-child {
        margin-bottom: 0;
    }
    
    /* Gallery Images */
    .gallery-item img {
        width: 100%;
        height: auto;
        max-height: 300px;
        object-fit: cover;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s ease;
        display: block;
        background: #f5f5f5;
    }
    
    .gallery-item img:hover {
        transform: scale(1.02);
    }
    
    /* Loading state */
    .gallery-item img[src=""] {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        animation: loading 2s infinite;
        min-height: 200px;
    }
    
    @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    
    /* Error Fallback */
    .image-error-fallback {
        display: none;
        text-align: center;
        padding: 40px 20px;
        background: #f8f9fa;
        border: 2px dashed #dee2e6;
        border-radius: 8px;
        color: #6c757d;
        font-size: 14px;
    }
    
    .image-error-fallback i {
        font-size: 48px;
        color: #dc3545;
        margin-bottom: 15px;
        opacity: 0.7;
    }
    
    /* Debug Info */
    .gallery-debug {
        font-family: 'Courier New', monospace;
        font-size: 11px;
        opacity: 0.7;
        margin-top: 10px;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
        word-break: break-all;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
        #overlayRoomGallery {
            max-height: 300px;
            padding: 10px;
        }
        
        .gallery-item img {
            max-height: 200px;
        }
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
        #overlayRoomGallery {
            background: var(--dark-background, #2d3748);
            border-color: var(--dark-border, #4a5568);
        }
        
        .image-error-fallback {
            background: #4a5568;
            border-color: #718096;
            color: #e2e8f0;
        }
        
        .gallery-debug {
            background: #4a5568;
            color: #e2e8f0;
        }
    }
</style>
    <style>
        /* =================== CSS Variables =================== */
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            
            --background-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --card-background: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e6ff;
            
            --border-radius: 15px;
            --box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
            
            --bottom-nav-height: 70px;
            --content-padding-bottom: 85px;
        }

        /* =================== Base Styles =================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background-gradient);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
            transition: var(--transition);
            padding-bottom: var(--content-padding-bottom);
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        /* =================== Header =================== */
        .header {
			position: relative; /* เพิ่มเพื่อให้ position absolute ทำงานได้ */
            background: var(--card-background);
            padding: 15px 20px;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 15px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
		.header .status-indicator {
			position: absolute;
			top: 2px;                   /* ลดจาก 5px */
			right: 10px;               /* เปลี่ยนจาก center เป็น right */
			z-index: 200;
			font-size: 8px;            /* เล็กลงอีก */
			padding: 1px 6px;          /* เล็กลงอีก */
			border-radius: 8px;
		}
		
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .school-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
        }

        .header-title {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            color: var(--text-primary);
            margin: 0;
            font-size: 1.4em;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-top: 5px;
        }

        .header-btn {
            background: var(--card-background);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            color: var(--primary-color);
            font-size: 12px;
        }

        .header-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .language-btn {
            background: linear-gradient(135deg, var(--info-color), var(--primary-color));
            color: white;
            border: none;
        }

        /* =================== Bottom Navigation =================== */
        .bottom-navigation {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--bottom-nav-height);
            background: var(--card-background);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
        }

        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            padding: 8px 4px;
            position: relative;
            color: var(--text-secondary);
        }

        .nav-item.active {
            color: var(--primary-color);
        }

        .nav-item:hover {
            color: var(--primary-color);
            transform: translateY(-2px);
        }

        .nav-item i {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .nav-item span {
            font-size: 10px;
            font-weight: 600;
        }

        .nav-item.active::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: var(--primary-color);
            border-radius: 0 0 10px 10px;
        }
		/* =================== Status Indicators =================== */
		/* ======= แก้ไข Version Indicator ให้เล็กลง ======= */
			.status-indicator {
				padding: 2px 8px;           /* ลดจาก 4px 12px */
				border-radius: 12px;        /* ลดจาก 20px */
				font-size: 9px;             /* ลดจาก 11px */
				font-weight: 500;           /* ลดจาก 600 */
				text-transform: uppercase;
				opacity: 0.8;               /* เพิ่มความโปร่งใส */
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
			}

		.status-active {
			background: rgba(40, 167, 69, 0.1);
			color: var(--accent-color);
		}

		.status-inactive {
			background: rgba(108, 117, 125, 0.1);
			color: #6c757d;
		}

		.status-connected {
			background: rgba(23, 162, 184, 0.1);
			color: var(--info-color);
		}

		.status-error {
			background: rgba(220, 53, 69, 0.1);
			color: var(--danger-color);
		}

		/* =================== Loading Overlay =================== */
		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0,0,0,0.8);
			z-index: 9999;
			display: none;
			align-items: center;
			justify-content: center;
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		.loading-content {
			background: var(--card-background);
			border-radius: var(--border-radius);
			padding: 40px;
			text-align: center;
			max-width: 400px;
			margin: 20px;
			box-shadow: 0 25px 50px rgba(0,0,0,0.3);
		}

		.loading-spinner {
			width: 50px;
			height: 50px;
			border: 4px solid #f3f3f3;
			border-top: 4px solid var(--primary-color);
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin: 0 auto 20px;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

        /* =================== Page Styles =================== */
        .page {
            display: none;
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            margin-bottom: 15px;
            min-height: calc(100vh - 200px);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .page.active {
            display: block;
            animation: fadeInUp 0.4s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* =================== Search Styles =================== */
        .search-container {
            background: linear-gradient(135deg, #f8f9ff, #e6f3ff);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .search-box {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .search-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255,255,255,0.9);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            background: white;
        }

        .search-btn {
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: var(--transition);
            white-space: nowrap;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .quick-categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .category-card {
            background: var(--card-background);
            padding: 20px;
            border-radius: var(--border-radius);
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid var(--border-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--box-shadow);
            border-color: var(--primary-color);
        }

        .category-card i {
            font-size: 32px;
            color: var(--primary-color);
            margin-bottom: 12px;
        }

        .category-card h4 {
            color: var(--primary-color);
            margin-bottom: 8px;
            font-size: 16px;
        }

        .category-card p {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* =================== Map Styles =================== */
        .map-container {
            position: relative;
            margin-top: 20px;
			width: 100%;
			max-width: 100%;  /* เพิ่มเพื่อป้องกันล้น */
        }

        /* Map controls with toggle functionality */
        .map-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            position: relative;
        }
		
		/* ========== Fullscreen mode enhancements ========== */
			
		.header {
			transition: transform 0.3s ease, opacity 0.3s ease;
		}

		body.fullscreen-active .header {
			height: 8px !important;
			padding: 1px !important;
			min-height: 8px !important;
			overflow: hidden !important;
			opacity: 0.3 !important;
		}
		
		body.fullscreen-active .container > *:not(.map-section) {
			display: none !important;
		}

		body.fullscreen-active .map-section > *:not(.map-area):not(.map-controls) {
			display: none !important;
		}

		.bottom-navigation {
			transition: transform 0.3s ease, opacity 0.3s ease;
		}

		body.fullscreen-active .bottom-navigation {
			height: 8px !important;
			padding: 1px !important;
			min-height: 8px !important;
			overflow: hidden !important;
			opacity: 0.3 !important;
		}
 
		body.fullscreen-active .map-container {
			position: fixed !important;
			top: 0 !important;
			left: 0 !important;
			width: 100vw !important;
			height: 100vh !important;
			z-index: 10000 !important;
			background: #f5f5f5 !important;
		}

		body.fullscreen-active .map-area {
			width: 100% !important;
			height: 100% !important;
			display: flex !important;
			align-items: center !important;
			justify-content: center !important;
		}

		body.fullscreen-active .map-image {
			max-width: 95% !important;
			max-height: 95% !important;
			object-fit: contain !important;
			object-position: center !important;
		}

		/* เพิ่มสำหรับ landscape fullscreen */
		@media screen and (orientation: landscape) and (max-height: 500px) {
			body.fullscreen-active .map-image {
				max-width: 98% !important;
				max-height: 98% !important;
			}
}

		body.fullscreen-active {
			padding-bottom: 8px !important;
			padding-top: 8px !important;
			background: #f5f5f5 !important;
			overflow: hidden !important;
		}
		
		body.fullscreen-active .container > *:not(.map-section) {
			display: none !important;
		}

		body.fullscreen-active .map-section > *:not(.map-area):not(.map-controls) {
			display: none !important;
		}

		body.fullscreen-active .map-area.fullscreen {
			display: flex !important;
			visibility: visible !important;
		}

		body.fullscreen-active .map-area.fullscreen .map-image {
			display: block !important;
			visibility: visible !important;
		}
                           
		body.fullscreen-active .route-path {
			position: absolute !important;
			top: 0 !important;
			left: 0 !important;
			width: 100% !important;
			height: 100% !important;
			pointer-events: none !important;
		}
		/* ========== end of Fullscreen mode enhancements ========== */
		.map-controls.fullscreen-controls {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 2000;
			background: rgba(255,255,255,0.95);
			padding: 8px;
			border-radius: var(--border-radius);
			box-shadow: var(--box-shadow);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}
		
		.map-controls.fullscreen-controls {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 2000;
			background: rgba(255,255,255,0.95);
			padding: 8px;
			border-radius: var(--border-radius);
			box-shadow: var(--box-shadow);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		.map-controls.fullscreen-controls .map-control-btn {
			display: block;
			margin-bottom: 5px;
		}

		.map-controls.fullscreen-controls .map-control-btn:last-child {
			margin-bottom: 0;
		}
		
        .map-controls.hidden .map-control-btn:not(.toggle-btn) {
            display: none;
        }
		.show-controls-btn {
			position: fixed;
			top: 20px;
			right: 20px;
			padding: 10px 15px;
			background: var(--warning-color);
			color: var(--text-primary);
			border: 2px solid var(--warning-color);
			border-radius: var(--border-radius);
			cursor: pointer;
			font-size: 12px;
			font-weight: 600;
			z-index: 1001;
			box-shadow: var(--box-shadow);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
			transition: var(--transition);
			display: none;
		}

		.show-controls-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 8px 20px rgba(0,0,0,0.2);
		}

        .map-control-btn {
            padding: 10px 15px;
            background: rgba(255,255,255,0.95);
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .map-control-btn.active {
            background: var(--primary-color);
            color: white;
        }

        .map-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .toggle-btn {
            background: var(--warning-color);
            color: var(--dark-color);
            border-color: var(--warning-color);
        }

        /* Room selection overlay for choosing action */
         .room-action-overlay {
            position: absolute;
            background: var(--card-background);
            border: 8px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: var(--box-shadow);
            z-index: 200;
            display: none;
            min-width: 200px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
			top: 50%;         /* เพิ่มใหม่ */
			left: 50%;        /* เพิ่มใหม่ */
			transform: translate(-50%, -50%); /* เพิ่มใหม่ */
        }
 
        .room-action-header {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 14px;
        }

        .room-action-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: var(--card-background);
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .room-action-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-1px);
        }

        .room-action-btn:last-child {
            margin-bottom: 0;
        }

      		
		.map-area {
			position: relative;
			width: 100%;
			min-height: 400px;  /* สำหรับ desktop */
			background: #f5f5f5;
			border-radius: var(--border-radius);
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
		}


        .map-image {
			width: 100%;
			height: 100%;
			object-fit: contain;  /* รักษาสัดส่วน + แสดงเต็มรูป */
			object-position: center;
			display: block;
			border-radius: var(--border-radius);
		}


        .map-image:hover {
            filter: brightness(1.05);
        }

        /* Route Controls - moved outside map */
        .route-controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .route-control-btn {
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .route-control-btn:hover {
            transform: translateY(-2px);
        }

        .route-control-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .clear-route-btn {
            background: var(--danger-color);
        }

        /* Room Markers */
        .room-marker {
            position: absolute;
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            transition: var(--transition);
            border: 3px solid white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 30;
            transform: translate(-50%, -50%);
        }

        .room-marker:hover {
            transform: translate(-50%, -50%) scale(1.3);
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .room-marker.highlighted {
            background: var(--danger-color);
            animation: pulse 2s infinite;
            transform: translate(-50%, -50%) scale(1.3);
        }

        .start-point-marker {
            background: var(--accent-color);
            width: 40px;
            height: 40px;
            font-size: 18px;
            animation: startPointPulse 3s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        @keyframes startPointPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                box-shadow: 0 0 0 15px rgba(40, 167, 69, 0);
            }
        }
		
		@keyframes pulse {
		0% {
			transform: scale(1);
			box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
		}
		70% {
			transform: scale(1.05);
			box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
		}
		100% {
			transform: scale(1);
			box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
		}
	}

      /* ========== 2. แก้ไข Route Path Style ให้เรียบง่าย ========== */
	.route-path {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: 15;
		overflow: visible;
	}

	/* เส้นทางหลักแบบเรียบง่าย */
	.route-line {
		stroke: #4285f4 !important;
		stroke-width: 2.5 !important; /* ย่อขนาดลง */
		fill: none !important;
		stroke-linecap: round !important;
		stroke-linejoin: round !important;
		opacity: 0.8 !important;
	}

	/* เส้นกรอบขาว (ไม่มี glow) */
	.route-line-border {
		stroke: white !important;
		stroke-width: 4 !important; /* ย่อขนาดลง */
		fill: none !important;
		stroke-linecap: round !important;
		stroke-linejoin: round !important;
		opacity: 0.9 !important;
	}
	
	/* Animation เรียบง่าย */
	@keyframes route-flow {
		0% { stroke-dashoffset: 0; }
		100% { stroke-dashoffset: -15; }
	}

	.route-line-animated {
		stroke: #4285f4 !important;
		stroke-width: 2.5 !important;
		fill: none !important;
		stroke-linecap: round !important;
		stroke-linejoin: round !important;
		stroke-dasharray: 8 4 !important;
		animation: route-flow 2s linear infinite !important;
	}

	/* จุดเริ่มต้น (เขียว) - เรียบง่าย */
	.route-start-marker {
		fill: #34a853 !important;
		stroke: white !important;
		stroke-width: 1.5 !important;
		r: 4 !important;
	}

	/* จุดปลายทาง (แดง) - เรียบง่าย */
	.route-end-marker {
		fill: #ea4335 !important;
		stroke: white !important;
		stroke-width: 1.5 !important;
		r: 4 !important;
	}

	/* Waypoints (จุดระหว่างทาง) - เรียบง่าย */
	.route-waypoint {
		fill: #fbbc04 !important;
		stroke: white !important;
		stroke-width: 1 !important;
		r: 3 !important;
	}
	
	
	 /* ========== Mobile Landscape: ซ่อน header-top เฉพาะในหน้าแผนที่ ========== */ 
@media screen and (orientation: landscape) and (max-height: 500px) {
    /* ซ่อน header-top เฉพาะเมื่ออยู่ในหน้าแผนที่ */
    body.map-page .header-top,
    body[data-current-page="map"] .header-top {
        display: none !important;
    }
    
    /* ซ่อน bottom navigation เฉพาะเมื่ออยู่ในหน้าแผนที่ */
    body.map-page .bottom-navigation,
    body[data-current-page="map"] .bottom-navigation {
        display: none !important;
    }
    
    /* ปรับ body padding เฉพาะเมื่ออยู่ในหน้าแผนที่ */
    body.map-page,
    body[data-current-page="map"] {
        padding-bottom: 0 !important;
    }
    
    /* แสดงข้อความแนะนำเฉพาะเมื่ออยู่ในหน้าแผนที่ */
    body.map-page .header::after,
    body[data-current-page="map"] .header::after {
        content: "กลับสู่เมนูปกติด้วยการหมุนโทรศัพท์ในแนวตั้ง" !important;
        display: block !important;
        color: white !important;
        font-size: 11px !important;
        text-align: center !important;
        font-weight: 500 !important;
        padding: 8px 0 !important;
        background: none !important;
    }
}

/* ========== Mobile Portrait: แสดงปกติในทุกหน้า ========== */
@media screen and (orientation: portrait) {
    /* แสดง header-top ปกติในทุกหน้า */
    .header-top {
        display: flex !important;
    }
    
    /* ซ่อนข้อความแนะนำในทุกหน้า */
    .header::after {
        display: none !important;
    }
    
    /* แสดง bottom navigation ปกติในทุกหน้า */
    .bottom-navigation {
        display: flex !important;
    }
    
    /* รีเซ็ต body padding ในทุกหน้า */
    body {
        padding-bottom: var(--content-padding-bottom) !important;
    }
}
/* ========== Mobile Portrait: แสดงปกติในทุกหน้า ========== */
@media screen and (orientation: portrait) and (max-width: 768px) {
    /* แสดง header-top ปกติในทุกหน้า */
    .header-top {
        display: flex !important;
    }
    
    /* ซ่อนข้อความแนะนำในทุกหน้า */
    .header::after {
        display: none !important;
    }
    
    /* แสดง bottom navigation ปกติในทุกหน้า */
    .bottom-navigation {
        display: flex !important;
    }
    
    /* รีเซ็ต body padding ในทุกหน้า */
    body {
        padding-bottom: var(--content-padding-bottom) !important;
    }
}
		
		/* ปรับ toolbar ใน landscape */
		body.map-page .map-toolbar,
		body[data-current-page="map"] .map-toolbar {
			position: absolute;
			top: 10px;
			right: 10px;
			z-index: 100;
			background: rgba(255,255,255,0.9);
			border-radius: 8px;
			padding: 5px;
		}
	}

	/* Mobile responsive - ขนาดเหมาะสม */
	@media (max-width: 768px) {
		.route-line,
		.route-line-animated {
			stroke-width: 2 !important; /* เล็กกว่าใน mobile */
		}
		
		.route-line-border {
			stroke-width: 3.5 !important;
		}
		
		.route-start-marker,
		.route-end-marker {
			r: 3.5 !important;
			stroke-width: 1 !important;
		}
		
		.route-waypoint {
			r: 2.5 !important;
			stroke-width: 0.8 !important;
		}
	}

		@media (max-width: 480px) {
			.route-line,
			.route-line-animated {
				stroke-width: 1.8 !important; /* เล็กสุดใน mobile เล็ก */
			}
			
			.route-line-border {
				stroke-width: 3 !important;
			}
			
			.route-start-marker,
			.route-end-marker {
				r: 3 !important;
				stroke-width: 1 !important;
			}
			
			.route-waypoint {
				r: 2 !important;
				stroke-width: 0.5 !important;
			}
		}

/*      
	  .waypoint-marker {
            fill: var(--warning-color);
            stroke: white;
            stroke-width: 3;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            animation: waypoint-pulse 2s ease-in-out infinite;
        }
*/
        @keyframes dash {
            to {
                stroke-dashoffset: -25;
            }
        }

        @keyframes waypoint-pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.3);
                opacity: 1;
            }
        }

        /* FIX 5: Building Filter */
        .building-filter {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .building-filter h4 {
            margin-bottom: 10px;
            color: var(--primary-color);
            font-size: 14px;
        }

        .building-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .building-btn {
            padding: 8px 12px;
            background: var(--card-background);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .building-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .building-btn:hover {
            border-color: var(--primary-color);
            transform: translateY(-1px);
        }

        /* =================== Room Info Overlay =================== */
        .room-info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1500;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .room-info-content {
            background: var(--card-background);
            border-radius: var(--border-radius);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .room-info-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 25px;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            position: relative;
        }

        .room-info-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .room-info-close:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .room-info-body {
            padding: 25px;
        }

        .navigation-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .nav-control-btn {
            flex: 1;
            padding: 15px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: var(--transition);
            text-align: center;
        }

        .nav-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .nav-control-btn:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
        }

        .voice-btn {
            background: var(--accent-color);
        }

        .voice-btn.speaking {
            background: var(--danger-color);
            animation: voice-pulse 1s infinite;
        }

        @keyframes voice-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Compact Info */
        .compact-info {
			display: flex;
			gap: 10px;
			margin-bottom: 15px;
			flex-wrap: wrap;
			justify-content: space-between;
		}

		.info-item {
			background: rgba(255,255,255,0.8);
			padding: 8px 12px;
			border-radius: 8px;
			text-align: center;
			border-left: 3px solid var(--primary-color);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
			flex: 1;
			min-width: 0;
		}

        .info-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Route Steps */
        .route-steps {
            background: var(--card-background);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-top: 15px;
        }

        .route-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .route-step:last-child {
            border-bottom: none;
        }

        .step-number {
            background: var(--primary-color);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
            font-size: 14px;
        }

        .step-distance {
            background: rgba(102, 126, 234, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            color: var(--primary-color);
            font-weight: 600;
        }

        .step-voice-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Search Results */
        .live-results {
            margin-top: 15px;
        }

        .search-result-item {
            background: var(--card-background);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: var(--border-radius);
            cursor: pointer;
            border-left: 4px solid var(--primary-color);
            transition: var(--transition);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid var(--border-color);
        }

        .search-result-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--box-shadow);
            border-color: var(--primary-color);
        }

        .search-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .search-result-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 16px;
        }

        .search-result-code {
            background: var(--primary-color);
            color: white;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .search-result-info {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* =================== Notification =================== */
        .notification {
            position: fixed;
            top: 90px;
            right: 20px;
            padding: 15px 25px;
            background: var(--accent-color);
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            opacity: 0;
            transform: translateX(350px);
            transition: var(--transition);
            z-index: 3000;
            max-width: 320px;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.error { background: var(--danger-color); }
        .notification.warning { background: var(--warning-color); color: #333; }
        .notification.info { background: var(--info-color); }

        /* =================== Hidden Elements =================== */
        .hidden {
            display: none !important;
        }

        /* =================== Responsive Design =================== */
        @media (min-width: 768px) {
            .container {
                max-width: 1200px;
                padding: 25px;
            }
            
            .quick-categories {
                grid-template-columns: repeat(4, 1fr);
            }

            .bottom-navigation {
                justify-content: center;
                gap: 40px;
                max-width: 600px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: var(--border-radius) var(--border-radius) 0 0;
            }

            .nav-item {
                flex: none;
                min-width: 80px;
            }
        }
		
		@media (max-width: 480px) {
			.compact-info { gap: 5px; }
			.info-item { padding: 6px 8px; flex: 1; min-width: 0; }
			.info-label { font-size: 9px; margin-bottom: 1px; }
			.info-value { font-size: 11px; }
		}
		
		/* แก้ไข responsive สำหรับ mobile */
		@media (max-width: 768px) {
			.header .status-indicator {
				top: 1px;
				right: 5px;
				font-size: 7px;
				padding: 1px 4px;
			}
			
			.map-area {
			min-height: 250px;  /* ลดความสูงใน mobile */
			}
			
			.map-image {
				object-fit: contain;  /* ยืนยันอีกครั้งสำหรับ mobile */
				max-height: 100%;
				max-width: 100%;
			}
		}
		
		@media (max-width: 480px) {
		.map-area {
			min-height: 200px;  /* ลดเพิ่มเติมสำหรับ mobile เล็ก */
		}
		
		/* เพิ่ม CSS สำหรับ About Page ที่ responsive */
		@media (max-width: 768px) {
			#about-page h1 {
				font-size: 1.5em !important;
			}
			
			#about-page .page h2 {
				font-size: 1.3em !important;
			}
			
			#about-page [style*="font-size: 64px"] {
				font-size: 48px !important;
			}
			
			#about-page [style*="font-size: 48px"] {
				font-size: 36px !important;
			}
			
			#about-page [style*="padding: 30px"] {
				padding: 20px !important;
			}
			
			#about-page [style*="padding: 25px"] {
				padding: 20px !important;
			}
			
			#about-page [style*="width: 60px; height: 60px"] {
				width: 50px !important;
				height: 50px !important;
				font-size: 20px !important;
			}
		}

		@media (max-width: 480px) {
			#about-page [style*="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr))"] {
				grid-template-columns: 1fr !important;
			}
			
			#about-page [style*="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr))"] {
				grid-template-columns: 1fr !important;
			}
			
			#about-page [style*="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))"] {
				grid-template-columns: repeat(2, 1fr) !important;
			}
			
			#about-page [style*="padding: 20px"] {
				padding: 15px !important;
			}
		}
    </style>
	
		<!-- เพิ่ม Script สำหรับ Enhanced Image Loading -->
	<script>
	// 🔧 Enhanced Image Loading with CORS handling
	document.addEventListener('DOMContentLoaded', function() {
		// ตั้งค่า global image error handler
		window.addEventListener('error', function(e) {
			if (e.target && e.target.tagName === 'IMG') {
				console.warn('🖼️ Global image error:', e.target.src);
				
				// ลองโหลดใหม่โดยไม่มี CORS
				if (e.target.hasAttribute('crossorigin')) {
					console.log('🔄 Retrying without CORS...');
					e.target.removeAttribute('crossorigin');
					e.target.src = e.target.src + '?retry=' + Date.now();
				}
			}
		}, true);
		
		// เพิ่ม observer สำหรับ dynamic images
		if (window.MutationObserver) {
			const observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(mutation) {
					mutation.addedNodes.forEach(function(node) {
						if (node.nodeType === 1 && node.tagName === 'IMG') {
							console.log('🔍 New image detected:', node.src);
						}
					});
				});
			});
			
			observer.observe(document.body, {
				childList: true,
				subtree: true
			});
		}
	});

	// 🔧 Force reload images function
	window.forceReloadGalleryImages = function() {
		const galleryImages = document.querySelectorAll('#roomGalleryImages img');
		console.log('🔄 Force reloading', galleryImages.length, 'gallery images');
		
		galleryImages.forEach((img, index) => {
			const originalSrc = img.src;
			img.src = '';
			setTimeout(() => {
				img.src = originalSrc + '?reload=' + Date.now();
				console.log(`🔄 Reloaded image ${index + 1}:`, img.src);
			}, index * 100); // Stagger loading
		});
	};
	// ========== 1. Enhanced ADMIN_INDEX_BRIDGE ==========

		const ADMIN_INDEX_BRIDGE = {
			// Environment detection
			isAdminMode: () => window.location.pathname.includes('admin.html'),
			isIndexMode: () => window.location.pathname.includes('index.html'),
			
			// Data format identification
			adminFormat: 'walkablePointsData',
			indexFormat: 'walkableRoutingData',
			
			// Sync configuration
			syncEnabled: true,
			autoSyncOnChange: true,
			adminHasPriority: true,  // Admin data มีความสำคัญสูงกว่า
			lastSyncTime: null,
			
			// Storage key management (🚨 FIXED: แยก keys แล้ว!)
			getStorageKey: (building, mode) => {
				if (!building) building = 'Main Building';
				return `walkableData_${building.replace(/\s+/g, '')}_${mode}`;
			},
			
			// Compatibility settings
			preserveFixedGrid: false,  // ไม่บังคับใช้ fixed grid ถ้า admin มีข้อมูล
			allowDynamicNodes: true,   // อนุญาตให้ admin เพิ่ม nodes ได้
			maxDataAge: 24 * 60 * 60 * 1000, // 24 ชั่วโมง (milliseconds)
			
			// Status tracking
			lastConversionError: null,
			conversionCount: 0,
			debugMode: true
		};
	
	// 🎯 Waypoint Navigation Enhancement
	// เพิ่มจุดนำทางและปรับปรุงการรักษาจุดปลายทาง

	// ========== 1. Waypoint System Configuration ==========

	const WAYPOINT_SYSTEM = {
		enabled: true,                    // เปิด/ปิดการแสดง waypoints
		showWaypoints: true,             // แสดง waypoints หรือไม่
		waypointInterval: 15,            // ระยะห่างระหว่าง waypoints (เมตร)
		minWaypoints: 2,                 // จำนวน waypoints ขั้นต่ำ
		maxWaypoints: 8,                 // จำนวน waypoints สูงสุด
		waypointSize: 0.8,               // ขนาด waypoint marker
		animationEnabled: true,          // เปิด/ปิด animation
		showLabels: false,               // แสดงหมายเลข waypoint หรือไม่
		autoHide: false                  // ซ่อน waypoints อัตโนมัติหลังจากเวลาหนึ่ง
	};

	// Waypoint visual styles
	const WAYPOINT_STYLES = {
		fill: '#fbbf24',                 // สีเหลืองทอง
		stroke: '#ffffff',               // ขอบสีขาว
		strokeWidth: '0.2',
		opacity: '0.9',
		pulseColor: '#f59e0b',          // สีเรืองแสง
		labelColor: '#1f2937',          // สีข้อความ
		labelSize: '6px'
	};
	
	// ========== Phase 2.3: Index Google Sheets Integration ==========
	// 🎯 Mission: เชื่อม index.html กับ Google Sheets สำหรับ routing system
	// 🔧 Target: Smart caching + Background loading + Error resilience + Performance optimization

	// ========== 1. Index Sheets Configuration ==========

	// เพิ่มใน sheetsConfig object (แก้ไข existing sheetsConfig หรือเพิ่มถ้าไม่มี)
	const INDEX_SHEETS_CONFIG = {
		// ใช้ sheetsConfig ที่มีอยู่แล้ว หรือ fallback
		url: (typeof sheetsConfig !== 'undefined' && sheetsConfig.url) ? sheetsConfig.url : '',
		connected: (typeof sheetsConfig !== 'undefined') ? sheetsConfig.connected : false,
		
		// Index-specific settings
		indexEnabled: true,
		backgroundSync: true,
		cacheTimeout: 300000,  // 5 minutes
		loadTimeout: 8000,     // 8 seconds
		retryAttempts: 3,
		
		// Performance settings
		enableSmartCache: true,
		preloadOnInit: true,
		offlineMode: false,
		
		// Index sync status
		indexSyncStatus: 'idle', // idle, loading, success, error, offline
		lastIndexSync: null,
		indexSyncErrors: [],
		
		// Cache metadata
		cacheStatus: 'empty', // empty, loading, fresh, stale, error
		cacheTimestamp: null,
		cacheBuilding: null
	};

	// ========== 2. Core Index Sheets Functions ==========

	// โหลด walkable data จาก Google Sheets สำหรับ index.html
	async function loadWalkableDataFromSheetsForIndex(building) {
		building = building || getCurrentBuildingName();
		
		// ตรวจสอบ sheets connection
		if (!INDEX_SHEETS_CONFIG.url || !INDEX_SHEETS_CONFIG.connected) {
			debugLogIndex('⚠️ Sheets not configured, using offline mode');
			INDEX_SHEETS_CONFIG.offlineMode = true;
			return await loadWalkableDataWithCacheFallback(building);
		}
		
		INDEX_SHEETS_CONFIG.indexSyncStatus = 'loading';
		updateIndexSyncStatus();
		
		try {
			debugLogIndex(`📥 Loading walkable data from sheets for routing: ${building}`);
			
			const params = new URLSearchParams();
			params.append('action', 'getWalkableData');
			params.append('building', building);
			
			const response = await Promise.race([
				fetch(INDEX_SHEETS_CONFIG.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				}),
				new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Timeout')), INDEX_SHEETS_CONFIG.loadTimeout)
				)
			]);
			
			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}
			
			const result = await response.json();
			
			if (result.success && result.data) {
				// แปลงเป็น index format ถ้าจำเป็น
				let indexData = result.data;
				if (indexData.dataSource !== 'index') {
					indexData = convertAdminToIndexFormat(indexData) || indexData;
				}
				
				// เพิ่ม index metadata
				indexData.dataSource = 'sheets';
				indexData.syncTime = new Date().toISOString();
				indexData.loadedVia = 'sheets';
				indexData.currentBuilding = building;
				
				// Cache data สำหรับ offline use
				await cacheWalkableDataForOffline(indexData, building);
				
				// อัปเดต walkableRoutingData
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					
					// Trigger route recalculation ถ้ามี current route
					if (typeof recalculateCurrentRoute === 'function') {
						recalculateCurrentRoute();
					}
				}
				
				INDEX_SHEETS_CONFIG.indexSyncStatus = 'success';
				INDEX_SHEETS_CONFIG.lastIndexSync = new Date().toISOString();
				
				debugLogIndex('✅ Loaded walkable data from sheets for routing:', {
					nodes: Object.keys(indexData.nodes || {}).length,
					edges: (indexData.edges || []).length,
					building: building
				});
				
				updateIndexSyncStatus();
				showIndexNotification('📥 โหลดข้อมูลจุดเดินจาก Google Sheets สำเร็จ', 'success');
				
				return indexData;
				
			} else {
				throw new Error(result.error || 'Invalid response format');
			}
			
		} catch (error) {
			INDEX_SHEETS_CONFIG.indexSyncStatus = 'error';
			INDEX_SHEETS_CONFIG.indexSyncErrors.push({
				timestamp: new Date().toISOString(),
				operation: 'loadFromSheets',
				error: error.message,
				building: building
			});
			
			debugLogIndex('❌ Failed to load from sheets:', error);
			updateIndexSyncStatus();
			
			// Fallback to cached data
			debugLogIndex('🔄 Falling back to cached data...');
			return await loadWalkableDataWithCacheFallback(building);
		}
	}

	// Cache walkable data สำหรับ offline mode
	async function cacheWalkableDataForOffline(data, building) {
		if (!data || !INDEX_SHEETS_CONFIG.enableSmartCache) return false;
		
		try {
			building = building || data.currentBuilding || getCurrentBuildingName();
			
			const cacheData = {
				...data,
				cacheTimestamp: new Date().toISOString(),
				cacheBuilding: building,
				cacheSource: 'sheets',
				cacheVersion: '1.3'
			};
			
			// บันทึกใน localStorage ด้วย index key format
			const indexKey = getSafeStorageKey(building, 'index');
			const cacheKey = `${indexKey}_cache`;
			
			localStorage.setItem(cacheKey, JSON.stringify(cacheData));
			localStorage.setItem(indexKey, JSON.stringify(cacheData));
			
			INDEX_SHEETS_CONFIG.cacheStatus = 'fresh';
			INDEX_SHEETS_CONFIG.cacheTimestamp = new Date().toISOString();
			INDEX_SHEETS_CONFIG.cacheBuilding = building;
			
			debugLogIndex('💾 Cached walkable data for offline use:', {
				building: building,
				nodes: Object.keys(data.nodes || {}).length,
				cacheKey: cacheKey
			});
			
			return true;
			
		} catch (error) {
			debugLogIndex('❌ Failed to cache data:', error);
			INDEX_SHEETS_CONFIG.cacheStatus = 'error';
			return false;
		}
	}

	// โหลดข้อมูลพร้อม cache fallback
	async function loadWalkableDataWithCacheFallback(building) {
		building = building || getCurrentBuildingName();
		
		try {
			// ลองใช้ cache ก่อน
			const indexKey = getSafeStorageKey(building, 'index');
			const cacheKey = `${indexKey}_cache`;
			
			// ลำดับการโหลด: Recent cache → Index storage → Admin sync → Fixed grid
			
			// 1. ลอง recent cache ก่อน
			const cachedDataString = localStorage.getItem(cacheKey);
			if (cachedDataString) {
				const cachedData = JSON.parse(cachedDataString);
				
				// ตรวจสอบว่า cache ยังใหม่หรือไม่
				const cacheAge = Date.now() - new Date(cachedData.cacheTimestamp || 0).getTime();
				const isCacheFresh = cacheAge < INDEX_SHEETS_CONFIG.cacheTimeout;
				
				if (isCacheFresh || INDEX_SHEETS_CONFIG.offlineMode) {
					// Cache ยังใหม่ หรือ offline mode
					if (typeof walkableRoutingData !== 'undefined') {
						Object.assign(walkableRoutingData, cachedData);
					}
					
					INDEX_SHEETS_CONFIG.cacheStatus = isCacheFresh ? 'fresh' : 'stale';
					debugLogIndex(`✅ Loaded from ${isCacheFresh ? 'fresh' : 'stale'} cache`, {
						building: building,
						age: Math.round(cacheAge / 1000) + 's'
					});
					
					return cachedData;
				}
			}
			
			// 2. ลอง index storage
			const indexDataString = localStorage.getItem(indexKey);
			if (indexDataString) {
				const indexData = JSON.parse(indexDataString);
				
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
				}
				
				debugLogIndex('📁 Loaded from index storage');
				return indexData;
			}
			
			// 3. ลอง sync จาก admin data
			const adminSynced = syncAdminDataToIndex(building);
			if (adminSynced && typeof walkableRoutingData !== 'undefined' && walkableRoutingData.nodes) {
				debugLogIndex('🔄 Loaded via admin sync');
				return walkableRoutingData;
			}
			
			// 4. สุดท้าย สร้าง fixed grid
			debugLogIndex('🗂️ No cached data, creating fixed grid fallback');
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
				return walkableRoutingData;
			}
			
			return null;
			
		} catch (error) {
			debugLogIndex('❌ Error in cache fallback:', error);
			INDEX_SHEETS_CONFIG.cacheStatus = 'error';
			return null;
		}
	}

	// ========== 3. Enhanced Loading with Background Sync ==========

	// โหลดข้อมูล walkable พร้อม sheets sync (แทนที่ function เดิม)
	async function loadWalkableDataWithSheetsSync(building) {
		building = building || getCurrentBuildingName();
		
		debugLogIndex('🚀 Loading walkable data with sheets sync...', { building });
		
		// ถ้าเปิด background sync ให้โหลด cache ก่อน แล้ว sync ใน background
		if (INDEX_SHEETS_CONFIG.backgroundSync && INDEX_SHEETS_CONFIG.connected) {
			// โหลด cache ก่อนเพื่อให้ UI responsive
			const cachedData = await loadWalkableDataWithCacheFallback(building);
			
			if (cachedData) {
				// มีข้อมูล cache ให้ใช้ก่อน
				debugLogIndex('⚡ Using cached data for immediate display');
				
				// Background sync (ไม่ block UI)
				setTimeout(async () => {
					try {
						const freshData = await loadWalkableDataFromSheetsForIndex(building);
						if (freshData && JSON.stringify(freshData.nodes) !== JSON.stringify(cachedData.nodes)) {
							debugLogIndex('🔄 Background sync updated data');
							showIndexNotification('🆕 ข้อมูลจุดเดินได้รับการอัปเดต', 'info');
						}
					} catch (error) {
						debugLogIndex('⚠️ Background sync failed, using cached data');
					}
				}, 100);
				
				return cachedData;
			}
		}
		
		// ถ้าไม่มี cache หรือไม่เปิด background sync ให้โหลดตรงจาก sheets
		return await loadWalkableDataFromSheetsForIndex(building);
	}

	// ========== 4. Validation and Error Handling ==========

	// ตรวจสอบความถูกต้องของ walkable data จาก sheets
	async function validateWalkableDataFromSheets(data) {
		if (!data || typeof data !== 'object') {
			return { valid: false, errors: ['Invalid data structure'] };
		}
		
		const errors = [];
		const warnings = [];
		
		// ตรวจสอบ nodes
		if (!data.nodes || typeof data.nodes !== 'object') {
			errors.push('Missing or invalid nodes object');
		} else {
			const nodeCount = Object.keys(data.nodes).length;
			if (nodeCount === 0) {
				warnings.push('No nodes found');
			} else if (nodeCount < 2) {
				warnings.push('Too few nodes for routing');
			}
			
			// ตรวจสอบ node structure
			for (const nodeId in data.nodes) {
				const node = data.nodes[nodeId];
				if (typeof node.x !== 'number' || typeof node.y !== 'number') {
					errors.push(`Node ${nodeId} has invalid coordinates`);
				}
			}
		}
		
		// ตรวจสอบ edges
		if (!Array.isArray(data.edges)) {
			errors.push('Missing or invalid edges array');
		} else if (data.edges.length === 0) {
			warnings.push('No edges found - routing may not work');
		}
		
		// ตรวจสอบ settings
		if (data.settings && typeof data.settings === 'object') {
			if (data.settings.metersPerPercent && data.settings.metersPerPercent <= 0) {
				errors.push('Invalid metersPerPercent setting');
			}
		}
		
		const result = {
			valid: errors.length === 0,
			errors: errors,
			warnings: warnings,
			nodeCount: Object.keys(data.nodes || {}).length,
			edgeCount: (data.edges || []).length
		};
		
		debugLogIndex('🔍 Data validation result:', result);
		return result;
	}

	// Fallback ไป localStorage เมื่อ sheets unavailable
	function fallbackToLocalStorageIfSheetsUnavailable() {
		if (INDEX_SHEETS_CONFIG.connected) return false;
		
		debugLogIndex('📱 Sheets unavailable, enabling offline mode');
		INDEX_SHEETS_CONFIG.offlineMode = true;
		INDEX_SHEETS_CONFIG.indexSyncStatus = 'offline';
		
		const building = getCurrentBuildingName();
		const data = loadWalkableDataWithCacheFallback(building);
		
		if (data) {
			showIndexNotification('📱 ใช้งานในโหมดออฟไลน์', 'info');
			return true;
		}
		
		showIndexNotification('⚠️ ไม่พบข้อมูลจุดเดิน', 'warning');
		return false;
	}

	// ========== 5. Performance Optimization ==========

	// เร่งความเร็วการคำนวณ route
	function optimizeRouteCalculationPerformance() {
		// ใช้ Web Workers ถ้าได้ (ถ้าไม่ได้ใช้ setTimeout)
		if (typeof Worker !== 'undefined' && typeof calculateShortestPath === 'function') {
			// อัปเดต calculateShortestPath ให้เร็วขึ้น
			const originalCalculate = window.calculateShortestPath;
			
			window.calculateShortestPath = function(startId, endId) {
				const startTime = performance.now();
				
				try {
					const result = originalCalculate.call(this, startId, endId);
					
					const endTime = performance.now();
					const duration = endTime - startTime;
					
					// Track performance
					if (duration > 500) {
						debugLogIndex(`⚠️ Slow route calculation: ${duration.toFixed(2)}ms`);
					} else {
						debugLogIndex(`⚡ Route calculated in: ${duration.toFixed(2)}ms`);
					}
					
					return result;
					
				} catch (error) {
					debugLogIndex('❌ Route calculation error:', error);
					return null;
				}
			};
		}
	}

	// ========== 6. UI Integration และ Status Indicators ==========

	// อัปเดต sync status UI
	function updateIndexSyncStatus() {
		// หา sync status elements หรือสร้างถ้าไม่มี
		let statusElement = document.getElementById('indexSyncStatus');
		if (!statusElement) {
			// สร้าง status indicator ใหม่
			statusElement = document.createElement('div');
			statusElement.id = 'indexSyncStatus';
			statusElement.style.cssText = `
				position: fixed; top: 10px; right: 10px; 
				padding: 8px 12px; border-radius: 6px; 
				font-size: 12px; z-index: 1000;
				transition: all 0.3s ease;
			`;
			document.body.appendChild(statusElement);
		}
		
		// อัปเดต status indicator
		const status = INDEX_SHEETS_CONFIG.indexSyncStatus;
		const lastSync = INDEX_SHEETS_CONFIG.lastIndexSync;
		
		let text, bgColor, textColor;
		
		switch (status) {
			case 'loading':
				text = '🔄 กำลังโหลด...';
				bgColor = '#3498db';
				textColor = 'white';
				break;
			case 'success':
				const timeAgo = lastSync ? Math.round((Date.now() - new Date(lastSync).getTime()) / 1000) : 0;
				text = `✅ อัปเดต ${timeAgo}s`;
				bgColor = '#2ecc71';
				textColor = 'white';
				break;
			case 'error':
				text = '❌ ข้อผิดพลาด';
				bgColor = '#e74c3c';
				textColor = 'white';
				break;
			case 'offline':
				text = '📱 ออฟไลน์';
				bgColor = '#f39c12';
				textColor = 'white';
				break;
			default:
				text = '⏸️ รอ';
				bgColor = '#95a5a6';
				textColor = 'white';
		}
		
		statusElement.textContent = text;
		statusElement.style.backgroundColor = bgColor;
		statusElement.style.color = textColor;
		
		// ซ่อน status หลัง 5 วินาทีถ้า success
		if (status === 'success') {
			setTimeout(() => {
				statusElement.style.opacity = '0.3';
			}, 5000);
		} else {
			statusElement.style.opacity = '1';
		}
	}

	// แสดง notification สำหรับ index operations
	function showIndexNotification(message, type = 'info') {
		// ใช้ existing notification system หรือสร้างใหม่
		if (typeof showNotification === 'function') {
			showNotification(message, type);
		} else if (typeof showProgressiveStatus === 'function') {
			showProgressiveStatus(message, type);
		} else {
			// Fallback notification
			console.log(`[Index] ${message}`);
			
			// สร้าง simple toast notification
			const toast = document.createElement('div');
			toast.textContent = message;
			toast.style.cssText = `
				position: fixed; bottom: 20px; left: 20px;
				background: ${type === 'success' ? '#2ecc71' : type === 'error' ? '#e74c3c' : '#3498db'};
				color: white; padding: 12px 20px; border-radius: 6px;
				z-index: 1001; animation: slideIn 0.3s ease;
			`;
			
			document.body.appendChild(toast);
			setTimeout(() => {
				toast.style.animation = 'slideOut 0.3s ease';
				setTimeout(() => toast.remove(), 300);
			}, 3000);
		}
	}

	// ========== 7. Enhanced Integration Functions ==========

	// แทนที่ loadWalkableData เดิมด้วยเวอร์ชันที่รองรับ sheets
	async function loadWalkableDataWithSheetsIntegration() {
		const building = getCurrentBuildingName();
		debugLogIndex('🎯 Loading walkable data with sheets integration...', { building });
		
		// ถ้าเปิดใช้ sheets ให้ลองโหลดจาก sheets ก่อน
		if (INDEX_SHEETS_CONFIG.indexEnabled && INDEX_SHEETS_CONFIG.connected) {
			const sheetsData = await loadWalkableDataWithSheetsSync(building);
			if (sheetsData) {
				return sheetsData;
			}
		}
		
		// Fallback ไปใช้ Phase 2.1 functions
		if (typeof loadWalkableDataWithAdminSyncV2 === 'function') {
			return loadWalkableDataWithAdminSyncV2(building);
		}
		
		// สุดท้าย fallback ไปใช้ cache
		return await loadWalkableDataWithCacheFallback(building);
	}

	// ========== 8. Connection Management ==========

	// เชื่อมต่อไป Google Sheets (สำหรับ index.html)
	async function connectToGoogleSheetsForIndex() {
		debugLogIndex('🔗 Connecting to Google Sheets for index...');
		
		// ใช้ existing sheetsConfig ถ้ามี
		if (typeof sheetsConfig !== 'undefined' && sheetsConfig.url) {
			INDEX_SHEETS_CONFIG.url = sheetsConfig.url;
			INDEX_SHEETS_CONFIG.connected = sheetsConfig.connected;
		}
		
		// ตรวจสอบ connection
		if (INDEX_SHEETS_CONFIG.url && INDEX_SHEETS_CONFIG.connected) {
			debugLogIndex('✅ Using existing sheets connection');
			return true;
		}
		
		// ถ้าไม่มี connection ให้เข้าโหมด offline
		debugLogIndex('📱 No sheets connection, enabling offline mode');
		INDEX_SHEETS_CONFIG.connected = false;
		INDEX_SHEETS_CONFIG.offlineMode = true;
		
		return false;
	}

	// Monitor connection status
	function monitorIndexSheetsConnection() {
		setInterval(async () => {
			if (INDEX_SHEETS_CONFIG.url && !INDEX_SHEETS_CONFIG.offlineMode) {
				try {
					// Simple ping test
					const response = await fetch(INDEX_SHEETS_CONFIG.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: 'action=ping'
					});
					
					const wasConnected = INDEX_SHEETS_CONFIG.connected;
					INDEX_SHEETS_CONFIG.connected = response.ok;
					
					// แจ้งเตือนเมื่อ connection เปลี่ยน
					if (!wasConnected && INDEX_SHEETS_CONFIG.connected) {
						showIndexNotification('✅ เชื่อมต่อ Google Sheets แล้ว', 'success');
						INDEX_SHEETS_CONFIG.offlineMode = false;
					} else if (wasConnected && !INDEX_SHEETS_CONFIG.connected) {
						showIndexNotification('📱 ขาดการเชื่อมต่อ เข้าโหมดออฟไลน์', 'warning');
						INDEX_SHEETS_CONFIG.offlineMode = true;
					}
					
				} catch (error) {
					INDEX_SHEETS_CONFIG.connected = false;
					INDEX_SHEETS_CONFIG.offlineMode = true;
				}
			}
		}, 30000); // ตรวจสอบทุก 30 วินาที
	}

	// ========== 9. Initialization และ Integration ==========

	// เริ่มต้น Index Sheets System
	async function initializeIndexSheetsSystem() {
		debugLogIndex('🚀 Initializing Index Sheets System...');
		
		try {
			// เชื่อมต่อ Google Sheets
			await connectToGoogleSheetsForIndex();
			
			// เริ่ม connection monitoring
			monitorIndexSheetsConnection();
			
			// Optimize route calculation
			optimizeRouteCalculationPerformance();
			
			// โหลดข้อมูลเริ่มต้น
			if (INDEX_SHEETS_CONFIG.preloadOnInit) {
				const building = getCurrentBuildingName();
				await loadWalkableDataWithSheetsIntegration();
			}
			
			// เพิ่ม debug commands
			if (ADMIN_INDEX_BRIDGE && ADMIN_INDEX_BRIDGE.debugMode) {
				window.loadWalkableDataFromSheetsForIndex = loadWalkableDataFromSheetsForIndex;
				window.INDEX_SHEETS_CONFIG = INDEX_SHEETS_CONFIG;
				window.cacheWalkableDataForOffline = cacheWalkableDataForOffline;
				window.validateWalkableDataFromSheets = validateWalkableDataFromSheets;
			}
			
			debugLogIndex('✅ Index Sheets System initialized successfully');
			
		} catch (error) {
			debugLogIndex('❌ Failed to initialize Index Sheets System:', error);
			// Fallback to offline mode
			INDEX_SHEETS_CONFIG.offlineMode = true;
			fallbackToLocalStorageIfSheetsUnavailable();
		}
	}

	// Helper function สำหรับ debug
	function debugLogIndex(message, data = null) {
		if (ADMIN_INDEX_BRIDGE && ADMIN_INDEX_BRIDGE.debugMode) {
			const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
			const prefix = `[${timestamp}] IndexSheets:`;
			
			if (data) {
				console.log(prefix, message, data);
			} else {
				console.log(prefix, message);
			}
		}
	}

	// ========== 10. Function Replacements และ Integration ==========

	// แทนที่ functions เดิมด้วยเวอร์ชันที่รองรับ sheets
	if (typeof window !== 'undefined') {
		// Backup original functions
		window.originalLoadWalkableData = window.loadWalkableData;
		window.originalLoadInitialData = window.loadInitialData;
		
		// Replace with enhanced versions
		window.loadWalkableData = loadWalkableDataWithSheetsIntegration;
		
		// Add new functions
		window.loadWalkableDataFromSheetsForIndex = loadWalkableDataFromSheetsForIndex;
		window.INDEX_SHEETS_CONFIG = INDEX_SHEETS_CONFIG;
		window.initializeIndexSheetsSystem = initializeIndexSheetsSystem;
	}

	// Auto-initialize เมื่อ DOM ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initializeIndexSheetsSystem);
	} else {
		// DOM ready แล้ว ให้ init ทันที
		setTimeout(initializeIndexSheetsSystem, 100);
	}

	// ========== End Phase 2.3: Index Google Sheets Integration ==========
	
	// ========== Phase 2.4: Cross-System Sync + Production Polish ==========
	// 🎯 Mission: Advanced sync mechanisms + Production-ready polish + Testing framework
	// 🔧 Target: Real-time sync + Conflict resolution + Health monitoring + Comprehensive testing

	// ========== 1. Advanced Cross-System Sync Manager ==========

	const CROSS_SYSTEM_SYNC = {
		// Sync configuration
		enabled: true,
		realTimeSync: true,
		conflictResolution: 'timestamp', // timestamp, user-prompt, admin-priority
		syncInterval: 5000, // 5 seconds
		
		// Sync state tracking
		syncInProgress: false,
		lastSyncTime: null,
		syncQueue: [],
		conflictQueue: [],
		
		// Health monitoring
		syncHealth: 'healthy', // healthy, degraded, offline, error
		syncSuccessRate: 100,
		totalSyncAttempts: 0,
		successfulSyncs: 0,
		failedSyncs: 0,
		
		// Performance tracking
		avgSyncTime: 0,
		syncTimes: [],
		maxSyncTime: 0,
		
		// Error tracking
		syncErrors: [],
		maxErrors: 50
	};

	// ========== 2. Real-time Sync Flow Implementation ==========

	// Main sync orchestrator: Admin → Sheets → Index
	async function orchestrateCrossSystemSync(building, sourceData, sourceType) {
		if (CROSS_SYSTEM_SYNC.syncInProgress) {
			debugLogSync('⏸️ Sync already in progress, queuing...');
			CROSS_SYSTEM_SYNC.syncQueue.push({ building, sourceData, sourceType, timestamp: Date.now() });
			return;
		}
		
		CROSS_SYSTEM_SYNC.syncInProgress = true;
		CROSS_SYSTEM_SYNC.totalSyncAttempts++;
		const syncStartTime = performance.now();
		
		try {
			debugLogSync(`🔄 Starting cross-system sync from ${sourceType}...`, { building });
			
			let success = true;
			const syncResults = {
				admin: false,
				sheets: false,
				index: false,
				conflicts: []
			};
			
			// Phase 1: Sync to Google Sheets (if enabled and connected)
			if (INDEX_SHEETS_CONFIG.connected && sourceType !== 'sheets') {
				try {
					const sheetsResult = await syncToGoogleSheets(sourceData, building, sourceType);
					syncResults.sheets = sheetsResult.success;
					
					if (!sheetsResult.success) {
						debugLogSync('⚠️ Sheets sync failed:', sheetsResult.error);
					}
				} catch (error) {
					debugLogSync('❌ Sheets sync error:', error);
					syncResults.sheets = false;
				}
			}
			
			// Phase 2: Sync to other formats
			if (sourceType === 'admin') {
				// Admin → Index format conversion และ sync
				try {
					const indexData = convertAdminToIndexFormat(sourceData);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						syncResults.index = true;
						
						// Trigger index refresh ถ้าอยู่ใน index.html
						if (ADMIN_INDEX_BRIDGE.isIndexMode() && typeof walkableRoutingData !== 'undefined') {
							Object.assign(walkableRoutingData, indexData);
							if (typeof recalculateCurrentRoute === 'function') {
								recalculateCurrentRoute();
							}
						}
					}
				} catch (error) {
					debugLogSync('❌ Admin→Index sync error:', error);
					syncResults.index = false;
					success = false;
				}
				
			} else if (sourceType === 'index') {
				// Index → Admin format conversion และ sync
				try {
					const adminData = convertIndexToAdminFormat(sourceData);
					if (adminData) {
						const adminKey = getSafeStorageKey(building, 'admin');
						localStorage.setItem(adminKey, JSON.stringify(adminData));
						syncResults.admin = true;
						
						// Trigger admin refresh ถ้าอยู่ใน admin.html
						if (ADMIN_INDEX_BRIDGE.isAdminMode() && typeof walkablePointsData !== 'undefined') {
							Object.assign(walkablePointsData, adminData);
							if (typeof renderUI === 'function') {
								renderUI();
							}
						}
					}
				} catch (error) {
					debugLogSync('❌ Index→Admin sync error:', error);
					syncResults.admin = false;
					success = false;
				}
				
			} else if (sourceType === 'sheets') {
				// Sheets → Both admin และ index
				try {
					// Convert to admin format
					const adminData = sourceData.dataSource === 'admin' ? sourceData : convertIndexToAdminFormat(sourceData);
					if (adminData) {
						const adminKey = getSafeStorageKey(building, 'admin');
						localStorage.setItem(adminKey, JSON.stringify(adminData));
						syncResults.admin = true;
					}
					
					// Convert to index format
					const indexData = sourceData.dataSource === 'index' ? sourceData : convertAdminToIndexFormat(sourceData);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						syncResults.index = true;
					}
					
				} catch (error) {
					debugLogSync('❌ Sheets→Local sync error:', error);
					success = false;
				}
			}
			
			// Update sync statistics
			const syncTime = performance.now() - syncStartTime;
			updateSyncStatistics(success, syncTime);
			
			// Update last sync time
			CROSS_SYSTEM_SYNC.lastSyncTime = new Date().toISOString();
			
			debugLogSync(`✅ Cross-system sync completed in ${syncTime.toFixed(2)}ms`, syncResults);
			
			return { success, results: syncResults, syncTime };
			
		} catch (error) {
			debugLogSync('❌ Cross-system sync failed:', error);
			CROSS_SYSTEM_SYNC.failedSyncs++;
			updateSyncHealth('error');
			
			// Log error
			logSyncError('crossSystemSync', error, { building, sourceType });
			
			return { success: false, error: error.message };
			
		} finally {
			CROSS_SYSTEM_SYNC.syncInProgress = false;
			
			// Process queue
			if (CROSS_SYSTEM_SYNC.syncQueue.length > 0) {
				const nextSync = CROSS_SYSTEM_SYNC.syncQueue.shift();
				setTimeout(() => {
					orchestrateCrossSystemSync(nextSync.building, nextSync.sourceData, nextSync.sourceType);
				}, 100);
			}
		}
	}

	// Sync to Google Sheets
	async function syncToGoogleSheets(data, building, sourceType) {
		try {
			// Use admin's saveWalkableDataToSheets function ถ้ามี
			if (typeof saveWalkableDataToSheets === 'function') {
				const result = await saveWalkableDataToSheets(data);
				return { success: result, source: 'admin-function' };
			}
			
			// หรือเรียก API ตรงๆ
			const params = new URLSearchParams();
			params.append('action', 'saveWalkableData');
			params.append('building', building);
			params.append('nodes', JSON.stringify(data.nodes || {}));
			params.append('edges', JSON.stringify(data.edges || []));
			params.append('settings', JSON.stringify(data.settings || {}));
			
			const response = await fetch(INDEX_SHEETS_CONFIG.url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: params.toString()
			});
			
			const result = await response.json();
			return { success: result.success, source: 'direct-api', result };
			
		} catch (error) {
			return { success: false, error: error.message };
		}
	}

	// ========== 3. Conflict Resolution System ==========

	// ตรวจหา sync conflicts
	async function detectSyncConflicts(building) {
		const conflicts = [];
		
		try {
			// ดึงข้อมูลจากทุก sources
			const sources = {
				admin: null,
				index: null,
				sheets: null
			};
			
			// Admin data
			const adminKey = getSafeStorageKey(building, 'admin');
			const adminDataString = localStorage.getItem(adminKey);
			if (adminDataString) {
				sources.admin = JSON.parse(adminDataString);
			}
			
			// Index data
			const indexKey = getSafeStorageKey(building, 'index');
			const indexDataString = localStorage.getItem(indexKey);
			if (indexDataString) {
				sources.index = JSON.parse(indexDataString);
			}
			
			// Sheets data (ถ้าเชื่อมต่อได้)
			if (INDEX_SHEETS_CONFIG.connected) {
				sources.sheets = await loadWalkableDataFromSheetsForIndex(building);
			}
			
			// เปรียบเทียบ timestamps และ node counts
			const timestamps = {};
			const nodeCounts = {};
			
			for (const [source, data] of Object.entries(sources)) {
				if (data) {
					timestamps[source] = new Date(data.syncTime || data.timestamp || 0).getTime();
					nodeCounts[source] = Object.keys(data.nodes || {}).length;
				}
			}
			
			// หา conflicts
			const sourceKeys = Object.keys(sources).filter(key => sources[key]);
			
			if (sourceKeys.length > 1) {
				// ตรวจสอบ timestamp conflicts
				const timestampValues = Object.values(timestamps);
				const uniqueTimestamps = [...new Set(timestampValues)];
				
				if (uniqueTimestamps.length > 1) {
					conflicts.push({
						type: 'timestamp',
						description: 'Different sync timestamps detected',
						sources: sourceKeys,
						timestamps: timestamps
					});
				}
				
				// ตรวจสอบ data conflicts
				const nodeCountValues = Object.values(nodeCounts);
				const uniqueNodeCounts = [...new Set(nodeCountValues)];
				
				if (uniqueNodeCounts.length > 1) {
					conflicts.push({
						type: 'nodeCount',
						description: 'Different node counts detected',
						sources: sourceKeys,
						nodeCounts: nodeCounts
					});
				}
			}
			
			return conflicts;
			
		} catch (error) {
			debugLogSync('❌ Error detecting conflicts:', error);
			return [];
		}
	}

	// แก้ไข sync conflicts
	async function resolveSyncConflicts(building, conflicts) {
		if (!conflicts || conflicts.length === 0) return true;
		
		debugLogSync('🔧 Resolving sync conflicts...', conflicts);
		
		for (const conflict of conflicts) {
			try {
				let winningSource = null;
				
				switch (CROSS_SYSTEM_SYNC.conflictResolution) {
					case 'timestamp':
						// ใช้ข้อมูลที่มี timestamp ใหม่ที่สุด
						winningSource = Object.entries(conflict.timestamps || {})
							.sort(([,a], [,b]) => b - a)[0]?.[0];
						break;
						
					case 'admin-priority':
						// Admin มี priority สูงสุด
						winningSource = conflict.sources.includes('admin') ? 'admin' : 
									  conflict.sources.includes('sheets') ? 'sheets' : 
									  conflict.sources[0];
						break;
						
					case 'user-prompt':
						// ถาม user (ถ้าไม่ได้อยู่ใน background)
						winningSource = await promptUserForConflictResolution(conflict);
						break;
				}
				
				if (winningSource) {
					debugLogSync(`🎯 Resolving conflict using ${winningSource} data`);
					
					// โหลดข้อมูลจาก winning source และ sync ไปทุกที่
					let winningData = null;
					
					if (winningSource === 'admin') {
						const adminKey = getSafeStorageKey(building, 'admin');
						const adminDataString = localStorage.getItem(adminKey);
						winningData = adminDataString ? JSON.parse(adminDataString) : null;
					} else if (winningSource === 'index') {
						const indexKey = getSafeStorageKey(building, 'index');
						const indexDataString = localStorage.getItem(indexKey);
						winningData = indexDataString ? JSON.parse(indexDataString) : null;
					} else if (winningSource === 'sheets') {
						winningData = await loadWalkableDataFromSheetsForIndex(building);
					}
					
					if (winningData) {
						// Sync winning data ไปทุก sources
						await orchestrateCrossSystemSync(building, winningData, winningSource);
					}
				}
				
			} catch (error) {
				debugLogSync('❌ Error resolving conflict:', error);
				logSyncError('conflictResolution', error, conflict);
			}
		}
		
		return true;
	}

	// ========== 4. Sync Health Monitoring ==========

	// อัปเดต sync statistics
	function updateSyncStatistics(success, syncTime) {
		if (success) {
			CROSS_SYSTEM_SYNC.successfulSyncs++;
		} else {
			CROSS_SYSTEM_SYNC.failedSyncs++;
		}
		
		// Calculate success rate
		const totalSyncs = CROSS_SYSTEM_SYNC.successfulSyncs + CROSS_SYSTEM_SYNC.failedSyncs;
		CROSS_SYSTEM_SYNC.syncSuccessRate = totalSyncs > 0 ? 
			(CROSS_SYSTEM_SYNC.successfulSyncs / totalSyncs) * 100 : 100;
		
		// Track sync times
		if (syncTime) {
			CROSS_SYSTEM_SYNC.syncTimes.push(syncTime);
			
			// Keep only last 20 sync times
			if (CROSS_SYSTEM_SYNC.syncTimes.length > 20) {
				CROSS_SYSTEM_SYNC.syncTimes.shift();
			}
			
			// Calculate average
			CROSS_SYSTEM_SYNC.avgSyncTime = CROSS_SYSTEM_SYNC.syncTimes.reduce((a, b) => a + b, 0) / CROSS_SYSTEM_SYNC.syncTimes.length;
			
			// Track max time
			CROSS_SYSTEM_SYNC.maxSyncTime = Math.max(CROSS_SYSTEM_SYNC.maxSyncTime, syncTime);
		}
		
		// Update health status
		if (CROSS_SYSTEM_SYNC.syncSuccessRate >= 90) {
			updateSyncHealth('healthy');
		} else if (CROSS_SYSTEM_SYNC.syncSuccessRate >= 70) {
			updateSyncHealth('degraded');
		} else {
			updateSyncHealth('error');
		}
	}

	// อัปเดต sync health status
	function updateSyncHealth(newStatus) {
		const oldStatus = CROSS_SYSTEM_SYNC.syncHealth;
		CROSS_SYSTEM_SYNC.syncHealth = newStatus;
		
		if (oldStatus !== newStatus) {
			debugLogSync(`🏥 Sync health changed: ${oldStatus} → ${newStatus}`);
			
			// แจ้งเตือนถ้า health แย่ลง
			if (newStatus === 'error' || newStatus === 'degraded') {
				showSyncHealthAlert(newStatus);
			}
		}
	}

	// แสดง sync health alert
	function showSyncHealthAlert(status) {
		const messages = {
			degraded: '⚠️ ประสิทธิภาพการซิงค์ลดลง',
			error: '❌ ระบบซิงค์มีปัญหา',
			offline: '📱 ระบบซิงค์ออฟไลน์'
		};
		
		const message = messages[status] || 'ℹ️ สถานะซิงค์เปลี่ยนแปลง';
		
		if (typeof showIndexNotification === 'function') {
			showIndexNotification(message, status === 'error' ? 'error' : 'warning');
		}
	}

	// Log sync errors
	function logSyncError(operation, error, context) {
		const errorEntry = {
			timestamp: new Date().toISOString(),
			operation: operation,
			error: error.message || error.toString(),
			context: context,
			syncHealth: CROSS_SYSTEM_SYNC.syncHealth
		};
		
		CROSS_SYSTEM_SYNC.syncErrors.push(errorEntry);
		
		// Keep only recent errors
		if (CROSS_SYSTEM_SYNC.syncErrors.length > CROSS_SYSTEM_SYNC.maxErrors) {
			CROSS_SYSTEM_SYNC.syncErrors.shift();
		}
		
		debugLogSync('📝 Logged sync error:', errorEntry);
	}

	// ========== 5. Comprehensive Testing Framework ==========

	const TESTING_FRAMEWORK = {
		// Test configuration
		enabled: true,
		autoRunOnInit: false,
		verbose: true,
		
		// Test results
		testResults: [],
		totalTests: 0,
		passedTests: 0,
		failedTests: 0,
		
		// Test categories
		testCategories: {
			dataConversion: [],
			syncOperations: [],
			errorHandling: [],
			performance: [],
			integration: []
		}
	};

	// Main testing suite
	async function runComprehensiveTestSuite() {
		debugLogSync('🧪 Starting comprehensive test suite...');
		
		TESTING_FRAMEWORK.testResults = [];
		TESTING_FRAMEWORK.totalTests = 0;
		TESTING_FRAMEWORK.passedTests = 0;
		TESTING_FRAMEWORK.failedTests = 0;
		
		try {
			// Test categories
			await testDataConversionSuite();
			await testSyncOperationsSuite();
			await testErrorHandlingSuite();
			await testPerformanceSuite();
			await testIntegrationSuite();
			
			// Generate test report
			const report = generateTestReport();
			debugLogSync('📊 Test suite completed:', report);
			
			return report;
			
		} catch (error) {
			debugLogSync('❌ Test suite failed:', error);
			return { success: false, error: error.message };
		}
	}

	// Test data conversion functions
	async function testDataConversionSuite() {
		debugLogSync('🔄 Testing data conversion...');
		
		// Test admin → index conversion
		await runTest('adminToIndexConversion', () => {
			const testAdminData = {
				nodes: { '1': { id: '1', x: 10, y: 20, type: 'grid' } },
				edges: [{ from: '1', to: '2', weight: 15 }],
				settings: { metersPerPercent: 1.2 },
				currentBuilding: 'Test Building'
			};
			
			const indexData = convertAdminToIndexFormat(testAdminData);
			
			if (!indexData || !indexData.nodes || !indexData.nodes['1']) {
				throw new Error('Conversion failed or missing nodes');
			}
			
			if (indexData.currentBuilding !== 'Test Building') {
				throw new Error('Building name not preserved');
			}
			
			return { success: true, data: indexData };
		});
		
		// Test index → admin conversion
		await runTest('indexToAdminConversion', () => {
			const testIndexData = {
				nodes: { '1': { id: '1', x: 10, y: 20, type: 'grid' } },
				edges: [{ from: '1', to: '2', weight: 15 }],
				settings: { metersPerPercent: 1.2 },
				currentBuilding: 'Test Building'
			};
			
			const adminData = convertIndexToAdminFormat(testIndexData);
			
			if (!adminData || !adminData.nodes || !adminData.nodes['1']) {
				throw new Error('Conversion failed or missing nodes');
			}
			
			return { success: true, data: adminData };
		});
		
		// Test round-trip conversion
		await runTest('roundTripConversion', () => {
			const originalData = {
				nodes: { '1': { id: '1', x: 10, y: 20, type: 'grid' } },
				edges: [{ from: '1', to: '2', weight: 15 }],
				currentBuilding: 'Test Building'
			};
			
			const indexData = convertAdminToIndexFormat(originalData);
			const backToAdmin = convertIndexToAdminFormat(indexData);
			
			if (!backToAdmin || !backToAdmin.nodes || !backToAdmin.nodes['1']) {
				throw new Error('Round-trip conversion failed');
			}
			
			// Check if key data is preserved
			if (backToAdmin.nodes['1'].x !== originalData.nodes['1'].x) {
				throw new Error('Data integrity lost in round-trip');
			}
			
			return { success: true };
		});
	}

	// Test sync operations
	async function testSyncOperationsSuite() {
		debugLogSync('🔄 Testing sync operations...');
		
		// Test localStorage sync
		await runTest('localStorageSync', () => {
			const testBuilding = 'Test Building';
			const testData = {
				nodes: { 'test1': { id: 'test1', x: 5, y: 10 } },
				edges: [],
				currentBuilding: testBuilding
			};
			
			// Test admin → index sync
			const adminKey = getSafeStorageKey(testBuilding, 'admin');
			localStorage.setItem(adminKey, JSON.stringify(testData));
			
			const synced = syncAdminDataToIndex(testBuilding);
			
			if (!synced) {
				throw new Error('Admin to index sync failed');
			}
			
			// Verify index data
			const indexKey = getSafeStorageKey(testBuilding, 'index');
			const indexDataString = localStorage.getItem(indexKey);
			
			if (!indexDataString) {
				throw new Error('Index data not found after sync');
			}
			
			// Cleanup
			localStorage.removeItem(adminKey);
			localStorage.removeItem(indexKey);
			
			return { success: true };
		});
		
		// Test conflict detection
		await runTest('conflictDetection', async () => {
			const testBuilding = 'Test Building Conflict';
			
			// Create conflicting data
			const adminData = { 
				nodes: { '1': { id: '1', x: 10, y: 20 } }, 
				syncTime: '2024-01-01T10:00:00Z',
				currentBuilding: testBuilding 
			};
			const indexData = { 
				nodes: { '1': { id: '1', x: 15, y: 25 }, '2': { id: '2', x: 30, y: 40 } }, 
				syncTime: '2024-01-01T11:00:00Z',
				currentBuilding: testBuilding 
			};
			
			// Save conflicting data
			const adminKey = getSafeStorageKey(testBuilding, 'admin');
			const indexKey = getSafeStorageKey(testBuilding, 'index');
			localStorage.setItem(adminKey, JSON.stringify(adminData));
			localStorage.setItem(indexKey, JSON.stringify(indexData));
			
			// Detect conflicts
			const conflicts = await detectSyncConflicts(testBuilding);
			
			if (!conflicts || conflicts.length === 0) {
				throw new Error('Failed to detect conflicts');
			}
			
			// Cleanup
			localStorage.removeItem(adminKey);
			localStorage.removeItem(indexKey);
			
			return { success: true, conflicts: conflicts.length };
		});
	}

	// Test error handling
	async function testErrorHandlingSuite() {
		debugLogSync('🛡️ Testing error handling...');
		
		// Test invalid data handling
		await runTest('invalidDataHandling', () => {
			// Test with null data
			const result1 = convertAdminToIndexFormat(null);
			if (result1 !== null) {
				throw new Error('Should return null for invalid input');
			}
			
			// Test with malformed data
			const result2 = convertAdminToIndexFormat({ invalid: 'data' });
			if (result2 !== null) {
				throw new Error('Should return null for malformed data');
			}
			
			return { success: true };
		});
		
		// Test network failure handling
		await runTest('networkFailureHandling', async () => {
			// Temporarily break connection
			const originalUrl = INDEX_SHEETS_CONFIG.url;
			INDEX_SHEETS_CONFIG.url = 'https://invalid-url-for-testing.com';
			
			try {
				const result = await loadWalkableDataFromSheetsForIndex('Test Building');
				
				// Should fail gracefully and return null or cached data
				if (result && result.error) {
					// Good - error was handled
					return { success: true, handledGracefully: true };
				} else if (result === null) {
					// Also good - returned null as expected
					return { success: true, returnedNull: true };
				} else {
					throw new Error('Network failure not handled properly');
				}
				
			} finally {
				// Restore connection
				INDEX_SHEETS_CONFIG.url = originalUrl;
			}
		});
	}

	// Test performance
	async function testPerformanceSuite() {
		debugLogSync('⚡ Testing performance...');
		
		// Test route calculation performance
		await runTest('routeCalculationPerformance', () => {
			// Create test data with many nodes
			const testNodes = {};
			for (let i = 1; i <= 50; i++) {
				testNodes[i.toString()] = {
					id: i.toString(),
					x: (i % 10) * 10,
					y: Math.floor(i / 10) * 10,
					type: 'grid'
				};
			}
			
			// Mock walkableRoutingData
			const originalData = window.walkableRoutingData;
			window.walkableRoutingData = {
				nodes: testNodes,
				edges: []
			};
			
			try {
				// Test route calculation time
				const startTime = performance.now();
				
				if (typeof calculateShortestPath === 'function') {
					calculateShortestPath('1', '50');
				}
				
				const endTime = performance.now();
				const calculationTime = endTime - startTime;
				
				// Should be under 500ms as per requirements
				if (calculationTime > 500) {
					throw new Error(`Route calculation too slow: ${calculationTime.toFixed(2)}ms > 500ms`);
				}
				
				return { success: true, time: calculationTime };
				
			} finally {
				// Restore original data
				window.walkableRoutingData = originalData;
			}
		});
		
		// Test data conversion performance
		await runTest('dataConversionPerformance', () => {
			// Create large test data
			const largeData = {
				nodes: {},
				edges: [],
				currentBuilding: 'Performance Test'
			};
			
			for (let i = 1; i <= 100; i++) {
				largeData.nodes[i.toString()] = {
					id: i.toString(),
					x: Math.random() * 100,
					y: Math.random() * 100,
					type: 'grid'
				};
			}
			
			// Test conversion time
			const startTime = performance.now();
			const converted = convertAdminToIndexFormat(largeData);
			const endTime = performance.now();
			
			const conversionTime = endTime - startTime;
			
			if (!converted) {
				throw new Error('Conversion failed');
			}
			
			// Should be reasonably fast
			if (conversionTime > 100) {
				throw new Error(`Data conversion too slow: ${conversionTime.toFixed(2)}ms > 100ms`);
			}
			
			return { success: true, time: conversionTime, nodeCount: 100 };
		});
	}

	// Test integration
	async function testIntegrationSuite() {
		debugLogSync('🔗 Testing integration...');
		
		// Test end-to-end workflow
		await runTest('endToEndWorkflow', async () => {
			const testBuilding = 'E2E Test Building';
			
			try {
				// 1. Create admin data
				const adminData = {
					nodes: { 'e2e1': { id: 'e2e1', x: 10, y: 20, type: 'entrance' } },
					edges: [],
					currentBuilding: testBuilding,
					dataSource: 'admin',
					syncTime: new Date().toISOString()
				};
				
				// 2. Save admin data
				const adminKey = getSafeStorageKey(testBuilding, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(adminData));
				
				// 3. Sync to index
				const syncResult = syncAdminDataToIndex(testBuilding);
				if (!syncResult) {
					throw new Error('Failed to sync admin to index');
				}
				
				// 4. Verify index data
				const indexKey = getSafeStorageKey(testBuilding, 'index');
				const indexDataString = localStorage.getItem(indexKey);
				if (!indexDataString) {
					throw new Error('Index data not found');
				}
				
				const indexData = JSON.parse(indexDataString);
				if (!indexData.nodes || !indexData.nodes['e2e1']) {
					throw new Error('Index data structure invalid');
				}
				
				// 5. Test cross-system sync
				const crossSyncResult = await orchestrateCrossSystemSync(testBuilding, adminData, 'admin');
				if (!crossSyncResult.success) {
					throw new Error('Cross-system sync failed');
				}
				
				return { success: true, steps: 5 };
				
			} finally {
				// Cleanup
				const adminKey = getSafeStorageKey(testBuilding, 'admin');
				const indexKey = getSafeStorageKey(testBuilding, 'index');
				localStorage.removeItem(adminKey);
				localStorage.removeItem(indexKey);
			}
		});
	}

	// Helper function to run individual test
	async function runTest(testName, testFunction) {
		TESTING_FRAMEWORK.totalTests++;
		
		try {
			debugLogSync(`🧪 Running test: ${testName}`);
			
			const startTime = performance.now();
			const result = await testFunction();
			const endTime = performance.now();
			
			const testResult = {
				name: testName,
				status: 'passed',
				duration: endTime - startTime,
				result: result,
				timestamp: new Date().toISOString()
			};
			
			TESTING_FRAMEWORK.testResults.push(testResult);
			TESTING_FRAMEWORK.passedTests++;
			
			debugLogSync(`✅ Test passed: ${testName} (${testResult.duration.toFixed(2)}ms)`);
			
		} catch (error) {
			const testResult = {
				name: testName,
				status: 'failed',
				error: error.message,
				timestamp: new Date().toISOString()
			};
			
			TESTING_FRAMEWORK.testResults.push(testResult);
			TESTING_FRAMEWORK.failedTests++;
			
			debugLogSync(`❌ Test failed: ${testName} - ${error.message}`);
		}
	}

	// Generate test report
	function generateTestReport() {
		const report = {
			summary: {
				total: TESTING_FRAMEWORK.totalTests,
				passed: TESTING_FRAMEWORK.passedTests,
				failed: TESTING_FRAMEWORK.failedTests,
				successRate: TESTING_FRAMEWORK.totalTests > 0 ? 
					(TESTING_FRAMEWORK.passedTests / TESTING_FRAMEWORK.totalTests) * 100 : 0
			},
			results: TESTING_FRAMEWORK.testResults,
			timestamp: new Date().toISOString()
		};
		
		// Log summary
		debugLogSync('📊 Test Report Summary:', {
			total: report.summary.total,
			passed: report.summary.passed,
			failed: report.summary.failed,
			successRate: `${report.summary.successRate.toFixed(1)}%`
		});
		
		return report;
	}

	// ========== 6. Debug และ Monitoring Tools ==========

	// Comprehensive system status
	function getSystemStatus() {
		return {
			// Phase status
			phases: {
				phase21: 'complete', // Data bridge
				phase22: 'complete', // Admin sheets
				phase23: 'complete', // Index sheets
				phase24: 'complete'  // Cross-system sync
			},
			
			// Connection status
			connections: {
				sheetsConnected: INDEX_SHEETS_CONFIG.connected,
				offlineMode: INDEX_SHEETS_CONFIG.offlineMode,
				adminMode: ADMIN_INDEX_BRIDGE.isAdminMode(),
				indexMode: ADMIN_INDEX_BRIDGE.isIndexMode()
			},
			
			// Sync status
			sync: {
				health: CROSS_SYSTEM_SYNC.syncHealth,
				successRate: CROSS_SYSTEM_SYNC.syncSuccessRate,
				lastSync: CROSS_SYSTEM_SYNC.lastSyncTime,
				avgSyncTime: CROSS_SYSTEM_SYNC.avgSyncTime,
				totalSyncs: CROSS_SYSTEM_SYNC.totalSyncAttempts
			},
			
			// Cache status
			cache: {
				status: INDEX_SHEETS_CONFIG.cacheStatus,
				timestamp: INDEX_SHEETS_CONFIG.cacheTimestamp,
				building: INDEX_SHEETS_CONFIG.cacheBuilding
			},
			
			// Error status
			errors: {
				syncErrors: CROSS_SYSTEM_SYNC.syncErrors.length,
				indexErrors: INDEX_SHEETS_CONFIG.indexSyncErrors.length,
				recentErrors: [...CROSS_SYSTEM_SYNC.syncErrors.slice(-3)]
			}
		};
	}

	// Debug sync status
	function debugSyncStatus() {
		const status = getSystemStatus();
		
		console.group('🔍 Smart School Map System Status');
		console.log('📋 Phases:', status.phases);
		console.log('🔗 Connections:', status.connections);
		console.log('🔄 Sync:', status.sync);
		console.log('💾 Cache:', status.cache);
		console.log('⚠️ Errors:', status.errors);
		console.groupEnd();
		
		return status;
	}

	// Helper function สำหรับ debug
	function debugLogSync(message, data = null) {
		if (ADMIN_INDEX_BRIDGE && ADMIN_INDEX_BRIDGE.debugMode) {
			const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
			const prefix = `[${timestamp}] CrossSync:`;
			
			if (data) {
				console.log(prefix, message, data);
			} else {
				console.log(prefix, message);
			}
		}
	}

	// ========== 7. Auto-Initialization และ Global Integration ==========

	// Initialize Cross-System Sync
	async function initializeCrossSystemSync() {
		debugLogSync('🚀 Initializing Cross-System Sync...');
		
		try {
			// Auto-detect และ repair conflicts
			const building = getCurrentBuildingName();
			const conflicts = await detectSyncConflicts(building);
			
			if (conflicts.length > 0) {
				debugLogSync(`🔧 Found ${conflicts.length} conflicts, resolving...`);
				await resolveSyncConflicts(building, conflicts);
			}
			
			// Start periodic sync monitoring
			if (CROSS_SYSTEM_SYNC.realTimeSync) {
				setInterval(async () => {
					try {
						const building = getCurrentBuildingName();
						const conflicts = await detectSyncConflicts(building);
						
						if (conflicts.length > 0) {
							await resolveSyncConflicts(building, conflicts);
						}
					} catch (error) {
						debugLogSync('⚠️ Periodic sync check failed:', error);
					}
				}, CROSS_SYSTEM_SYNC.syncInterval);
			}
			
			// Run tests ถ้าเปิดใช้
			if (TESTING_FRAMEWORK.autoRunOnInit) {
				setTimeout(() => runComprehensiveTestSuite(), 2000);
			}
			
			debugLogSync('✅ Cross-System Sync initialized successfully');
			
			// เพิ่ม global functions
			window.orchestrateCrossSystemSync = orchestrateCrossSystemSync;
			window.debugSyncStatus = debugSyncStatus;
			window.runComprehensiveTestSuite = runComprehensiveTestSuite;
			window.CROSS_SYSTEM_SYNC = CROSS_SYSTEM_SYNC;
			
			return true;
			
		} catch (error) {
			debugLogSync('❌ Failed to initialize Cross-System Sync:', error);
			return false;
		}
	}

/*
	// Auto-initialize
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			setTimeout(initializeCrossSystemSync, 200);
		});
	} else {
		setTimeout(initializeCrossSystemSync, 200);
	}
*/

	// ========== End Phase 2.4: Cross-System Sync + Production Polish ==========


	// ========== ERROR FIX: SVG Routing Markers + Data Validation ==========
	// 🎯 Mission: แก้ไข "undefined" cx attribute error ในระบบ routing
	// 🔧 Target: Safe data validation + Error-free routing + Graceful fallbacks

	// ========== 1. Safe Data Validation Functions ==========

	// ตรวจสอบและแก้ไข node data
	function validateAndFixNodeData(nodeId, nodeData) {
		if (!nodeData || typeof nodeData !== 'object') {
			console.warn(`Invalid node data for ${nodeId}:`, nodeData);
			return null;
		}
		
		// แก้ไข missing coordinates
		const fixedNode = { ...nodeData };
		
		// ตรวจสอบ x coordinate
		if (typeof fixedNode.x !== 'number' || isNaN(fixedNode.x)) {
			console.warn(`Invalid x coordinate for node ${nodeId}:`, fixedNode.x);
			fixedNode.x = 50; // Default center x
		}
		
		// ตรวจสอบ y coordinate  
		if (typeof fixedNode.y !== 'number' || isNaN(fixedNode.y)) {
			console.warn(`Invalid y coordinate for node ${nodeId}:`, fixedNode.y);
			fixedNode.y = 50; // Default center y
		}
		
		// ตรวจสอบ id
		if (!fixedNode.id) {
			fixedNode.id = nodeId;
		}
		
		// ตรวจสอบ type
		if (!fixedNode.type) {
			fixedNode.type = 'grid';
		}
		
		return fixedNode;
	}

	// ตรวจสอบความถูกต้องของ walkableRoutingData
	function validateWalkableRoutingData() {
		if (typeof walkableRoutingData === 'undefined') {
			console.error('walkableRoutingData is undefined, initializing...');
			window.walkableRoutingData = {
				nodes: {},
				edges: [],
				currentBuilding: getCurrentBuildingName(),
				isInitialized: false
			};
			return false;
		}
		
		if (!walkableRoutingData.nodes || typeof walkableRoutingData.nodes !== 'object') {
			console.error('walkableRoutingData.nodes is invalid, fixing...');
			walkableRoutingData.nodes = {};
			return false;
		}
		
		if (!Array.isArray(walkableRoutingData.edges)) {
			console.error('walkableRoutingData.edges is invalid, fixing...');
			walkableRoutingData.edges = [];
			return false;
		}
		
		// ตรวจสอบและแก้ไข nodes
		let fixedNodes = 0;
		for (const nodeId in walkableRoutingData.nodes) {
			const originalNode = walkableRoutingData.nodes[nodeId];
			const fixedNode = validateAndFixNodeData(nodeId, originalNode);
			
			if (fixedNode && (fixedNode.x !== originalNode.x || fixedNode.y !== originalNode.y)) {
				walkableRoutingData.nodes[nodeId] = fixedNode;
				fixedNodes++;
			} else if (!fixedNode) {
				console.warn(`Removing invalid node: ${nodeId}`);
				delete walkableRoutingData.nodes[nodeId];
			}
		}
		
		if (fixedNodes > 0) {
			console.log(`Fixed ${fixedNodes} nodes with invalid coordinates`);
		}
		
		return true;
	}

	// ========== 2. Safe Node Retrieval Functions ==========

	// ดึง node อย่างปลอดภัย
	function getSafeNode(nodeId) {
		if (!nodeId) {
			console.warn('Node ID is empty or undefined');
			return null;
		}
		
		// ตรวจสอบ walkableRoutingData
		if (!validateWalkableRoutingData()) {
			console.error('Cannot get node: walkableRoutingData is invalid');
			return null;
		}
		
		const node = walkableRoutingData.nodes[nodeId];
		if (!node) {
			console.warn(`Node not found: ${nodeId}`);
			return null;
		}
		
		// ตรวจสอบและแก้ไข node data
		return validateAndFixNodeData(nodeId, node);
	}

	// ดึง coordinates อย่างปลอดภัย
	function getSafeNodeCoordinates(nodeId) {
		const node = getSafeNode(nodeId);
		if (!node) {
			console.warn(`Cannot get coordinates for node: ${nodeId}`);
			return { x: 50, y: 50 }; // Default center coordinates
		}
		
		return {
			x: typeof node.x === 'number' ? node.x : 50,
			y: typeof node.y === 'number' ? node.y : 50
		};
	}

	// ========== 3. Enhanced Route Marker Functions ==========

	// แทนที่ addRouteMarkers เดิมด้วย safe version
	function addRouteMarkersSafe(path, svgElement) {
		if (!path || !Array.isArray(path) || path.length === 0) {
			console.warn('Invalid path for route markers:', path);
			return;
		}
		
		if (!svgElement) {
			console.warn('SVG element not provided for route markers');
			return;
		}
		
		try {
			// ตรวจสอบ walkableRoutingData ก่อน
			if (!validateWalkableRoutingData()) {
				console.error('Cannot add route markers: invalid walkableRoutingData');
				return;
			}
			
			path.forEach((nodeId, index) => {
				if (!nodeId) {
					console.warn(`Empty node ID at path index ${index}`);
					return;
				}
				
				const coords = getSafeNodeCoordinates(nodeId);
				
				// สร้าง marker circle
				const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				
				// ใช้ safe coordinates
				marker.setAttribute('cx', coords.x.toString());
				marker.setAttribute('cy', coords.y.toString());
				marker.setAttribute('r', '3');
				marker.setAttribute('class', 'route-marker');
				
				// กำหนดสีตาม position ใน path
				if (index === 0) {
					marker.setAttribute('fill', '#00ff00'); // Start - Green
				} else if (index === path.length - 1) {
					marker.setAttribute('fill', '#ff0000'); // End - Red
				} else {
					marker.setAttribute('fill', '#ffff00'); // Middle - Yellow
				}
				
				marker.setAttribute('stroke', '#000000');
				marker.setAttribute('stroke-width', '1');
				
				svgElement.appendChild(marker);
			});
			
			console.log(`Added ${path.length} route markers successfully`);
			
		} catch (error) {
			console.error('Error adding route markers:', error);
			console.error('Path data:', path);
		}
	}

	// ========== 4. Enhanced Route Display Functions ==========

	// Safe version ของ showStraightRoutePath
	function showStraightRoutePathSafe(startNodeId, endNodeId) {
		try {
			console.log(`Showing route: ${startNodeId} → ${endNodeId}`);
			
			// ตรวจสอบ node IDs
			if (!startNodeId || !endNodeId) {
				throw new Error('Start or end node ID is missing');
			}
			
			// ตรวจสอบ nodes existence
			const startCoords = getSafeNodeCoordinates(startNodeId);
			const endCoords = getSafeNodeCoordinates(endNodeId);
			
			// หา SVG element
			const svg = document.querySelector('.floor-map svg') || 
					   document.querySelector('svg') ||
					   document.getElementById('floorPlanSvg');
			
			if (!svg) {
				throw new Error('SVG element not found');
			}
			
			// ลบ route เก่า
			clearExistingRoute(svg);
			
			// สร้าง route line
			const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			line.setAttribute('x1', startCoords.x.toString());
			line.setAttribute('y1', startCoords.y.toString());
			line.setAttribute('x2', endCoords.x.toString());
			line.setAttribute('y2', endCoords.y.toString());
			line.setAttribute('stroke', '#ff0000');
			line.setAttribute('stroke-width', '3');
			line.setAttribute('stroke-dasharray', '5,5');
			line.setAttribute('class', 'route-line');
			
			svg.appendChild(line);
			
			// เพิ่ม markers
			addRouteMarkersSafe([startNodeId, endNodeId], svg);
			
			// แสดงระยะทาง
			const distance = calculateDistanceBetweenNodes(startNodeId, endNodeId);
			showRouteInfo(startNodeId, endNodeId, distance, 'straight');
			
			console.log('Straight route displayed successfully');
			
		} catch (error) {
			console.error('Error showing straight route:', error);
			showErrorNotification('ไม่สามารถแสดงเส้นทางได้: ' + error.message);
		}
	}

	// Safe version ของ showRouteToSelected
	function showRouteToSelectedSafe(targetNodeId) {
		try {
			console.log(`Showing route to selected node: ${targetNodeId}`);
			
			if (!targetNodeId) {
				throw new Error('Target node ID is missing');
			}
			
			// หา starting point (ใช้ center หรือ entrance)
			const startNodeId = findBestStartingPoint();
			
			if (!startNodeId) {
				throw new Error('Cannot find starting point');
			}
			
			// ใช้ Dijkstra algorithm ถ้ามี
			if (typeof calculateShortestPath === 'function') {
				const path = calculateShortestPath(startNodeId, targetNodeId);
				
				if (path && path.length > 0) {
					showCalculatedRouteSafe(path);
				} else {
					console.warn('No path found, showing straight line');
					showStraightRoutePath(getSafeNodeCoordinates(startNodeId), getSafeNodeCoordinates(targetNodeId));
				}
			} else {
				// Fallback ไป straight line
				console.warn('calculateShortestPath not available, showing straight line');
				showStraightRoutePath(getSafeNodeCoordinates(startNodeId), getSafeNodeCoordinates(targetNodeId));
			}
			
		} catch (error) {
			console.error('Error showing route to selected:', error);
			showStraightRoutePath(getSafeNodeCoordinates(startNodeId), getSafeNodeCoordinates(targetNodeId));
		}
	}

	// แสดง calculated route อย่างปลอดภัย
	function showCalculatedRouteSafe(path) {
		if (!path || !Array.isArray(path) || path.length === 0) {
			console.warn('Invalid calculated path:', path);
			return;
		}
		
		try {
			const svg = document.querySelector('.floor-map svg') || 
					   document.querySelector('svg') ||
					   document.getElementById('floorPlanSvg');
			
			if (!svg) {
				throw new Error('SVG element not found');
			}
			
			// ลบ route เก่า
			clearExistingRoute(svg);
			
			// สร้าง polyline สำหรับ path
			const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
			const points = [];
			
			path.forEach(nodeId => {
				const coords = getSafeNodeCoordinates(nodeId);
				points.push(`${coords.x},${coords.y}`);
			});
			
			polyline.setAttribute('points', points.join(' '));
			polyline.setAttribute('fill', 'none');
			polyline.setAttribute('stroke', '#0066cc');
			polyline.setAttribute('stroke-width', '4');
			polyline.setAttribute('stroke-linejoin', 'round');
			polyline.setAttribute('class', 'route-path');
			
			svg.appendChild(polyline);
			
			// เพิ่ม markers
			addRouteMarkersSafe(path, svg);
			
			// คำนวณระยะทาง
			const totalDistance = calculatePathDistance(path);
			showRouteInfo(path[0], path[path.length - 1], totalDistance, 'calculated');
			
			console.log(`Calculated route displayed with ${path.length} nodes`);
			
		} catch (error) {
			console.error('Error showing calculated route:', error);
			showErrorNotification('ไม่สามารถแสดงเส้นทางที่คำนวณได้: ' + error.message);
		}
	}

	// ========== 5. Helper Functions ==========

	// หา starting point ที่ดีที่สุด
	function findBestStartingPoint() {
		if (!validateWalkableRoutingData()) {
			return null;
		}
		
		const nodes = walkableRoutingData.nodes;
		
		// ลำดับความสำคัญ: center → entrance → grid → อื่นๆ
		const priorities = ['center', 'entrance', 'grid'];
		
		for (const type of priorities) {
			for (const nodeId in nodes) {
				const node = nodes[nodeId];
				if (node && node.type === type) {
					return nodeId;
				}
			}
		}
		
		// ถ้าไม่เจอ ใช้ node แรกที่มี
		const firstNodeId = Object.keys(nodes)[0];
		return firstNodeId || null;
	}

	// คำนวณระยะทางระหว่าง nodes
	function calculateDistanceBetweenNodes(nodeId1, nodeId2) {
		const coords1 = getSafeNodeCoordinates(nodeId1);
		const coords2 = getSafeNodeCoordinates(nodeId2);
		
		const dx = coords2.x - coords1.x;
		const dy = coords2.y - coords1.y;
		const percentDistance = Math.sqrt(dx * dx + dy * dy);
		
		// แปลงเป็นเมตร
		const metersPerPercent = (walkableRoutingData.settings && walkableRoutingData.settings.metersPerPercent) || 1.2;
		return percentDistance * metersPerPercent;
	}

	// คำนวณระยะทางของ path ทั้งหมด
	function calculatePathDistance(path) {
		if (!path || path.length < 2) return 0;
		
		let totalDistance = 0;
		for (let i = 0; i < path.length - 1; i++) {
			totalDistance += calculateDistanceBetweenNodes(path[i], path[i + 1]);
		}
		
		return totalDistance;
	}

	// ลบ route เก่า
	function clearExistingRoute(svg) {
		if (!svg) return;
		
		try {
			// ลบ route elements
			const routeElements = svg.querySelectorAll('.route-line, .route-path, .route-marker');
			routeElements.forEach(element => element.remove());
			
			// ลบ old route elements (ถ้ามี)
			const oldRoutes = svg.querySelectorAll('line[stroke="#ff0000"], polyline[stroke="#0066cc"]');
			oldRoutes.forEach(element => element.remove());
			
		} catch (error) {
			console.warn('Error clearing existing route:', error);
		}
	}

	// แสดงข้อมูล route
	function showRouteInfo(startNodeId, endNodeId, distance, routeType) {
		try {
			const routeInfo = document.getElementById('routeInfo') || createRouteInfoElement();
			
			const startNode = getSafeNode(startNodeId);
			const endNode = getSafeNode(endNodeId);
			
			const startName = (startNode && startNode.name) || startNodeId;
			const endName = (endNode && endNode.name) || endNodeId;
			
			routeInfo.innerHTML = `
				<div class="route-info-content">
					<h4>🗺️ ข้อมูลเส้นทาง</h4>
					<p><strong>จาก:</strong> ${startName}</p>
					<p><strong>ไป:</strong> ${endName}</p>
					<p><strong>ระยะทาง:</strong> ${distance.toFixed(1)} เมตร</p>
					<p><strong>ประเภท:</strong> ${routeType === 'calculated' ? 'เส้นทางที่คำนวณ' : 'เส้นตรง'}</p>
				</div>
			`;
			
			routeInfo.style.display = 'block';
			
		} catch (error) {
			console.warn('Error showing route info:', error);
		}
	}

	// สร้าง route info element
	function createRouteInfoElement() {
		const routeInfo = document.createElement('div');
		routeInfo.id = 'routeInfo';
		routeInfo.style.cssText = `
			position: fixed;
			top: 80px;
			right: 20px;
			background: white;
			border: 2px solid #0066cc;
			border-radius: 8px;
			padding: 15px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.15);
			z-index: 1000;
			max-width: 250px;
			font-family: Arial, sans-serif;
			display: none;
		`;
		
		document.body.appendChild(routeInfo);
		return routeInfo;
	}

	// แสดง error notification
	function showErrorNotification(message) {
		console.error(message);
		
		// ใช้ existing notification system ถ้ามี
		if (typeof showNotification === 'function') {
			showNotification(message, 'error');
		} else if (typeof showIndexNotification === 'function') {
			showIndexNotification(message, 'error');
		} else {
			// Fallback alert
			alert(message);
		}
	}

	// ========== 6. Data Recovery Functions ==========

	// กู้คืนข้อมูล walkable ถ้าเสียหาย
	async function recoverWalkableData() {
		console.log('🔧 Attempting to recover walkable data...');
		
		try {
			const building = getCurrentBuildingName();
			
			// ลำดับการกู้คืน: Sheets → Admin cache → Index cache → Fixed grid
			
			// 1. ลองโหลดจาก Sheets
			if (typeof loadWalkableDataFromSheetsForIndex === 'function') {
				const sheetsData = await loadWalkableDataFromSheetsForIndex(building);
				if (sheetsData && sheetsData.nodes && Object.keys(sheetsData.nodes).length > 0) {
					console.log('✅ Recovered data from Google Sheets');
					return true;
				}
			}
			
			// 2. ลองใช้ Phase 2.1 sync functions
			if (typeof syncAdminDataToIndex === 'function') {
				const synced = syncAdminDataToIndex(building);
				if (synced) {
					console.log('✅ Recovered data from admin sync');
					return true;
				}
			}
			
			// 3. ลองโหลดจาก cache
			if (typeof loadWalkableDataWithCacheFallback === 'function') {
				const cacheData = await loadWalkableDataWithCacheFallback(building);
				if (cacheData && cacheData.nodes && Object.keys(cacheData.nodes).length > 0) {
					console.log('✅ Recovered data from cache');
					return true;
				}
			}
			
			// 4. สุดท้าย สร้าง fixed grid
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
				console.log('✅ Created fixed grid as fallback');
				return true;
			}
			
			console.warn('❌ Could not recover walkable data');
			return false;
			
		} catch (error) {
			console.error('❌ Error during data recovery:', error);
			return false;
		}
	}

	// ========== 7. Function Replacements ==========

	// แทนที่ functions เดิมด้วย safe versions
	if (typeof window !== 'undefined') {
		// Backup original functions
		window.originalAddRouteMarkers = window.addRouteMarkers;
		window.originalShowStraightRoutePath = window.showStraightRoutePath;
		window.originalShowRouteToSelected = window.showRouteToSelected;
		
		// Replace with safe versions
		window.addRouteMarkers = addRouteMarkersSafe;
		//window.showStraightRoutePath = showStraightRoutePathSafe;
		window.showRouteToSelected = showRouteToSelectedSafe;
		
		// Add new functions
		window.validateWalkableRoutingData = validateWalkableRoutingData;
		window.getSafeNode = getSafeNode;
		window.getSafeNodeCoordinates = getSafeNodeCoordinates;
		window.recoverWalkableData = recoverWalkableData;
		
		console.log('✅ Safe routing functions installed');
	}

	// ========== 8. Auto-Fix on Load ==========

	// แก้ไขข้อมูลอัตโนมัติเมื่อโหลดหน้า
	async function autoFixWalkableDataOnLoad() {
		console.log('🔧 Auto-fixing walkable data on load...');
		
		try {
			// ตรวจสอบและแก้ไขข้อมูล
			const isValid = validateWalkableRoutingData();
			
			if (!isValid) {
				console.log('⚠️ Data validation failed, attempting recovery...');
				const recovered = await recoverWalkableData();
				
				if (!recovered) {
					console.error('❌ Data recovery failed');
					showErrorNotification('ไม่สามารถโหลดข้อมูลจุดเดินได้ กรุณาลองใหม่');
					return false;
				}
			}
			
			// ตรวจสอบใหม่หลัง recovery
			const finalValidation = validateWalkableRoutingData();
			if (finalValidation) {
				console.log('✅ Walkable data is now valid');
				
				// แสดง notification
				if (typeof showIndexNotification === 'function') {
					showIndexNotification('✅ ระบบนำทางพร้อมใช้งาน', 'success');
				}
				
				return true;
			} else {
				console.error('❌ Final validation failed');
				return false;
			}
			
		} catch (error) {
			console.error('❌ Auto-fix failed:', error);
			return false;
		}
	}

	// เรียก auto-fix เมื่อ DOM ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			setTimeout(autoFixWalkableDataOnLoad, 500);
		});
	} else {
		setTimeout(autoFixWalkableDataOnLoad, 500);
	}

	// ========== End Error Fix: SVG Routing Markers + Data Validation ==========

	// ปรับปรุงการรักษาจุดปลายทาง
	function ensurePersistentDestination() {
		// ตรวจสอบว่ามีจุดปลายทางที่เลือกไว้หรือไม่
		if (!selectedRoom && persistentDestination && persistentDestination.roomCode) {
			selectedRoom = persistentDestination.roomCode;
			debugLog('🎯 Restored persistent destination:', persistentDestination.roomName);
			
			// อัปเดต UI เพื่อแสดงว่ามีปลายทางอยู่
			updateDestinationDisplay();
			return true;
		}
		
		return selectedRoom && roomData[selectedRoom];
	}

	// ปรับปรุงการอัปเดตจุดเริ่มต้นให้รักษาปลายทาง
	function enhancedUpdateStartPointWithAutoRoute(x, y) {
		debugLog('📍 Enhanced start point update with persistent destination...', { 
			x: x.toFixed(2), 
			y: y.toFixed(2) 
		});
		
		// ตรวจสอบและรักษาจุดปลายทาง
		const hasDestination = ensurePersistentDestination();
		autoRouteUpdate.hasActiveDestination = hasDestination;
		
		// อัปเดตจุดเริ่มต้น (ซ่อนจากผู้ใช้)
		const oldStartPoint = startPoint ? { ...startPoint } : null;
		startPoint = {
			name: currentLanguage === 'th' ? 'จุดเริ่มต้น' : 'Starting Point',
			x: x,
			y: y,
			hidden: true,
			timestamp: Date.now()
		};
		
		// บันทึกลง localStorage
		localStorage.setItem('startPoint', JSON.stringify(startPoint));
		autoRouteUpdate.lastStartPoint = { ...startPoint };
		
		// อัปเดต UI markers (ไม่แสดงจุดเริ่มต้น)
		updateStartPointMarker(x, y);
		
		// ถ้ามีปลายทางอยู่แล้ว ให้อัปเดตเส้นทางอัตโนมัติ
		if (hasDestination && autoRouteUpdate.enabled) {
			debugLog('🔄 Auto-updating route with persistent destination...', {
				destination: persistentDestination.roomName || selectedRoom,
				startPoint: { x: x.toFixed(2), y: y.toFixed(2) }
			});
			
			// แสดง brief notification
			const destination = roomData[selectedRoom];
			const message = currentLanguage === 'th' 
				? `🔄 อัปเดตเส้นทางไปยัง ${destination.name}`
				: `🔄 Route updated to ${destination.name}`;
			showNotification(message, 'info', 2000); // แสดง 2 วินาที
			
			// อัปเดตเส้นทางหลังจาก delay เล็กน้อย
			setTimeout(() => {
				enhancedAutoUpdateRoute();
			}, autoRouteUpdate.updateDelay);
			
		} else {
			// ไม่มีปลายทาง แสดง notification ให้เลือกปลายทาง
			updateRouteControls();
			
			const message = currentLanguage === 'th' 
				? `📍 เปลี่ยนจุดเริ่มต้นแล้ว - กรุณาเลือกจุดหมาย`
				: `📍 Start point updated - Please select destination`;
			showNotification(message, 'success');
		}
	}

	// ========== 3. Waypoint Generation System ==========

	// สร้าง waypoints บนเส้นทาง
	function generateWaypoints(pathNodeIds) {
		if (!WAYPOINT_SYSTEM.enabled || !WAYPOINT_SYSTEM.showWaypoints) {
			return [];
		}
		
		const waypoints = [];
		const pathPoints = pathNodeIds.map(nodeId => walkableRoutingData.nodes[nodeId]);
		
		if (pathPoints.length < 2) return waypoints;
		
		debugLog('🎯 Generating waypoints for path...', {
			totalNodes: pathPoints.length,
			interval: WAYPOINT_SYSTEM.waypointInterval
		});
		
		// คำนวณระยะทางรวมของเส้นทาง
		let totalDistance = 0;
		const segmentDistances = [];
		
		for (let i = 0; i < pathPoints.length - 1; i++) {
			const segmentDistance = distanceBetweenPoints(pathPoints[i], pathPoints[i + 1]) 
								  * walkableRoutingData.settings.metersPerPercent;
			segmentDistances.push(segmentDistance);
			totalDistance += segmentDistance;
		}
		
		// กำหนดจำนวน waypoints ตามระยะทาง
		const optimalWaypointCount = Math.max(
			WAYPOINT_SYSTEM.minWaypoints,
			Math.min(
				WAYPOINT_SYSTEM.maxWaypoints,
				Math.floor(totalDistance / WAYPOINT_SYSTEM.waypointInterval)
			)
		);
		
		// สร้าง waypoints ที่กระจายตัวเท่าๆ กันตลอดเส้นทาง
		for (let w = 1; w <= optimalWaypointCount; w++) {
			const targetDistance = (totalDistance * w) / (optimalWaypointCount + 1);
			
			// หาตำแหน่งที่ตรงกับระยะทางเป้าหมาย
			let accumulatedDistance = 0;
			let waypointPosition = null;
			
			for (let i = 0; i < segmentDistances.length; i++) {
				const segmentStart = accumulatedDistance;
				const segmentEnd = accumulatedDistance + segmentDistances[i];
				
				if (targetDistance >= segmentStart && targetDistance <= segmentEnd) {
					// interpolate ตำแหน่งในส่วนนี้
					const ratio = (targetDistance - segmentStart) / segmentDistances[i];
					const pointA = pathPoints[i];
					const pointB = pathPoints[i + 1];
					
					waypointPosition = {
						x: pointA.x + (pointB.x - pointA.x) * ratio,
						y: pointA.y + (pointB.y - pointA.y) * ratio,
						segmentIndex: i,
						ratio: ratio
					};
					break;
				}
				
				accumulatedDistance += segmentDistances[i];
			}
			
			if (waypointPosition) {
				waypoints.push({
					id: `waypoint_${w}`,
					x: waypointPosition.x,
					y: waypointPosition.y,
					index: w,
					distance: targetDistance,
					segmentIndex: waypointPosition.segmentIndex,
					type: 'waypoint'
				});
			}
		}
		
		debugLog('✅ Generated waypoints:', {
			count: waypoints.length,
			totalDistance: totalDistance.toFixed(1),
			interval: (totalDistance / (waypoints.length + 1)).toFixed(1)
		});
		
		return waypoints;
	}

	// ========== 4. Enhanced Route Drawing with Waypoints ==========

	// แทนที่ฟังก์ชัน drawWalkablePath เดิม
	 function drawWalkablePathWithWaypoints(pathNodeIds) {
		const routePath = document.getElementById('routePath') || createRoutePathElement();
		if (!routePath) return;
		
		routePath.innerHTML = ''; // เคลียร์ทั้งหมดก่อน
		
		// สร้างจุดต่างๆ บนเส้นทาง
		const pathPoints = pathNodeIds.map(nodeId => walkableRoutingData.nodes[nodeId]);
		
		if (pathPoints.length < 2) return;
		
		debugLog('🎨 Drawing walkable path with waypoints...', {
			points: pathPoints.length,
			waypointsEnabled: WAYPOINT_SYSTEM.showWaypoints
		});
		
		// สร้าง SVG path
		const pathString = pathPoints.map((point, index) => {
			const command = index === 0 ? 'M' : 'L';
			return `${command} ${point.x} ${point.y}`;
		}).join(' ');
		
		// 1. Glow effect (เส้นเรืองแสง)
		const glowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		glowPath.setAttribute('d', pathString);
		glowPath.setAttribute('class', 'route-line-glow');
		glowPath.setAttribute('stroke', '#fbbf24');
		glowPath.setAttribute('stroke-width', '1.2');
		glowPath.setAttribute('fill', 'none');
		glowPath.setAttribute('opacity', '0.6');
		routePath.appendChild(glowPath);
		
		// 2. Main path (เส้นหลัก)
		const mainPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		mainPath.setAttribute('d', pathString);
		mainPath.setAttribute('class', 'route-line route-line-animated');
		mainPath.setAttribute('stroke', '#dc3545');
		mainPath.setAttribute('stroke-width', '0.6');
		mainPath.setAttribute('fill', 'none');
		mainPath.setAttribute('stroke-dasharray', '4 2');
		mainPath.setAttribute('stroke-linecap', 'round');
		routePath.appendChild(mainPath);
		
		// 3. สร้าง waypoints
		if (WAYPOINT_SYSTEM.showWaypoints) {
			const waypoints = generateWaypoints(pathNodeIds);
			drawWaypoints(routePath, waypoints);
		}
		
		// 4. ใช้ฟังก์ชันเดิม addRouteMarkers (แก้ไขแล้ว)
		addRouteMarkers(pathPoints[0], pathPoints[pathPoints.length - 1]);
		
		routePath.style.display = 'block';
	}
 
 
	// วาด waypoints บนแผนที่
	function drawWaypoints(routePath, waypoints) {
		if (!waypoints || waypoints.length === 0) return;
		
		debugLog('🎯 Drawing waypoints...', { count: waypoints.length });
		
		waypoints.forEach((waypoint, index) => {
			// สร้าง waypoint marker
			const waypointGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			waypointGroup.setAttribute('class', 'waypoint-group');
			waypointGroup.setAttribute('data-waypoint-id', waypoint.id);
			
			// Pulse ring (animation)
			if (WAYPOINT_SYSTEM.animationEnabled) {
				const pulseRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				pulseRing.setAttribute('cx', waypoint.x);
				pulseRing.setAttribute('cy', waypoint.y);
				pulseRing.setAttribute('r', WAYPOINT_SYSTEM.waypointSize * 1.5);
				pulseRing.setAttribute('fill', 'none');
				pulseRing.setAttribute('stroke', WAYPOINT_STYLES.pulseColor);
				pulseRing.setAttribute('stroke-width', '0.2');
				pulseRing.setAttribute('opacity', '0');
				pulseRing.setAttribute('class', 'waypoint-pulse');
				
				// CSS animation จะถูกเพิ่มผ่าน CSS
				waypointGroup.appendChild(pulseRing);
			}
			
			// Main waypoint circle
			const waypointCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			waypointCircle.setAttribute('cx', waypoint.x);
			waypointCircle.setAttribute('cy', waypoint.y);
			waypointCircle.setAttribute('r', WAYPOINT_SYSTEM.waypointSize);
			waypointCircle.setAttribute('fill', WAYPOINT_STYLES.fill);
			waypointCircle.setAttribute('stroke', WAYPOINT_STYLES.stroke);
			waypointCircle.setAttribute('stroke-width', WAYPOINT_STYLES.strokeWidth);
			waypointCircle.setAttribute('opacity', WAYPOINT_STYLES.opacity);
			waypointCircle.setAttribute('class', 'waypoint-marker');
			waypointGroup.appendChild(waypointCircle);
			
			// Label (หมายเลข) ถ้าเปิดใช้งาน
			if (WAYPOINT_SYSTEM.showLabels) {
				const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
				label.setAttribute('x', waypoint.x);
				label.setAttribute('y', waypoint.y + 0.2); // เลื่อนลงเล็กน้อย
				label.setAttribute('text-anchor', 'middle');
				label.setAttribute('font-size', WAYPOINT_STYLES.labelSize);
				label.setAttribute('font-weight', 'bold');
				label.setAttribute('fill', WAYPOINT_STYLES.labelColor);
				label.setAttribute('class', 'waypoint-label');
				label.textContent = waypoint.index;
				waypointGroup.appendChild(label);
			}
			
			routePath.appendChild(waypointGroup);
		});
		
		// เพิ่ม CSS animation สำหรับ waypoints
		ensureWaypointCSS();
	}

	// เพิ่ม CSS สำหรับ waypoint animations
	function ensureWaypointCSS() {
		if (document.getElementById('waypointAnimationCSS')) return;
		
		const css = document.createElement('style');
		css.id = 'waypointAnimationCSS';
		css.textContent = `
			/* Waypoint Animation Styles */
			.waypoint-pulse {
				animation: waypoint-pulse 2s ease-in-out infinite;
			}
			
			@keyframes waypoint-pulse {
				0% {
					r: ${WAYPOINT_SYSTEM.waypointSize * 0.5};
					opacity: 0.8;
				}
				50% {
					r: ${WAYPOINT_SYSTEM.waypointSize * 2};
					opacity: 0.3;
				}
				100% {
					r: ${WAYPOINT_SYSTEM.waypointSize * 3};
					opacity: 0;
				}
			}
			
			.waypoint-marker {
				transition: all 0.3s ease;
				cursor: pointer;
			}
			
			.waypoint-marker:hover {
				r: ${WAYPOINT_SYSTEM.waypointSize * 1.3};
				opacity: 1;
			}
			
			.waypoint-group:hover .waypoint-pulse {
				animation-duration: 1s;
			}
			
			.waypoint-label {
				pointer-events: none;
				transition: opacity 0.3s ease;
			}
			
			/* Waypoint visibility toggle */
			.waypoints-hidden .waypoint-group {
				opacity: 0;
				transition: opacity 0.5s ease;
			}
			
			.waypoints-visible .waypoint-group {
				opacity: 1;
				transition: opacity 0.5s ease;
			}
		`;
		document.head.appendChild(css);
	}

 
	// ========== 6. Waypoint Control Toggle ==========

	// สร้าง waypoint toggle control
	function createWaypointToggle() {
		const routeControls = document.querySelector('.route-controls');
		if (!routeControls) return;
		
		// ตรวจสอบว่ามี toggle แล้วหรือไม่
		if (document.getElementById('waypointToggle')) return;
		
		const toggleContainer = document.createElement('div');
		toggleContainer.className = 'waypoint-toggle-container';
		toggleContainer.style.cssText = `
			display: flex;
			align-items: center;
			gap: 8px;
			margin-left: 10px;
			font-size: 12px;
			color: var(--text-secondary);
		`;
		
		toggleContainer.innerHTML = `
			<label class="waypoint-toggle">
				<input type="checkbox" id="waypointToggle" ${WAYPOINT_SYSTEM.showWaypoints ? 'checked' : ''}>
				<span class="toggle-slider"></span>
			</label>
			<span>${currentLanguage === 'th' ? 'จุดนำทาง' : 'Waypoints'}</span>
			<button id="waypointSettings" class="waypoint-settings-btn" title="Waypoint Settings">
				<i class="fas fa-cog"></i>
			</button>
		`;
		
		// เพิ่ม CSS สำหรับ toggle (ใช้ CSS เดิมแต่เปลี่ยนชื่อ class)
		if (!document.getElementById('waypointToggleCSS')) {
			const css = document.createElement('style');
			css.id = 'waypointToggleCSS';
			css.textContent = `
				.waypoint-toggle {
					position: relative;
					display: inline-block;
					width: 40px;
					height: 20px;
				}
				
				.waypoint-toggle input {
					opacity: 0;
					width: 0;
					height: 0;
				}
				
				.waypoint-settings-btn {
					background: none;
					border: none;
					color: var(--text-secondary);
					cursor: pointer;
					padding: 4px;
					border-radius: 4px;
					font-size: 12px;
					transition: all 0.2s ease;
				}
				
				.waypoint-settings-btn:hover {
					background: var(--primary-color);
					color: white;
				}
			`;
			document.head.appendChild(css);
		}
		
		// เพิ่ม event listeners
		const toggle = toggleContainer.querySelector('#waypointToggle');
		toggle.addEventListener('change', function() {
			WAYPOINT_SYSTEM.showWaypoints = this.checked;
			localStorage.setItem('waypointSystemEnabled', this.checked);
			
			// อัปเดตเส้นทางปัจจุบัน
			if (routeDisplayed && currentRoute) {
				updateCurrentRouteWaypoints();
			}
			
			const message = currentLanguage === 'th' 
				? (this.checked ? '✅ เปิดการแสดงจุดนำทาง' : '❌ ปิดการแสดงจุดนำทาง')
				: (this.checked ? '✅ Waypoints enabled' : '❌ Waypoints disabled');
			showNotification(message, 'info');
		});
		
		// เพิ่ม settings button
		const settingsBtn = toggleContainer.querySelector('#waypointSettings');
		settingsBtn.addEventListener('click', showWaypointSettings);
		
		routeControls.appendChild(toggleContainer);
	}

	// อัปเดต waypoints ของเส้นทางปัจจุบัน
	function updateCurrentRouteWaypoints() {
		if (!walkableRoutingData.lastPath) return;
		
		debugLog('🔄 Updating current route waypoints...', {
			showWaypoints: WAYPOINT_SYSTEM.showWaypoints,
			pathLength: walkableRoutingData.lastPath.length
		});
		
		// วาดเส้นทางใหม่พร้อม waypoints
		drawWalkablePathWithWaypoints(walkableRoutingData.lastPath);
	}

	// แสดงหน้าต่างการตั้งค่า waypoints
	function showWaypointSettings() {
		const modal = document.createElement('div');
		modal.className = 'waypoint-settings-modal';
		modal.style.cssText = `
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0,0,0,0.5);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
		`;
		
		modal.innerHTML = `
			<div class="settings-content" style="
				background: white;
				padding: 20px;
				border-radius: 12px;
				width: 300px;
				max-width: 90vw;
			">
				<h3>การตั้งค่าจุดนำทาง</h3>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>ระยะห่างระหว่างจุด (เมตร)</label>
					<input type="number" id="waypointInterval" value="${WAYPOINT_SYSTEM.waypointInterval}" min="5" max="50">
				</div>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>จำนวนจุดสูงสุด</label>
					<input type="number" id="maxWaypoints" value="${WAYPOINT_SYSTEM.maxWaypoints}" min="2" max="15">
				</div>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>
						<input type="checkbox" id="showLabels" ${WAYPOINT_SYSTEM.showLabels ? 'checked' : ''}>
						แสดงหมายเลขจุดนำทาง
					</label>
				</div>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>
						<input type="checkbox" id="animationEnabled" ${WAYPOINT_SYSTEM.animationEnabled ? 'checked' : ''}>
						เปิดใช้งาน Animation
					</label>
				</div>
				
				<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
					<button id="cancelSettings" style="padding: 8px 15px; border: 1px solid #ccc; background: white; border-radius: 6px;">ยกเลิก</button>
					<button id="saveSettings" style="padding: 8px 15px; background: var(--primary-color); color: white; border: none; border-radius: 6px;">บันทึก</button>
				</div>
			</div>
		`;
		
		document.body.appendChild(modal);
		
		// Event listeners
		modal.querySelector('#cancelSettings').addEventListener('click', () => {
			document.body.removeChild(modal);
		});
		
		modal.querySelector('#saveSettings').addEventListener('click', () => {
			// บันทึกการตั้งค่า
			WAYPOINT_SYSTEM.waypointInterval = parseInt(modal.querySelector('#waypointInterval').value);
			WAYPOINT_SYSTEM.maxWaypoints = parseInt(modal.querySelector('#maxWaypoints').value);
			WAYPOINT_SYSTEM.showLabels = modal.querySelector('#showLabels').checked;
			WAYPOINT_SYSTEM.animationEnabled = modal.querySelector('#animationEnabled').checked;
			
			// บันทึกลง localStorage
			localStorage.setItem('waypointSystemConfig', JSON.stringify(WAYPOINT_SYSTEM));
			
			// อัปเดตเส้นทางปัจจุบัน
			if (routeDisplayed && currentRoute) {
				updateCurrentRouteWaypoints();
			}
			
			showNotification('✅ บันทึกการตั้งค่าจุดนำทางแล้ว', 'success');
			document.body.removeChild(modal);
		});
		
		// ปิดเมื่อคลิกพื้นหลัง
		modal.addEventListener('click', (e) => {
			if (e.target === modal) {
				document.body.removeChild(modal);
			}
		});
	}

	// ========== 7. Enhanced Auto Update with Persistence ==========

	function enhancedAutoUpdateRoute() {
		if (routingLock.isProcessing) {
			debugLog('⏳ Route update already in progress, skipping enhanced auto update...');
			return;
		}
		
		if (autoRouteUpdate.isUpdating) {
			debugLog('⏳ Enhanced auto update already in progress...');
			return;
		}
		
		autoRouteUpdate.isUpdating = true;
		
		try {
			// ตรวจสอบและรักษาจุดปลายทาง
			const hasDestination = ensurePersistentDestination();
			
			if (!startPoint || !hasDestination) {
				debugLog('⚠️ Missing required data for enhanced route update', {
					hasStartPoint: !!startPoint,
					hasDestination,
					selectedRoom
				});
				autoRouteUpdate.isUpdating = false;
				return;
			}
			
			// เคลียร์เส้นทางเดิม
			safeClearRouteVisuals();
			
			// สร้างเส้นทางใหม่
			const destination = roomData[selectedRoom];
			currentRoute = { start: startPoint, destination: destination };
			
			debugLog('🔄 Enhanced auto-updating route with waypoints...', { 
				start: startPoint, 
				destination: destination.name,
				waypointsEnabled: WAYPOINT_SYSTEM.showWaypoints
			});
			
			showRouteToSelected();
			// อัปเดต state
			routeDisplayed = true;
			updateRouteControls(true);
			updateRoomMarkers();
			
			ensureRouteConsistency();
			
			
			debugLog('✅ Enhanced auto route update completed with persistent destination');
			
		} catch (error) {
			debugLog('❌ Error in enhanced auto route update', error);
			showNotification('❌ เกิดข้อผิดพลาดในการอัปเดตเส้นทาง', 'error');
		} finally {
			autoRouteUpdate.isUpdating = false;
		}
	}

	 

	// ========== 9. Initialize Enhanced System ==========

	// โหลดการตั้งค่า waypoint system
	function loadWaypointSettings() {
		const saved = localStorage.getItem('waypointSystemConfig');
		if (saved) {
			try {
				const config = JSON.parse(saved);
				Object.assign(WAYPOINT_SYSTEM, config);
				debugLog('📁 Loaded waypoint settings from localStorage');
			} catch (error) {
				debugLog('⚠️ Error loading waypoint settings:', error);
			}
		}
		
		// โหลดการตั้งค่า enabled/disabled
		const enabled = localStorage.getItem('waypointSystemEnabled');
		if (enabled !== null) {
			WAYPOINT_SYSTEM.showWaypoints = enabled === 'true';
		}
	}

	// เริ่มต้นระบบ waypoint
	function initializeWaypointSystem() {
		debugLog('🎯 Initializing waypoint navigation system...');
		
		// โหลดการตั้งค่า
		loadWaypointSettings();
		
		// สร้าง toggle control
		setTimeout(() => {
			createWaypointToggle();
		}, 1000);
		
		debugLog('✅ Waypoint system initialized:', {
			enabled: WAYPOINT_SYSTEM.enabled,
			showWaypoints: WAYPOINT_SYSTEM.showWaypoints,
			interval: WAYPOINT_SYSTEM.waypointInterval,
			maxWaypoints: WAYPOINT_SYSTEM.maxWaypoints
		});
	}

	// ========== 10. Integration and Exports ==========

	// แทนที่ฟังก์ชันหลัก
	function replaceWithEnhancedFunctions() {
		debugLog('🔄 Replacing with enhanced waypoint functions...');
		
		// Backup original functions
		if (typeof window.originalUpdateStartPointWithAutoRoute === 'undefined') {
			window.originalUpdateStartPointWithAutoRoute = window.updateStartPointWithAutoRoute;
			window.originalDrawWalkablePath = window.drawWalkablePath;
			window.originalAutoUpdateRoute = window.autoUpdateRoute;
		}
		
		// Replace with enhanced versions
		window.updateStartPointWithAutoRoute = enhancedUpdateStartPointWithAutoRoute;
		window.drawWalkablePath = drawWalkablePathWithWaypoints;
		window.autoUpdateRoute = enhancedAutoUpdateRoute;
		
		debugLog('✅ Enhanced waypoint functions activated');
	}

	// Auto-Initialize
	document.addEventListener('DOMContentLoaded', function() {
		setTimeout(() => {
			debugLog('🚀 Starting waypoint navigation enhancement...');
			
			try {
				loadWaypointSettings();
				replaceWithEnhancedFunctions();
				//initializeWaypointSystem();
				
				debugLog('✅ Waypoint navigation enhancement initialized');
				
			} catch (error) {
				debugLog('❌ Error initializing waypoint system', error);
			}
			
		}, 5000); // รอหลัง routing system โหลดเสร็จ
	});

	// Export enhanced system
	window.waypointNavigationSystem = {
		config: WAYPOINT_SYSTEM,
		generateWaypoints,
		updateWaypoints: updateCurrentRouteWaypoints,
		showSettings: showWaypointSettings,
		toggleWaypoints: (enabled) => {
			WAYPOINT_SYSTEM.showWaypoints = enabled;
			document.getElementById('waypointToggle').checked = enabled;
			updateCurrentRouteWaypoints();
		}
	};
	
	// 🔧 Debug & Fix Critical Routing Issues
        // แทนที่โค้ดเดิมใน index.html

        // ========== 1. Enhanced Debugging & Safety Guards ==========

        // ป้องกัน infinite loop
        let routingLock = {
            isProcessing: false,
            lastUpdate: 0,
            minInterval: 500, // ms
            maxRetries: 3,
            currentRetries: 0
        };

        // Enhanced logging
        function debugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] 🔍 ${message}`, data || '');
        }

        // ========== 2. Walkable Data Structure (Global Variables) ==========
        let walkableRoutingData = {
            nodes: {},           // ข้อมูลจุดเดิน { id: {x, y, building} }
            edges: [],          // ข้อมูลเส้นเชื่อม [{from, to, weight, bidirectional}]
            settings: {
                metersPerPercent: 1.2,
                maxSearchRadius: 25,
                defaultWalkSpeed: 1.5  // m/s
            },
            currentBuilding: null,
            lastPath: null,
            isInitialized: false
        };

        // Auto-update configuration
        let autoRouteUpdate = {
            enabled: true,
            lastStartPoint: null,
            hasActiveDestination: false,
            isUpdating: false,
            updateDelay: 300 // milliseconds
        };

        // ========== 3. Core Functions ==========
        
        // คำนวณระยะทางระหว่างจุด (เปอร์เซ็นต์)
        function distanceBetweenPoints(pointA, pointB) {
            return Math.sqrt(
                Math.pow(pointA.x - pointB.x, 2) + 
                Math.pow(pointA.y - pointB.y, 2)
            );
        }

        // สร้าง adjacency list สำหรับ graph
        function buildAdjacencyList(metersPerPercent = 1.2) {
            const adj = {};
            
            for (const edge of walkableRoutingData.edges) {
                const weight = edge.weight || (distanceBetweenPoints(
                    walkableRoutingData.nodes[edge.from], 
                    walkableRoutingData.nodes[edge.to]
                ) * metersPerPercent);
                
                // เพิ่ม edge ไปทิศทางหนึ่ง
                (adj[edge.from] ||= []).push({to: edge.to, weight: weight});
                
                // เพิ่ม edge ย้อนกลับถ้าเป็น bidirectional
                if (edge.bidirectional !== false) {
                    (adj[edge.to] ||= []).push({to: edge.from, weight: weight});
                }
            }
            
            return adj;
        }

        // Dijkstra's shortest path algorithm
        function dijkstraPathfinder(startId, endId, metersPerPercent = 1.2) {
            const adj = buildAdjacencyList(metersPerPercent);
            const distances = {};
            const previous = {};
            const priorityQueue = [[0, startId]];
            const visited = new Set();
            
            distances[startId] = 0;
            
            while (priorityQueue.length > 0) {
                // Sort ตาม distance (simple implementation)
                priorityQueue.sort((a, b) => a[0] - b[0]);
                const [currentDistance, currentNode] = priorityQueue.shift();
                
                if (visited.has(currentNode)) continue;
                visited.add(currentNode);
                
                // หาถึงปลายทางแล้ว
                if (currentNode === endId) break;
                
                // ตรวจสอบ neighbors
                for (const neighbor of (adj[currentNode] || [])) {
                    const newDistance = currentDistance + neighbor.weight;
                    
                    if (newDistance < (distances[neighbor.to] ?? Infinity)) {
                        distances[neighbor.to] = newDistance;
                        previous[neighbor.to] = currentNode;
                        priorityQueue.push([newDistance, neighbor.to]);
                    }
                }
            }
            
            // สร้าง path
            const path = [];
            let currentNode = endId;
            
            // ถ้าไม่มี path
            if (!previous[currentNode] && currentNode !== startId) {
                return { path: [], distance: Infinity, error: 'No path found' };
            }
            
            // สร้าง path โดยย้อนกลับ
            while (currentNode) {
                path.unshift(currentNode);
                if (currentNode === startId) break;
                currentNode = previous[currentNode];
            }
            
            return { 
                path, 
                distance: distances[endId] ?? 0,
                nodeCount: path.length
            };
        }

        // ========== 4. Enhanced Sample Data Creation ==========
        function createRobustSampleWalkableData() {
            debugLog('🏗️ Creating robust sample walkable data...');
            
            let nodeId = 1;
            walkableRoutingData.nodes = {};
            walkableRoutingData.edges = [];
            
            // สร้าง grid ที่หนาแน่นขึ้น 6x6 instead of 4x4
            const gridPoints = [];
            for (let x = 10; x <= 90; x += 16) { // ทุกๆ 16% แทน 20%
                for (let y = 10; y <= 90; y += 16) {
                    const point = {
                        id: nodeId.toString(),
                        x: x,
                        y: y,
                        building: walkableRoutingData.currentBuilding
                    };
                    walkableRoutingData.nodes[nodeId] = point;
                    gridPoints.push(point);
                    nodeId++;
                }
            }
            
            // เพิ่มจุดกลางแผนที่
            const centerPoints = [
                {x: 50, y: 50}, // จุดศูนย์กลาง
                {x: 30, y: 50}, // จุดกลางซ้าย
                {x: 70, y: 50}, // จุดกลางขวา
                {x: 50, y: 30}, // จุดกลางบน
                {x: 50, y: 70}  // จุดกลางล่าง
            ];
            
            centerPoints.forEach(point => {
                walkableRoutingData.nodes[nodeId] = {
                    id: nodeId.toString(),
                    x: point.x,
                    y: point.y,
                    building: walkableRoutingData.currentBuilding
                };
                nodeId++;
            });
            
            // เชื่อมต่อจุดที่อยู่ใกล้กัน - เพิ่ม radius
            const maxConnectionDistance = 25; // เพิ่มจาก 20 เป็น 25
            const nodes = Object.values(walkableRoutingData.nodes);
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const distance = distanceBetweenPoints(nodes[i], nodes[j]);
                    if (distance <= maxConnectionDistance) {
                        walkableRoutingData.edges.push({
                            from: nodes[i].id,
                            to: nodes[j].id,
                            weight: distance * walkableRoutingData.settings.metersPerPercent,
                            bidirectional: true
                        });
                    }
                }
            }
            
            debugLog('✅ Sample walkable data created:', {
                nodes: Object.keys(walkableRoutingData.nodes).length,
                edges: walkableRoutingData.edges.length,
                maxDistance: maxConnectionDistance
            });
            
            // บันทึกลง localStorage
            try {
                const building = getCurrentBuilding();
                const storageKey = `walkableData_${building}`;
                const dataToSave = {
                    nodes: walkableRoutingData.nodes,
                    edges: walkableRoutingData.edges,
                    settings: walkableRoutingData.settings,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(storageKey, JSON.stringify(dataToSave));
                debugLog('💾 Sample data saved to localStorage');
            } catch (error) {
                console.warn('⚠️ Could not save to localStorage:', error);
            }
        }

        // ========== 5. Helper Functions ==========
        
        // หาจุดเดินที่ใกล้ที่สุดกับตำแหน่งที่กำหนด
        function findNearestWalkableNode(targetX, targetY, maxRadius = 25) {
            let nearestNode = null;
            let nearestDistance = Infinity;
            
            for (const nodeId in walkableRoutingData.nodes) {
                const node = walkableRoutingData.nodes[nodeId];
                const distance = distanceBetweenPoints({x: targetX, y: targetY}, node);
                
                if (distance < nearestDistance && distance <= maxRadius) {
                    nearestDistance = distance;
                    nearestNode = { id: nodeId, distance, ...node };
                }
            }
            
            return nearestNode;
        }

        // สร้าง temporary node สำหรับจุดเริ่มต้นและปลายทาง
        function createTemporaryNode(x, y, nodeId) {
            return {
                id: nodeId,
                x: x,
                y: y,
                isTemporary: true,
                building: walkableRoutingData.currentBuilding
            };
        }

        // Enhanced connection logic
        function enhancedConnectTemporaryNode(tempNodeId, maxRadius = 30) { // เพิ่มจาก 15 เป็น 30
            const tempNode = walkableRoutingData.nodes[tempNodeId];
            if (!tempNode) {
                debugLog('❌ Temporary node not found:', tempNodeId);
                return [];
            }
            
            const connectedNodes = [];
            let nearestNodes = [];
            
            // หาทุกจุดที่อยู่ในรัศมี พร้อมระยะทาง
            for (const nodeId in walkableRoutingData.nodes) {
                if (nodeId === tempNodeId) continue;
                
                const node = walkableRoutingData.nodes[nodeId];
                const distance = distanceBetweenPoints(tempNode, node);
                
                if (distance <= maxRadius) {
                    nearestNodes.push({ nodeId, node, distance });
                }
            }
            
            // เรียงตามระยะทางใกล้ไกล
            nearestNodes.sort((a, b) => a.distance - b.distance);
            
            // เชื่อมต่อกับจุดที่ใกล้ที่สุด 3-5 จุด
            const maxConnections = Math.min(5, nearestNodes.length);
            
            for (let i = 0; i < maxConnections; i++) {
                const { nodeId, node, distance } = nearestNodes[i];
                const weight = distance * walkableRoutingData.settings.metersPerPercent;
                
                walkableRoutingData.edges.push({
                    from: tempNodeId,
                    to: nodeId,
                    weight: weight,
                    bidirectional: true,
                    isTemporary: true
                });
                
                connectedNodes.push(nodeId);
            }
            
            debugLog(`🔗 Connected temporary node ${tempNodeId} to ${connectedNodes.length}/${nearestNodes.length} nearby nodes`, {
                connections: connectedNodes,
                maxRadius,
                nearestDistance: nearestNodes[0]?.distance
            });
            
            return connectedNodes;
        }

        // ลบ temporary nodes และ edges
        function cleanupTemporaryNodes() {
            // ลบ temporary nodes
            for (const nodeId in walkableRoutingData.nodes) {
                if (walkableRoutingData.nodes[nodeId].isTemporary) {
                    delete walkableRoutingData.nodes[nodeId];
                }
            }
            
            // ลบ temporary edges
            walkableRoutingData.edges = walkableRoutingData.edges.filter(edge => !edge.isTemporary);
        }

        // ========== 6. Safe Route Creation ==========
        
        function safeShowWalkableRoutePath(start, destination) {
            const now = Date.now();
            
            // ป้องกัน rapid successive calls
            if (routingLock.isProcessing) {
                debugLog('⏳ Routing already in progress, skipping...');
                return;
            }
            
            if (now - routingLock.lastUpdate < routingLock.minInterval) {
                debugLog('⏱️ Too soon for another route update, skipping...');
                return;
            }
            
            routingLock.isProcessing = true;
            routingLock.lastUpdate = now;
            
            try {
                debugLog('🛣️ Safe walkable route creation started', {start, destination});
                
                // เคลียร์เส้นทางเดิมก่อน
                safeClearRouteVisuals();
                
                // ตรวจสอบและเตรียม walkable data
                if (!walkableRoutingData.isInitialized) {
                    debugLog('📚 Initializing walkable data...');
                    initializeWalkableRouting();
                }
                
                const nodesCount = Object.keys(walkableRoutingData.nodes).length;
                const edgesCount = walkableRoutingData.edges.length;
                
                debugLog('📊 Walkable data status:', { nodesCount, edgesCount });
                
                if (nodesCount === 0) {
                    debugLog('⚠️ No walkable nodes, creating sample data...');
                    createRobustSampleWalkableData();
                }
                
                if (Object.keys(walkableRoutingData.nodes).length < 5) {
                    debugLog('❌ Insufficient walkable data, falling back to straight line');
                    routingLock.isProcessing = false;
                    return showStraightRoutePath(start, destination);
                }
                
                // ลบ temporary nodes เก่า
                cleanupTemporaryNodes();
                
                // สร้าง temporary nodes ใหม่
                const startNodeId = 'temp_start';
                const endNodeId = 'temp_end';
                
                walkableRoutingData.nodes[startNodeId] = createTemporaryNode(start.x, start.y, startNodeId);
                walkableRoutingData.nodes[endNodeId] = createTemporaryNode(destination.x, destination.y, endNodeId);
                
                // เชื่อมต่อ temporary nodes
                const startConnections = enhancedConnectTemporaryNode(startNodeId, 35);
                const endConnections = enhancedConnectTemporaryNode(endNodeId, 35);
                
                if (startConnections.length === 0 || endConnections.length === 0) {
                    debugLog('❌ Cannot connect to walkable network, using straight line', {
                        startConnections: startConnections.length,
                        endConnections: endConnections.length,
                        totalNodes: Object.keys(walkableRoutingData.nodes).length
                    });
                    
                    cleanupTemporaryNodes();
                    routingLock.isProcessing = false;
                    return showStraightRoutePath(start, destination);
                }
                
                // คำนวณเส้นทาง
                debugLog('🧮 Calculating Dijkstra path...');
                const result = dijkstraPathfinder(startNodeId, endNodeId, walkableRoutingData.settings.metersPerPercent);
                
                if (result.path.length === 0) {
                    debugLog('❌ No walkable path found, using straight line');
                    cleanupTemporaryNodes();
                    routingLock.isProcessing = false;
                    return showStraightRoutePath(start, destination);
                }
                
                // วาดเส้นทาง
                drawWalkablePath(result.path);
                displayRouteInfo(result);
                
                // อัพเดต state
                routeDisplayed = true;
                walkableRoutingData.lastPath = result.path;
                updateRouteControls(true);
                
                // แสดง notification
                const message = currentLanguage === 'th' 
                    ? `🛣️ เส้นทางเดิน: ${result.distance.toFixed(1)}m, ${result.nodeCount} จุด`
                    : `🛣️ Walking route: ${result.distance.toFixed(1)}m, ${result.nodeCount} points`;
                showNotification(message, 'success');
                
                debugLog('✅ Walkable route created successfully', result);
                
            } catch (error) {
                debugLog('❌ Error in walkable route creation', error);
                cleanupTemporaryNodes();
                showNotification('❌ เกิดข้อผิดพลาดในการสร้างเส้นทาง', 'error');
                
                // Fallback แต่ป้องกัน loop
                if (routingLock.currentRetries < routingLock.maxRetries) {
                    routingLock.currentRetries++;
                    setTimeout(() => {
                        showStraightRoutePath(start, destination);
                    }, 100);
                }
            } finally {
                routingLock.isProcessing = false;
                routingLock.currentRetries = 0;
            }
        }

        // ========== 7. Visual Functions ==========
        
        // แทนที่ฟังก์ชัน drawWalkablePath เดิม
		function drawWalkablePath(pathNodeIds) {
			const routePath = document.getElementById('routePath') || createRoutePathElement();
			if (!routePath) return;
			
			routePath.innerHTML = '';
			
			// สร้างจุดต่างๆ บนเส้นทาง
			const pathPoints = pathNodeIds.map(nodeId => walkableRoutingData.nodes[nodeId]);
			
			if (pathPoints.length < 2) return;
			
			debugLog('🎨 Drawing walkable path:', {
				points: pathPoints.length,
				startHidden: true,
				endVisible: true
			});
			
			// สร้าง SVG path
			const pathString = pathPoints.map((point, index) => {
				const command = index === 0 ? 'M' : 'L';
				return `${command} ${point.x} ${point.y}`;
			}).join(' ');
			
			// Glow effect (เส้นเรืองแสง)
			const glowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			glowPath.setAttribute('d', pathString);
			glowPath.setAttribute('class', 'route-line-glow');
			glowPath.setAttribute('stroke', '#fbbf24');
			glowPath.setAttribute('stroke-width', '1.0');
			glowPath.setAttribute('fill', 'none');
			glowPath.setAttribute('opacity', '0.7');
			routePath.appendChild(glowPath);
			
			// Main path (เส้นหลัก)
			const mainPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			mainPath.setAttribute('d', pathString);
			mainPath.setAttribute('class', 'route-line route-line-animated');
			mainPath.setAttribute('stroke', '#dc3545');
			mainPath.setAttribute('stroke-width', '0.5');
			mainPath.setAttribute('fill', 'none');
			mainPath.setAttribute('stroke-dasharray', '3 1');
			mainPath.setAttribute('stroke-linecap', 'round');
			routePath.appendChild(mainPath);
			
			// เพิ่มเฉพาะ destination marker (ไม่มี start marker)
			addRouteMarkers(pathPoints[0], pathPoints[pathPoints.length - 1]);
			
			routePath.style.display = 'block';
		}

        // เพิ่ม route markers แก้ไขฟังก์ชันเดิม - แสดงเฉพาะ destination marker
		function addRouteMarkers(startPoint, endPoint) {
			const routePath = document.getElementById('routePath');
			if (!routePath) return;
			
			// ลบ markers เดิมก่อน (ป้องกันซ้ำ)
			routePath.querySelectorAll('.route-marker, .destination-marker, .destination-label').forEach(el => el.remove());
			
			// แสดงเฉพาะ End marker (จุดปลายทาง) - ไม่มี start marker
			const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			endMarker.setAttribute('cx', endPoint.x);
			endMarker.setAttribute('cy', endPoint.y);
			endMarker.setAttribute('r', '1.5');
			endMarker.setAttribute('fill', '#dc3545');
			endMarker.setAttribute('stroke', '#fff');
			endMarker.setAttribute('stroke-width', '0.4');
			endMarker.setAttribute('class', 'route-marker destination-marker');
			endMarker.setAttribute('data-marker-type', 'destination');
			routePath.appendChild(endMarker);
			
			// เพิ่ม destination label
			const destLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
			destLabel.setAttribute('x', endPoint.x);
			destLabel.setAttribute('y', endPoint.y - 2.5);
			destLabel.setAttribute('text-anchor', 'middle');
			destLabel.setAttribute('font-size', '8px');
			destLabel.setAttribute('font-weight', 'bold');
			destLabel.setAttribute('fill', '#dc3545');
			destLabel.setAttribute('class', 'destination-label');
			destLabel.setAttribute('data-marker-type', 'destination');
			destLabel.textContent = '🎯';
			routePath.appendChild(destLabel);
			
			debugLog('🎯 Only destination marker shown (no duplicates)');
		}
        // แสดงข้อมูลเส้นทาง
        function displayRouteInfo(routeResult) {
			const { distance, nodeCount, path } = routeResult;
			
			// คำนวณข้อมูลเพิ่มเติม
			const walkingTime = Math.ceil(distance / walkableRoutingData.settings.defaultWalkSpeed);
			const gridNodesUsed = path.filter(nodeId => {
				const node = walkableRoutingData.nodes[nodeId];
				return node && node.type === 'grid';
			}).length;
			const strategicNodesUsed = nodeCount - gridNodesUsed;
			
			// อัพเดต route steps ถ้ามี element
			const routeSteps = document.getElementById('routeSteps');
			if (routeSteps) {
				const stepsHTML = `
					<div class="route-summary">
						<div class="summary-item">
							<i class="fas fa-route"></i>
							<span>ระยะทาง: ${distance.toFixed(1)} เมตร</span>
						</div>
						<div class="summary-item">
							<i class="fas fa-clock"></i>
							<span>เวลาเดิน: ~${walkingTime} วินาที</span>
						</div>
						<div class="summary-item">
							<i class="fas fa-map-marker-alt"></i>
							<span>จุดผ่าน: ${nodeCount} จุด</span>
						</div>
						<div class="summary-item">
							<i class="fas fa-network-wired"></i>
							<span>Grid: ${gridNodesUsed} | Strategic: ${strategicNodesUsed}</span>
						</div>
					</div>
				`;
				
				routeSteps.innerHTML = stepsHTML;
			}
			
			debugLog('📊 Route info displayed:', { 
				distance: distance.toFixed(1), 
				nodeCount, 
				walkingTime,
				gridNodesUsed,
				strategicNodesUsed
			});
		}

        // เคลียร์เฉพาะ visual elements ไม่ลบ state
        function safeClearRouteVisuals() {
            debugLog('🗑️ Safely clearing route visuals...');
            
            try {
                // ลบ visual elements
                const routeSelectors = [
                    '.route-line', 
                    '.route-marker', 
                    '.route-path',
                    '.route-step-marker',
                    '.navigation-marker',
                    '[data-route="true"]',
                    '.route-animated',
                    '.route-line-animated',
                    '.route-marker-enhanced',
                    'path[stroke="#dc3545"]',
                    'circle[fill="#28a745"]',
                    'circle[fill="#dc3545"]'
                ];
                
                let removedCount = 0;
                routeSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        el.remove();
                        removedCount++;
                    });
                });
                
                // เคลียร์ routePath
                const routePath = document.getElementById('routePath');
                if (routePath) {
                    routePath.innerHTML = '';
                }
                
                debugLog(`✅ Cleared ${removedCount} route visual elements`);
                
            } catch (error) {
                debugLog('❌ Error clearing route visuals', error);
            }
        }

        // ========== 8. Auto-Update Functions ==========
        
        // แทนที่ event listeners เดิม
        function enhancedMapClickHandler(event) {
            // ตรวจสอบว่าไม่ใช่การคลิกที่ room marker หรือ controls
            if (event.target.closest('.room-marker') || 
                event.target.closest('.route-controls') ||
                event.target.closest('.search-container') ||
                event.target.closest('.room-action-overlay')) {
                return;
            }

            const mapArea = event.currentTarget;
            const rect = mapArea.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            // ตรวจสอบว่าตำแหน่งอยู่ในขอบเขต
            if (x >= 0 && x <= 100 && y >= 0 && y <= 100) {
                updateStartPointWithAutoRoute(x, y);
			
            }
        }

        function updateStartPointWithAutoRoute(x, y) {
			debugLog('📍 Updating hidden start point with auto-route...', { x: x.toFixed(2), y: y.toFixed(2) });
			
			// ตรวจสอบว่ามีปลายทางอยู่แล้วหรือไม่
			const hasDestination = selectedRoom && roomData[selectedRoom];
			autoRouteUpdate.hasActiveDestination = hasDestination;
			
			// อัปเดตจุดเริ่มต้น (ซ่อนจากผู้ใช้)
			const oldStartPoint = startPoint ? { ...startPoint } : null;
			startPoint = {
				name: currentLanguage === 'th' ? 'จุดเริ่มต้น' : 'Starting Point',
				x: x,
				y: y,
				hidden: true  // flag ระบุว่าซ่อนจากผู้ใช้
			};
			
			// บันทึกลง localStorage
			localStorage.setItem('startPoint', JSON.stringify(startPoint));
			autoRouteUpdate.lastStartPoint = { ...startPoint };
			
			// อัปเดต UI markers (ไม่แสดงจุดเริ่มต้น)
			updateStartPointMarker(x, y);
			
			// ถ้ามีปลายทางอยู่แล้ว ให้อัปเดตเส้นทางอัตโนมัติ
			if (hasDestination && autoRouteUpdate.enabled) {
				debugLog('🔄 Auto-updating route to existing destination (start point hidden)...');
				
				// อัปเดตเส้นทางหลังจาก delay เล็กน้อย
				setTimeout(() => {
					safeAutoUpdateRoute();
				}, autoRouteUpdate.updateDelay);
				
			} else {
				// ไม่มีปลายทาง แสดงแค่ notification (ไม่บอกตำแหน่งจุดเริ่มต้น)
				updateRouteControls();
				
				const message = currentLanguage === 'th' 
					? `📍 เปลี่ยนจุดเริ่มต้นแล้ว - กรุณาเลือกจุดหมาย`
					: `📍 Start point updated - Please select destination`;
				showNotification(message, 'success');
			}
		}

        function safeAutoUpdateRoute() {
            if (routingLock.isProcessing) {
                debugLog('⏳ Route update already in progress, skipping auto update...');
                return;
            }
            
            if (autoRouteUpdate.isUpdating) {
                debugLog('⏳ Auto update already in progress...');
                return;
            }
            
            autoRouteUpdate.isUpdating = true;
            
            try {
                // ตรวจสอบข้อมูลที่จำเป็น
                if (!startPoint || !selectedRoom || !roomData[selectedRoom]) {
                    debugLog('⚠️ Missing required data for auto route update');
                    autoRouteUpdate.isUpdating = false;
                    return;
                }
                
                // เคลียร์เส้นทางเดิม
                safeClearRouteVisuals();
                
                // สร้างเส้นทางใหม่
                const destination = roomData[selectedRoom];
                currentRoute = { start: startPoint, destination: destination };
                
                debugLog('🔄 Auto-updating route', { start: startPoint, destination: destination.name });
                
                // ใช้ safe walkable routing
                safeShowWalkableRoutePath(startPoint, destination);
                
                // อัปเดต state
                routeDisplayed = true;
                updateRouteControls(true);
                updateRoomMarkers();
                
                debugLog('✅ Auto route update completed');
                
            } catch (error) {
                debugLog('❌ Error in auto route update', error);
                showNotification('❌ เกิดข้อผิดพลาดในการอัปเดตเส้นทาง', 'error');
            } finally {
                autoRouteUpdate.isUpdating = false;
            }
        }
		
		
        // ========== 9. Initialization Functions ==========
        
        // เริ่มต้นระบบ walkable routing
		// อัปเดต initialization เพื่อใช้ fixed grid
		function initializeWalkableRouting() {
			debugLog('🚀 Initializing walkable routing system with fixed grid...');
			
			// โหลดข้อมูลจาก localStorage หรือสร้าง fixed grid
			loadWalkableData();
			
			// ตั้งค่าอาคารปัจจุบัน
			walkableRoutingData.currentBuilding = getCurrentBuilding();
			
			walkableRoutingData.isInitialized = true;
			
			debugLog('✅ Fixed walkable routing initialized:', {
				nodesCount: Object.keys(walkableRoutingData.nodes).length,
				edgesCount: walkableRoutingData.edges.length,
				building: walkableRoutingData.currentBuilding,
				gridType: 'Fixed 6x6 + Strategic',
				startPointVisible: false
			});
		}

        // แทนที่ฟังก์ชัน loadWalkableData เดิม
		function loadWalkableData() {
			const building = getCurrentBuilding();
			const storageKey = `walkableData_${building}`;
			const savedData = localStorage.getItem(storageKey);
			
			let useFixed = true;  // ใช้ fixed grid เป็นหลัก
			
			if (savedData) {
				try {
					const data = JSON.parse(savedData);
					
					// ตรวจสอบว่าเป็น fixed grid data หรือไม่
					if (data.gridInfo && data.gridInfo.type === 'fixed_grid') {
						walkableRoutingData.nodes = data.nodes || {};
						walkableRoutingData.edges = data.edges || [];
						
						if (data.settings) {
							walkableRoutingData.settings = { ...walkableRoutingData.settings, ...data.settings };
						}
						
						debugLog('📁 Loaded fixed grid data from localStorage:', storageKey);
						debugLog('Grid info:', data.gridInfo);
						useFixed = false;  // ใช้ข้อมูลที่มีอยู่แล้ว
					}
				} catch (error) {
					console.error('Error loading walkable data:', error);
					useFixed = true;  // สร้างใหม่
				}
			}
			
			if (useFixed) {
				debugLog('🏗️ Creating new fixed walkable grid...');
				createFixedWalkableGrid();
			}
		}

        // ได้ building ปัจจุบัน
        function getCurrentBuilding() {
            return window.currentSelectedBuilding || 
                   document.querySelector('.building-filter-active')?.textContent || 
                   'Main Building';
        }

        // สร้าง route path element ถ้าไม่มี
        function createRoutePathElement() {
			let routePath = document.getElementById('routePath');
			
			if (!routePath) {
				const mapContainer = document.getElementById('mapContainer') || 
								   document.querySelector('.map-area') ||
								   document.querySelector('.map-container');
				
				if (mapContainer) {
					routePath = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
					routePath.id = 'routePath';
					routePath.className = 'route-path';
					// ลบบรรทัดเหล่านี้แล้ว:
					routePath.setAttribute('viewBox', '0 0 100 100');
				    routePath.setAttribute('preserveAspectRatio', 'none');
					
					// เก็บเฉพาะบรรทัดเหล่านี้:
					routePath.style.position = 'absolute';
					routePath.style.top = '0';
					routePath.style.left = '0';
					routePath.style.width = '100%';
					routePath.style.height = '100%';
					//routePath.style.pointerEvents = 'none';
					//routePath.style.zIndex = '10';
					
					mapContainer.appendChild(routePath);
				}
			}
			
			return routePath;
		}
				 

        // ========== 11. Integration and Auto-Initialize ==========
        
        // แทนที่ฟังก์ชันเดิมด้วยเวอร์ชันปลอดภัย
        function replaceFunctionsWithSafeVersions() {
            debugLog('🔄 Replacing functions with safe versions...');
            
            // Backup original functions
            if (typeof window.originalShowWalkableRoutePath === 'undefined') {
                window.originalShowStraightRoutePath = window.showStraightRoutePath;
            }
            
            // Replace with safe versions
            window.showStraightRoutePath = safeShowWalkableRoutePath;
            window.clearRouteVisuals = safeClearRouteVisuals;
            
            debugLog('✅ Functions replaced with safe versions');
        }

        // แทนที่ event listeners เดิม
        function initializeEnhancedRouting() {
            debugLog('🚀 Initializing enhanced auto-route system...');
            
            // โหลดการตั้งค่าจาก localStorage
            const savedSetting = localStorage.getItem('autoRouteUpdateEnabled');
            if (savedSetting !== null) {
                autoRouteUpdate.enabled = savedSetting === 'true';
            }
            
            // หา map area elements
            const mapAreas = document.querySelectorAll('.map-area, #mapContainer, .map-container');
            
            mapAreas.forEach(mapArea => {
                if (mapArea) {
                    // ลบ event listeners เดิม
                    const newMapArea = mapArea.cloneNode(true);
                    mapArea.parentNode.replaceChild(newMapArea, mapArea);
                    
                    // เพิ่ม enhanced event listener
                    newMapArea.addEventListener('click', enhancedMapClickHandler);
                    debugLog('✅ Enhanced click handler attached to:', newMapArea.className);
                }
            });
            
            debugLog('🎯 Enhanced auto-route system initialized!');
        }
		//************************* V1.2End: Dijkstra *************************
	
		// 🔗 Admin-Index Integration Bridge V1.3
		// ========== 1. Compatibility Analysis ==========
		/*V1.3
		🔍 CONFLICTS DETECTED:

		Admin.html ใช้:
		- walkablePointsData (global object)
		- Dynamic node creation (click to add)
		- localStorage key: walkableData_${building}
		- Manual node management via UI

		Index.html ใช้:
		- walkableRoutingData (global object) 
		- Fixed grid system (48 nodes)
		- localStorage key: walkableData_${building} (SAME!)
		- Automatic grid generation

		❌ CONFLICT: Data structure และ management approach ต่างกัน
		✅ SOLUTION: สร้าง integration bridge
		*/
 

		// ========== 3. Data Format Converter ==========

		// แปลงจาก admin format เป็น index format
		function convertAdminToIndexFormat(adminData) {
			if (!adminData || !adminData.nodes) return null;
			
			debugLog('🔄 Converting admin data to index format...', {
				adminNodes: Object.keys(adminData.nodes).length,
				adminEdges: adminData.edges ? adminData.edges.length : 0
			});
			
			const indexData = {
				nodes: {},
				edges: [],
				settings: {
					metersPerPercent: adminData.settings?.metersPerPercent || 1.2,
					maxSearchRadius: adminData.settings?.maxConnectionDistance || 25,
					defaultWalkSpeed: 1.5
				},
				currentBuilding: adminData.building || adminData.currentBuilding,
				lastPath: null,
				isInitialized: true,
				dataSource: 'admin',
				syncTime: new Date().toISOString()
			};
			
			// แปลง nodes
			Object.values(adminData.nodes).forEach(node => {
				indexData.nodes[node.id] = {
					id: node.id,
					x: node.x,
					y: node.y,
					type: node.type || 'admin',  // mark as admin-created
					building: node.building || indexData.currentBuilding,
					isFixed: false,  // admin nodes ไม่ใช่ fixed
					source: 'admin'
				};
			});
			
			// แปลง edges
			if (adminData.edges && Array.isArray(adminData.edges)) {
				adminData.edges.forEach(edge => {
					indexData.edges.push({
						from: edge.from,
						to: edge.to,
						weight: edge.weight,
						bidirectional: edge.bidirectional !== false,
						type: 'admin',
						source: 'admin'
					});
				});
			}
			
			debugLog('✅ Admin to index conversion completed:', {
				convertedNodes: Object.keys(indexData.nodes).length,
				convertedEdges: indexData.edges.length
			});
			
			return indexData;
		}

		// แปลงจาก index format เป็น admin format
		function convertIndexToAdminFormat(indexData) {
			if (!indexData || !indexData.nodes) return null;
			
			debugLog('🔄 Converting index data to admin format...', {
				indexNodes: Object.keys(indexData.nodes).length,
				indexEdges: indexData.edges ? indexData.edges.length : 0
			});
			
			const adminData = {
				currentBuilding: indexData.currentBuilding,
				building: indexData.currentBuilding,
				nodes: {},
				edges: [],
				settings: {
					maxConnectionDistance: indexData.settings?.maxSearchRadius || 25,
					metersPerPercent: indexData.settings?.metersPerPercent || 1.2,
					autoConnect: true,
					snapToGrid: false,
					gridSize: 5
				},
				selectedNodes: new Set(),
				isDragging: false,
				dragNode: null,
				dataSource: 'index',
				syncTime: new Date().toISOString()
			};
			
			// แปลง nodes
			Object.values(indexData.nodes).forEach(node => {
				adminData.nodes[node.id] = {
					id: node.id,
					x: node.x,
					y: node.y,
					type: node.type || 'grid',
					building: node.building || adminData.currentBuilding,
					source: node.source || 'index'
				};
			});
			
			// แปลง edges
			if (indexData.edges && Array.isArray(indexData.edges)) {
				indexData.edges.forEach(edge => {
					adminData.edges.push({
						from: edge.from,
						to: edge.to,
						weight: edge.weight,
						bidirectional: edge.bidirectional !== false,
						source: edge.source || 'index'
					});
				});
			}
			
			debugLog('✅ Index to admin conversion completed:', {
				convertedNodes: Object.keys(adminData.nodes).length,
				convertedEdges: adminData.edges.length
			});
			
			return adminData;
		}

		// ========== 4. Smart Data Sync ==========

		// อัปเดตข้อมูลใน index.html จาก admin data
		function syncAdminDataToIndex(building) {
			if (!ADMIN_INDEX_BRIDGE.isIndexMode()) return false;
			
			debugLog('📥 Syncing admin data to index...', { building });
			
			try {
				// โหลดข้อมูลจาก admin
				const storageKey = `walkableData_${building}`;
				const adminDataString = localStorage.getItem(storageKey);
				
				if (!adminDataString) {
					debugLog('⚠️ No admin data found, using fixed grid');
					return false;
				}
				
				const adminData = JSON.parse(adminDataString);
				
				// ตรวจสอบว่าเป็นข้อมูลจาก admin หรือไม่
				if (adminData.dataSource === 'index') {
					debugLog('ℹ️ Data source is index, no sync needed');
					return false;
				}
				
				// แปลงเป็น index format
				const indexData = convertAdminToIndexFormat(adminData);
				if (!indexData) {
					debugLog('❌ Failed to convert admin data');
					return false;
				}
				
				// อัปเดต walkableRoutingData
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					debugLog('✅ walkableRoutingData updated from admin');
				}
				
				// อัปเดต localStorage สำหรับ index
				const indexStorageKey = `walkableData_${building}_index`;
				localStorage.setItem(indexStorageKey, JSON.stringify(indexData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('✅ Admin data synced to index successfully');
				return true;
				
			} catch (error) {
				debugLog('❌ Error syncing admin data to index:', error);
				return false;
			}
		}

		// อัปเดตข้อมูลใน admin.html จาก index data
		function syncIndexDataToAdmin(building) {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) return false;
			
			debugLog('📤 Syncing index data to admin...', { building });
			
			try {
				// โหลดข้อมูลจาก index
				const indexStorageKey = `walkableData_${building}_index`;
				const indexDataString = localStorage.getItem(indexStorageKey);
				
				if (!indexDataString) {
					debugLog('⚠️ No index data found');
					return false;
				}
				
				const indexData = JSON.parse(indexDataString);
				
				// แปลงเป็น admin format
				const adminData = convertIndexToAdminFormat(indexData);
				if (!adminData) {
					debugLog('❌ Failed to convert index data');
					return false;
				}
				
				// อัปเดต walkablePointsData
				if (typeof walkablePointsData !== 'undefined') {
					Object.assign(walkablePointsData, adminData);
					
					// Render ใหม่ถ้ามีฟังก์ชัน
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
					
					debugLog('✅ walkablePointsData updated from index');
				}
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('✅ Index data synced to admin successfully');
				return true;
				
			} catch (error) {
				debugLog('❌ Error syncing index data to admin:', error);
				return false;
			}
		}

		// ========== 5. Automatic Sync Triggers ==========

		// ตรวจสอบและ sync อัตโนมัติเมื่อโหลดหน้า
		function autoSyncOnPageLoad() {
			if (!ADMIN_INDEX_BRIDGE.syncEnabled) return;
			
			const building = getCurrentBuilding();
			if (!building) return;
			
			debugLog('🔄 Auto-sync on page load...', { 
				building, 
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode()
			});
			
			if (ADMIN_INDEX_BRIDGE.isIndexMode()) {
				// ใน index.html - ลองโหลดข้อมูลจาก admin ก่อน
				const adminSynced = syncAdminDataToIndex(building);
				
				if (!adminSynced) {
					debugLog('📋 No admin data available, creating fixed grid for index');
					// สร้าง fixed grid ตามปกติ
					if (typeof createFixedWalkableGrid === 'function') {
						createFixedWalkableGrid();
					}
				} else {
					debugLog('✅ Using admin-created walkable points in index');
				}
				
			} else if (ADMIN_INDEX_BRIDGE.isAdminMode()) {
				// ใน admin.html - โหลดข้อมูลปกติ
				debugLog('📋 Admin mode: Using standard admin data loading');
			}
		}

		// ========== 6. Enhanced Integration Functions ==========

		// แทนที่ฟังก์ชัน loadWalkableData เดิมใน index.html
		function loadWalkableDataWithAdminSync() {
			const building = getCurrentBuilding();
			const storageKey = `walkableData_${building}`;
			const indexStorageKey = `walkableData_${building}_index`;
			
			debugLog('📁 Loading walkable data with admin sync...', { building });
			
			// ลองโหลดจาก admin ก่อน
			const adminSynced = syncAdminDataToIndex(building);
			
			if (adminSynced) {
				debugLog('✅ Loaded admin-created walkable data');
				return;
			}
			
			// ถ้าไม่มีข้อมูลจาก admin ให้ลองโหลดจาก index cache
			const indexDataString = localStorage.getItem(indexStorageKey);
			if (indexDataString) {
				try {
					const data = JSON.parse(indexDataString);
					Object.assign(walkableRoutingData, data);
					debugLog('📁 Loaded cached index walkable data');
					return;
				} catch (error) {
					debugLog('⚠️ Error loading cached data:', error);
				}
			}
			
			// สุดท้ายถ้าไม่มีข้อมูลใดๆ ให้สร้าง fixed grid
			debugLog('🏗️ No existing data, creating fixed grid');
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
			}
		}

		// ปรับปรุงฟังก์ชัน saveWalkableData ใน admin.html
		function enhancedSaveWalkableData() {
			if (typeof saveWalkableData === 'function') {
				// เรียกฟังก์ชันเดิมก่อน
				saveWalkableData();
				
				// จากนั้น sync ไป index
				const building = getCurrentBuilding() || walkablePointsData?.currentBuilding;
				if (building) {
					debugLog('💾 Syncing saved admin data to index format...');
					
					// อัปเดต data source flag
					if (walkablePointsData) {
						walkablePointsData.dataSource = 'admin';
						walkablePointsData.syncTime = new Date().toISOString();
					}
					
					// บันทึกข้อมูลใหม่พร้อม flag
					const storageKey = `walkableData_${building}`;
					localStorage.setItem(storageKey, JSON.stringify(walkablePointsData));
					
					debugLog('✅ Admin data saved with sync metadata');
				}
			}
		}

		// ========== 7. UI Integration Helpers ==========

		// เพิ่ม sync status indicator ใน admin
		function addSyncStatusIndicator() {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) return;
			
			const header = document.querySelector('.walkable-header');
			if (!header || document.getElementById('syncStatus')) return;
			
			const syncStatus = document.createElement('div');
			syncStatus.id = 'syncStatus';
			syncStatus.className = 'sync-status';
			syncStatus.innerHTML = `
				<div class="sync-indicator">
					<i class="fas fa-sync"></i>
					<span>Sync Ready</span>
				</div>
			`;
			
			// เพิ่ม CSS
			const style = document.createElement('style');
			style.textContent = `
				.sync-status {
					display: flex;
					align-items: center;
					gap: 8px;
					font-size: 12px;
					color: var(--text-secondary);
				}
				
				.sync-indicator {
					display: flex;
					align-items: center;
					gap: 4px;
					padding: 4px 8px;
					background: #f0f9ff;
					border: 1px solid #bae6fd;
					border-radius: 4px;
				}
				
				.sync-indicator.syncing {
					background: #fef3c7;
					border-color: #fcd34d;
				}
				
				.sync-indicator.synced {
					background: #dcfce7;
					border-color: #86efac;
				}
				
				.sync-indicator i {
					font-size: 10px;
				}
				
				.sync-indicator.syncing i {
					animation: spin 1s linear infinite;
				}
				
				@keyframes spin {
					from { transform: rotate(0deg); }
					to { transform: rotate(360deg); }
				}
			`;
			document.head.appendChild(style);
			
			header.appendChild(syncStatus);
		}

		// อัปเดต sync status
		function updateSyncStatus(status, message) {
			const indicator = document.querySelector('.sync-indicator');
			if (!indicator) return;
			
			indicator.className = `sync-indicator ${status}`;
			
			const statusMessages = {
				ready: '🔄 พร้อม sync',
				syncing: '⏳ กำลัง sync...',
				synced: '✅ Sync แล้ว',
				error: '❌ Sync ผิดพลาด'
			};
			
			indicator.querySelector('span').textContent = message || statusMessages[status] || status;
		}

		// ========== 8. Debug and Monitoring ==========

		// ตรวจสอบสถานะ compatibility
		function debugCompatibilityStatus() {
			console.group('🔍 Admin-Index Compatibility Status');
			
			console.log('Environment:', {
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode(),
				syncEnabled: ADMIN_INDEX_BRIDGE.syncEnabled
			});
			
			// ตรวจสอบ global objects
			const adminDataExists = typeof walkablePointsData !== 'undefined';
			const indexDataExists = typeof walkableRoutingData !== 'undefined';
			
			console.log('Global Objects:', {
				walkablePointsData: adminDataExists ? 'EXISTS' : 'NOT FOUND',
				walkableRoutingData: indexDataExists ? 'EXISTS' : 'NOT FOUND'
			});
			
			// ตรวจสอบข้อมูลใน localStorage
			const building = getCurrentBuilding();
			if (building) {
				const adminKey = `walkableData_${building}`;
				const indexKey = `walkableData_${building}_index`;
				
				const adminData = localStorage.getItem(adminKey);
				const indexData = localStorage.getItem(indexKey);
				
				console.log('LocalStorage Data:', {
					adminData: adminData ? 'EXISTS' : 'NOT FOUND',
					indexData: indexData ? 'EXISTS' : 'NOT FOUND',
					lastSync: ADMIN_INDEX_BRIDGE.lastSyncTime
				});
				
				if (adminData) {
					try {
						const parsed = JSON.parse(adminData);
						console.log('Admin Data Summary:', {
							nodes: Object.keys(parsed.nodes || {}).length,
							edges: (parsed.edges || []).length,
							source: parsed.dataSource,
							building: parsed.building || parsed.currentBuilding
						});
					} catch (e) {
						console.warn('⚠️ Admin data parsing error:', e);
					}
				}
			}
			
			console.log('Sync Status:', ADMIN_INDEX_BRIDGE);
			console.groupEnd();
		}

		// ========== 9. Auto-Initialize Integration ==========

		// Initialize integration bridge
		function initializeAdminIndexBridge() {
			debugLog('🌉 Initializing Admin-Index Integration Bridge...');
			
			try {
				// ตรวจสอบ environment
				const isAdmin = ADMIN_INDEX_BRIDGE.isAdminMode();
				const isIndex = ADMIN_INDEX_BRIDGE.isIndexMode();
				
				debugLog('Environment detection:', { isAdmin, isIndex });
				
				if (isAdmin) {
					// Admin mode setup
					addSyncStatusIndicator();
					updateSyncStatus('ready');
					
					// Hook into save function
					if (typeof window.saveWalkableData === 'function') {
						const originalSave = window.saveWalkableData;
						window.saveWalkableData = function() {
							updateSyncStatus('syncing');
							const result = originalSave.apply(this, arguments);
							enhancedSaveWalkableData();
							updateSyncStatus('synced');
							return result;
						};
					}
					
				} else if (isIndex) {
					// Index mode setup
					autoSyncOnPageLoad();
					
					// แทนที่ฟังก์ชัน loadWalkableData
					if (typeof window.loadWalkableData === 'function') {
						window.originalLoadWalkableData = window.loadWalkableData;
						window.loadWalkableData = loadWalkableDataWithAdminSync;
					}
				}
				
				debugLog('✅ Admin-Index Integration Bridge initialized');
				
			} catch (error) {
				debugLog('❌ Error initializing bridge:', error);
			}
		}

		// Auto-initialize based on page type
		document.addEventListener('DOMContentLoaded', function() {
			setTimeout(() => {
				initializeAdminIndexBridge();
				
				// Debug compatibility after initialization
				setTimeout(() => {
					debugCompatibilityStatus();
				}, 2000);
				
			}, 1000);
		});

		// Export bridge functions
		window.adminIndexBridge = {
			sync: {
				adminToIndex: syncAdminDataToIndex,
				indexToAdmin: syncIndexDataToAdmin,
				auto: autoSyncOnPageLoad
			},
			convert: {
				adminToIndex: convertAdminToIndexFormat,
				indexToAdmin: convertIndexToAdminFormat
			},
			debug: debugCompatibilityStatus,
			config: ADMIN_INDEX_BRIDGE
		};
	//******************* End Admin-index Integration bridge *********************
	
	</script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
		 
			<!-- ย้าย Version Indicator ไปมุมขวาบน -->
			<span id="globalVersionIndicator" class="status-indicator status-connected" 
				  style="position: absolute; top: 2px; right: 10px; z-index: 200; font-size: 8px; padding: 1px 6px;">
			</span>
			
			<div class="header-top">
				<img class="school-logo" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%23667eea'/%3E%3Ctext x='50' y='60' text-anchor='middle' font-family='Arial' font-size='40' fill='white'%3E🏫%3C/text%3E%3C/svg%3E" alt="School Logo">
				
				<div class="header-title">
					<h1 id="systemTitle">🏫 ระบบแผนที่โรงเรียนอัจฉริยะ</h1>
					<p id="systemSubtitle">ค้นหาห้องเรียนและสถานที่ต่างๆ พร้อมระบบนำทางด้วยเสียง</p>
				</div>
				
				<button class="header-btn language-btn" onclick="toggleLanguage()">
					<i class="fas fa-globe"></i>
					<span id="languageText">TH</span>
				</button>
			</div>
		

        <!-- ======================== Search Page ======================== -->
        <div class="page active" id="search-page">
            <div class="search-container">
                <h2><i class="fas fa-search"></i> <span data-translate="search_title">ค้นหาห้องเรียนและสถานที่</span></h2>
                
                <div class="search-box">
                    <input class="search-input" id="searchInput" 
                           onkeypress="handleSearchKeyPress(event)" 
                           oninput="liveSearch()" 
                           placeholder="🔍 พิมพ์ชื่อห้อง รหัส หรือตำแหน่ง..." 
                           data-placeholder-th="🔍 พิมพ์ชื่อห้อง รหัส หรือตำแหน่ง..."
                           data-placeholder-en="🔍 Search room, code, or location..."
                           type="text">
                    <button class="search-btn" onclick="searchRoom()">
                        <i class="fas fa-search"></i> <span data-translate="search_btn">ค้นหา</span>
                    </button>
                </div>
                
                <div class="live-results" id="liveResults"></div>
            </div>

            <div class="quick-categories">
                <div class="category-card" onclick="quickSearch('classroom')">
                    <i class="fas fa-graduation-cap"></i>
                    <h4 data-translate="category_classroom">ห้องเรียน</h4>
                    <p data-translate="category_classroom_desc">ห้องเรียนปกติทั้งหมด</p>
                </div>
                <div class="category-card" onclick="quickSearch('special')">
                    <i class="fas fa-flask"></i>
                    <h4 data-translate="category_special">ห้องพิเศษ</h4>
                    <p data-translate="category_special_desc">ห้องปฏิบัติการ</p>
                </div>
                <div class="category-card" onclick="quickSearch('facilities')">
                    <i class="fas fa-building"></i>
                    <h4 data-translate="category_facilities">สิ่งอำนวยความสะดวก</h4>
                    <p data-translate="category_facilities_desc">ห้องสมุด โรงอาหาร</p>
                </div>
                <div class="category-card" onclick="quickSearch('office')">
                    <i class="fas fa-briefcase"></i>
                    <h4 data-translate="category_office">ห้องสำนักงาน</h4>
                    <p data-translate="category_office_desc">ห้องผู้บริหาร</p>
                </div>
            </div>
        </div>

        <!-- ======================== Map Page ======================== -->
        <div class="page" id="map-page">
            <!--
			<h2><i class="fas fa-map"></i> <span data-translate="map_title">แผนที่โรงเรียน</span></h2>
            -->
			  <!-- แก้ไข: กล่องวิธีการใช้งานแบบ Toggle  
			<div id="usageGuideContainer" style="background: linear-gradient(135deg, #f8f9ff, #e6f3ff); border-radius: var(--border-radius); margin-bottom: 20px; overflow: hidden; border: 2px solid var(--border-color);">
			 
				
				<div style="padding: 15px; text-align: center; cursor: pointer; background: rgba(102, 126, 234, 0.1);" onclick="toggleUsageGuide()">
					<i class="fas fa-question-circle" style="color: var(--primary-color); margin-right: 8px;"></i>
					<span style="color: var(--primary-color); font-weight: 600; font-size: 14px;" id="usageGuideToggleText">
						<span data-translate="show_usage_guide">แสดงวิธีการใช้งาน</span>
					</span>
					<i class="fas fa-chevron-down" id="usageGuideChevron" style="color: var(--primary-color); margin-left: 8px; transition: transform 0.3s ease;"></i>
				</div>
				
				 
				<div id="usageGuideContent" style="display: none; padding: 20px; border-top: 1px solid var(--border-color);">
					<h4 style="color: var(--primary-color); margin-bottom: 15px; text-align: center;">
						<i class="fas fa-info-circle"></i> <span data-translate="usage_guide_title">วิธีการใช้งานแผนที่</span>
					</h4>
					<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
						<div style="background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px; border-left: 4px solid var(--primary-color);">
							<div style="color: var(--primary-color); font-weight: 600; margin-bottom: 8px;">
								<i class="fas fa-search"></i> <span data-translate="step1">ขั้นตอนที่ 1: ค้นหาห้อง</span>
							</div>
							<p style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; margin: 0;">
								<span data-translate="step1_desc">ไปหน้าค้นหา เลือกห้องที่ต้องการ หรือคลิกหมวดหมู่ด่วน</span>
							</p>
						</div>
						<div style="background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px; border-left: 4px solid var(--accent-color);">
							<div style="color: var(--accent-color); font-weight: 600; margin-bottom: 8px;">
								<i class="fas fa-map-marker-alt"></i> <span data-translate="step2">ขั้นตอนที่ 2: กำหนดจุดเริ่มต้น</span>
							</div>
							<p style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; margin: 0;">
								<span data-translate="step2_desc">คลิกที่แผนที่เพื่อกำหนดตำแหน่งที่คุณอยู่</span>
							</p>
						</div>
						<div style="background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px; border-left: 4px solid var(--warning-color);">
							<div style="color: #856404; font-weight: 600; margin-bottom: 8px;">
								<i class="fas fa-route"></i> <span data-translate="step3">ขั้นตอนที่ 3: ดูเส้นทาง</span>
							</div>
							<p style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; margin: 0;">
								<span data-translate="step3_desc">คลิก "แสดงเส้นทาง" เพื่อดูการนำทางแบบ step by step</span>
							</p>
						</div>
					</div>
				</div>
			</div>
			-->	
            <!-- 1.1: Map controls with toggle -->
            <!-- แทนที่ส่วน map-controls ใน index.html
			<div class="map-controls" id="mapControls">
				<button class="map-control-btn toggle-btn" onclick="toggleMapControls()" id="toggleControlsBtn">
					<i class="fas fa-eye-slash"></i> <span data-translate="hide_controls">ซ่อนปุ่ม</span>
				</button>
				<button class="map-control-btn" onclick="setMapLayout('floorplan')" id="floorplanBtn" data-layout="floorplan">
					<i class="fas fa-th-large"></i> <span data-translate="floorplan">แผนผัง</span>
				</button>
				
				<button class="map-control-btn" onclick="setMapLayout('photo')" id="photoBtn" data-layout="photo">
					<i class="fas fa-camera"></i> <span data-translate="real_photo">ภาพจริง</span>
				</button>
				<button class="map-control-btn" onclick="toggleFullscreen()" id="fullscreenBtn">
					<i class="fas fa-expand"></i> <span data-translate="fullscreen">เต็มจอ</span>
				</button>
			</div>
			 -->
            
            <div class="map-container">
                <div class="map-area" id="mapArea">
                    <img id="mapImage" class="map-image" 
                         src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='600' viewBox='0 0 800 600'%3E%3Crect width='800' height='600' fill='%23f0f8ff'/%3E%3Ctext x='400' y='280' text-anchor='middle' font-family='Arial' font-size='28' fill='%23667eea' font-weight='bold'%3E🏫 แผนที่โรงเรียนอัจฉริยะ%3C/text%3E%3Ctext x='400' y='320' text-anchor='middle' font-family='Arial' font-size='16' fill='%23999'%3E(คลิกเพื่อกำหนดจุดเริ่มต้น)%3C/text%3E%3Ctext x='400' y='350' text-anchor='middle' font-family='Arial' font-size='14' fill='%23667eea'%3E📍 คลิกจุดบนแผนที่เพื่อดูข้อมูลห้อง%3C/text%3E%3C/svg%3E" 
                         alt="แผนที่โรงเรียน">
                    
                    <!-- Route Path SVG -->
                    <svg class="route-path" id="routePath" style="display: none;">
                        <!-- Path elements will be created by JavaScript -->
                    </svg>
                    
                    <!-- 1.2: Room action selection overlay -->
                    <div class="room-action-overlay" id="roomActionOverlay">
                        <div class="room-action-header" id="roomActionHeader">เลือกการดำเนินการ</div>
                        <button class="room-action-btn" onclick="showRoomDetails()">
                            <i class="fas fa-info-circle"></i>
                            <span data-translate="view_details">ดูรายละเอียดห้อง</span>
                        </button>
                        <button class="room-action-btn" onclick="showRouteDirectly()">
                            <i class="fas fa-route"></i>
                            <span data-translate="show_route_direct">แสดงเส้นทาง</span>
                        </button>
                    </div>
                    
                    <div id="roomMarkers"></div>
                </div>
				<button class="show-controls-btn" id="showControlsBtn" onclick="showAllControls()">
				<i class="fas fa-eye"></i> <span data-translate="show_controls">แสดงปุ่ม</span>
			</button>
            </div>
            
            <!-- Route Controls moved outside map -->
            <div class="route-controls">
			<div id="destinationStatus" style="
				position: fixed; 
				top: 80px; 
				right: 20px; 
				background: rgba(102, 126, 234, 0.95); 
				color: white; 
				padding: 10px 15px; 
				border-radius: 20px; 
				font-size: 14px; 
				display: none;
				z-index: 1000;
				box-shadow: 0 4px 12px rgba(0,0,0,0.15);
			">
				<i class="fas fa-map-marker-alt"></i> 
				<span id="destinationText">-</span>
				<button onclick="clearDestination(); updateDestinationDisplay();" style="
					background: none; 
					border: none; 
					color: white; 
					margin-left: 8px; 
					cursor: pointer;
					opacity: 0.8;
				">
					<i class="fas fa-times"></i>
				</button>
			</div>
                <button class="route-control-btn" onclick="showRouteToSelected()" id="showRouteBtn" disabled>
                    <i class="fas fa-route"></i> <span data-translate="show_route">แสดงเส้นทาง</span>
                </button>
                <button class="route-control-btn clear-route-btn" onclick="clearRoute()" id="clearRouteBtn" style="display: none;">
                    <i class="fas fa-times"></i> <span data-translate="clear_route">ล้างเส้นทาง</span>
                </button>
                <button class="route-control-btn voice-btn" onclick="startContinuousVoiceNavigation()" id="voiceNavigationBtn" style="display: none;">
                    <i class="fas fa-volume-up"></i> <span data-translate="voice_nav">นำทางด้วยเสียง</span>
                </button>
            </div>
        </div>

        <!-- ======================== About Page ======================== -->
        <div class="page" id="about-page">
			<!-- Header Section -->
			<div style="text-align: center; margin-bottom: 30px;">
				<div style="font-size: 64px; margin-bottom: 20px;">🏫</div>
				<h1 style="color: var(--primary-color); margin-bottom: 10px; font-size: 2em;">
					<span data-translate="system_name">ระบบแผนที่โรงเรียนอัจฉริยะ V1.2</span>
				</h1>
				<p style="color: var(--text-secondary); font-size: 1.1em; max-width: 600px; margin: 0 auto; line-height: 1.6;">
					<span data-translate="system_desc">ระบบนำทางและค้นหาห้องเรียนที่ทันสมัย ออกแบบมาสำหรับการใช้งานบนมือถือเป็นหลัก พร้อมระบบนำทางด้วยเสียงและการแสดงเส้นทางอย่างชัดเจน</span>
				</p>
			</div>

			<!-- Features Grid -->
			<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;">
				<!-- Feature 1 -->
				<div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: var(--border-radius); text-align: center; box-shadow: var(--box-shadow);">
					<div style="font-size: 48px; margin-bottom: 15px;">🎯</div>
					<h3 style="margin-bottom: 10px; font-size: 1.2em;" data-translate="feature1_title">การนำทางที่แม่นยำ</h3>
					<p style="opacity: 0.9; font-size: 0.9em; line-height: 1.5;" data-translate="feature1_desc">กำหนดจุดเริ่มต้นได้ทุกตำแหน่งบนแผนที่ พร้อมเส้นทางที่ชัดเจน</p>
				</div>

				<!-- Feature 2 -->
				<div style="background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 25px; border-radius: var(--border-radius); text-align: center; box-shadow: var(--box-shadow);">
					<div style="font-size: 48px; margin-bottom: 15px;">🔊</div>
					<h3 style="margin-bottom: 10px; font-size: 1.2em;" data-translate="feature2_title">นำทางด้วยเสียง</h3>
					<p style="opacity: 0.9; font-size: 0.9em; line-height: 1.5;" data-translate="feature2_desc">ระบบอ่านคำแนะนำการเดินทางแบบขั้นตอน รองรับภาษาไทยและอังกฤษ</p>
				</div>

				<!-- Feature 3 -->
				<div style="background: linear-gradient(135deg, #17a2b8, #6f42c1); color: white; padding: 25px; border-radius: var(--border-radius); text-align: center; box-shadow: var(--box-shadow);">
					<div style="font-size: 48px; margin-bottom: 15px;">📱</div>
					<h3 style="margin-bottom: 10px; font-size: 1.2em;" data-translate="feature3_title">Mobile First</h3>
					<p style="opacity: 0.9; font-size: 0.9em; line-height: 1.5;" data-translate="feature3_desc">ออกแบบเพื่อมือถือเป็นหลัก ใช้งานง่าย UI ที่สวยงามและทันสมัย</p>
				</div>
			</div>

			<!-- New Features Section -->
			<div style="background: linear-gradient(135deg, #f8f9ff, #e6f3ff); padding: 30px; border-radius: var(--border-radius); margin-bottom: 25px; border: 2px solid var(--border-color);">
				<h2 style="text-align: center; color: var(--primary-color); margin-bottom: 25px; font-size: 1.5em;">
					<i class="fas fa-sparkles"></i> <span data-translate="whats_new">มีอะไรใหม่ในเวอร์ชัน 1.3</span>
				</h2>
				
				<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
					<div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 12px; border-left: 4px solid var(--primary-color);">
						<div style="display: flex; align-items: center; margin-bottom: 10px;">
							<div style="background: var(--primary-color); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 14px;">🎯</div>
							<h4 style="color: var(--primary-color); margin: 0;" data-translate="new1_title">จุดเริ่มต้นแบบ Custom</h4>
						</div>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; margin: 0;" data-translate="new1_desc">กำหนดจุดเริ่มต้นได้ทุกตำแหน่งบนแผนที่ตามต้องการ</p>
					</div>

					<div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 12px; border-left: 4px solid var(--accent-color);">
						<div style="display: flex; align-items: center; margin-bottom: 10px;">
							<div style="background: var(--accent-color); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 14px;">🛣️</div>
							<h4 style="color: var(--accent-color); margin: 0;" data-translate="new2_title">เส้นทางที่ชัดเจน</h4>
						</div>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; margin: 0;" data-translate="new2_desc">แสดงเส้นทางแบบเชื่อมจุดต่อจุดพร้อมแอนิเมชัน</p>
					</div>

					<div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 12px; border-left: 4px solid var(--warning-color);">
						<div style="display: flex; align-items: center; margin-bottom: 10px;">
							<div style="background: var(--warning-color); color: black; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 14px;">⚡</div>
							<h4 style="color: #856404; margin: 0;" data-translate="new3_title">ประสิทธิภาพสูง</h4>
						</div>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; margin: 0;" data-translate="new3_desc">โหลดเร็วขึ้น ใช้หน่วยความจำน้อยลง รองรับข้อมูลจำนวนมาก</p>
					</div>
				</div>
			</div>

			<!-- How to Use Section -->
			<div style="background: var(--card-background); padding: 30px; border-radius: var(--border-radius); margin-bottom: 25px; box-shadow: var(--box-shadow);">
				<h2 style="text-align: center; color: var(--primary-color); margin-bottom: 25px; font-size: 1.5em;">
					<i class="fas fa-question-circle"></i> <span data-translate="how_to_use">วิธีการใช้งาน</span>
				</h2>
				
				<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px;">
					<!-- Step 1 -->
					<div style="text-align: center;">
						<div style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 24px; font-weight: bold;">1</div>
						<h4 style="color: var(--primary-color); margin-bottom: 10px;" data-translate="step1_title">ค้นหาห้อง</h4>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6;" data-translate="step1_desc">ใช้ช่องค้นหาหรือคลิกหมวดหมู่ด่วนเพื่อหาห้องที่ต้องการ</p>
					</div>

					<!-- Step 2 -->
					<div style="text-align: center;">
						<div style="background: linear-gradient(135deg, var(--accent-color), #20c997); color: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 24px; font-weight: bold;">2</div>
						<h4 style="color: var(--accent-color); margin-bottom: 10px;" data-translate="step2_title">กำหนดจุดเริ่มต้น</h4>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6;" data-translate="step2_desc">คลิกที่แผนที่เพื่อกำหนดจุดเริ่มต้นการนำทาง</p>
					</div>

					<!-- Step 3 -->
					<div style="text-align: center;">
						<div style="background: linear-gradient(135deg, var(--info-color), #6f42c1); color: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 24px; font-weight: bold;">3</div>
						<h4 style="color: var(--info-color); margin-bottom: 10px;" data-translate="step3_title">ดูเส้นทาง</h4>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6;" data-translate="step3_desc">เลือกห้องที่ต้องการไป คลิก "แสดงเส้นทาง" เพื่อดูเส้นทางและคำแนะนำ</p>
					</div>
				</div>
			</div>

			<!-- Technical Info -->
			<div style="background: linear-gradient(135deg, #e8f5e8, #d4edda); padding: 25px; border-radius: var(--border-radius); border: 2px solid var(--accent-color);">
				<h3 style="text-align: center; color: var(--accent-color); margin-bottom: 20px;">
					<i class="fas fa-cog"></i> <span data-translate="tech_info">ข้อมูลทางเทคนิค</span>
				</h3>
				
				<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">🌐</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="web_tech">เทคโนโลยีเว็บ</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">HTML5, CSS3, JavaScript</div>
					</div>
					
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">📊</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="data_source">แหล่งข้อมูล</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">Google Sheets Integration</div>
					</div>
					
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">🔊</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="voice_tech">เทคโนโลยีเสียง</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">Web Speech API</div>
					</div>
					
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">📱</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="responsive">Responsive Design</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">Mobile First Approach</div>
					</div>
				</div>
			</div>
		</div>
    </div>

    <!-- Admin Link (Hidden) - Removed from bottom left -->

    <!-- Bottom Navigation -->
    <div class="bottom-navigation">
        <div class="nav-item active" onclick="showPage('search')">
            <i class="fas fa-search"></i>
            <span data-translate="nav_search">ค้นหา</span>
        </div>
        <div class="nav-item" onclick="showPage('map')">
            <i class="fas fa-map"></i>
            <span data-translate="nav_map">แผนที่</span>
        </div>
        <div class="nav-item" onclick="showPage('about')">
            <i class="fas fa-info-circle"></i>
            <span data-translate="nav_about">เกี่ยวกับ</span>
        </div>
        <!-- 1.3: Admin button moved to bottom navigation -->
        <div class="nav-item" onclick="openAdminInterface()" title="Admin Panel">
            <i class="fas fa-cog"></i>
            <span data-translate="nav_admin">จัดการ</span>
        </div>
		  <div class="nav-item" onclick="openSystemPresentation()" title="พรีเซ้นท์ระบบ">
            <i class="fas fa-exclamation-triangle"></i>
            <span data-translate="nav_Present">อธิบายระบบ</span>
        </div>
		
    </div>

    <!-- Room Info Overlay -->
    <div class="room-info-overlay" id="roomInfoOverlay">
        <div class="room-info-content">
            <div class="room-info-header">
                <div class="room-title" id="overlayRoomName"></div>
               <!-- <div style="font-size: 16px; opacity: 0.9;" id="overlayRoomLocation"></div> -->
                <button class="room-info-close" onclick="closeRoomInfoOverlay()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="room-info-body">
                <!-- 1.3: Remove status info, enhanced room information display -->
                <div class="compact-info">
                    <div class="info-item">
                        <div class="info-label" data-translate="info_building">🏢 อาคาร</div>
                        <div class="info-value" id="overlayRoomBuilding"></div>
                    </div>
                    <div class="info-item">
                        <div class="info-label" data-translate="info_floor">📍 ชั้น</div>
                        <div class="info-value" id="overlayRoomFloor"></div>
                    </div>
                    <div class="info-item">
						<div class="info-label" data-translate="info_type">🏷️ ประเภทห้อง</div>
                        <div class="info-value" id="overlayRoomType"></div>
                    </div>
                </div>
 
                
                <div style="background: rgba(255,255,255,0.7); padding: 20px; border-radius: var(--border-radius); margin-bottom: 20px;">
                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;" data-translate="info_description">รายละเอียด</div>
                    <div style="font-size: 16px;" id="overlayRoomDescription"></div>
                </div>
                
                <div id="overlayRoomGallery" style="display: none;">
                    <h4 style="font-size: 16px; color: var(--primary-color); margin-bottom: 15px;">
                        <i class="fas fa-images"></i> <span data-translate="room_images">รูปภาพห้อง</span>
                    </h4>
                    <div id="overlayImageGallery" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;"></div>
                </div>
                
                <div class="navigation-controls">
                    <button class="nav-control-btn" onclick="generateCompleteRoute()" id="routeBtn">
                        <i class="fas fa-route"></i> <span data-translate="route_navigation">เส้นทางนำทาง</span>
                    </button>
                    <button class="nav-control-btn voice-btn" onclick="toggleVoiceNavigation()" id="overlayVoiceBtn">
                        <i class="fas fa-volume-up"></i> <span data-translate="voice">เสียง</span>
                    </button>
                </div>
                
                <div id="overlayRouteSteps"></div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>
	
	<!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h3 style="color: var(--primary-color); margin-bottom: 10px;" id="loadingTitle">กำลังโหลดข้อมูล</h3>
            <p style="color: var(--text-secondary);" id="loadingMessage">กรุณารอสักครู่...</p>
        </div>
    </div>

    <script>
        // =================== Global Variables ===================
       // ======= Enhanced Global Variables =======
		let roomData = {};
		let selectedRoom = null;
		let startPoint = null;
		let voiceNavigationEnabled = false;
		let currentSpeech = null;
		let currentLanguage = 'th';
		let currentMapLayout = 'floorplan';
		let isFullscreen = false;
		let currentVersion = 'live'; // เปลี่ยนจาก 'demo' เป็น 'live'
		let buildingsData = {};

		// Enhanced variables
		let systemConfig = {
			version: 'demo',
			maintenance_mode: false,
			maintenance_message: 'เว็บไซต์อยู่ระหว่างการปรับปรุง'
		};
		let isMaintenanceMode = false;

		// Route persistence variables
		let currentRoute = null;
		let routeDisplayed = false;

		// Voice navigation queue
		let voiceQueue = [];
		let isVoiceNavigating = false;
		let voiceTimeout = null;

		// Sheets configuration (same as admin)
		 
		let sheetsConfig = {
			url: 'https://script.google.com/macros/s/AKfycbzpCFGZ_7kvyvAqiQGw3y_t6ROwUhh8Csp-I3xOPZZhP_XJ9Yyfyjsrl88s5qg3xx56/exec',
			buildingsSheet: 'Buildings',
			roomsSheet: 'Rooms',
			mapImagesSheet: 'MapImages',
			systemConfigSheet: 'SystemConfig',
			connected: false
		};
	
		// ======= ตัวแปรสำหรับจัดการภาพแผนที่ =======
		let mapData = {
			floorplan: null,
			realphoto: null,
			notes: '',
			loaded: false
		};

		 let persistentDestination = {
			roomCode: null,
			roomName: null,
			timestamp: null
		};
		
		
		// ปรับปรุง Cache System
		let CACHE_CONFIG = {
				buildings: {
					maxAge: 60 * 60 * 1000,  // 30 นาที
					priority: 'high',
					retryInterval: 50 * 60 * 1000  // ลองใหม่ทุก 5 นาที
				},
				rooms: {
					maxAge: 60 * 60 * 1000,  // 60 นาที  
					priority: 'high',
					retryInterval: 30 * 60 * 1000  // ลองใหม่ทุก 3 นาที
				},
				mapImages: {
					maxAge: 5 * 60 * 60 * 1000, // 5 ชั่วโมง
					priority: 'low',
					retryInterval: 30 * 60 * 1000  // ลองใหม่ทุก 30 นาที
				},
				batch: {
					maxAge: 10 * 60 * 1000,  // 10 นาที
					priority: 'highest'
				}
		};
		
		let IMAGE_STORAGE_CONFIG = {
			provider: 'github',
			
			github: {
				username: 'benzbil',        // 🔥 เปลี่ยนเป็น GitHub username จริง
				repo: 'school-map-images',               
				token: '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', // 🔥 เปลี่ยนเป็น Personal Access Token จริง
				branch: 'main',                          
				folder: 'room-images',                   
				baseUrl: 'https://raw.githubusercontent.com'
			} 
		};
		
		// ===== 🌐 Universal Code สำหรับทั้ง Local PC และ Web Server =====
		//  ✅ Environment Detection System
		const Environment = {
			isLocalPC: false,
			isWebServer: false,
			
			init() {
				try {
					// ตรวจสอบจาก protocol และ hostname
					const protocol = window.location.protocol;
					const hostname = window.location.hostname;
					
					this.isLocalPC = protocol === 'file:' || 
								   hostname === 'localhost' || 
								   hostname === '127.0.0.1' ||
								   hostname.startsWith('192.168.') ||
								   hostname.includes('.local');
								   
					this.isWebServer = !this.isLocalPC;
					
					console.log(`🌐 Environment: ${this.getType()}`);
				} catch (error) {
					console.warn('Environment detection error:', error);
					// Fallback เป็น web server
					this.isLocalPC = false;
					this.isWebServer = true;
				}
			},
			
			getType() {
				return this.isLocalPC ? 'Local PC' : 'Web Server';
			}
		};

		
		// 2. ปรับปรุงฟังก์ชันแสดงรูปในหน้า index
		function displayRoomImages(room) {
			if (!room.images || room.images.length === 0) {
				return '<p style="color: #666; text-align: center; padding: 20px;">ไม่มีรูปภาพ</p>';
			}
			
			return room.images.map((imageData, index) => {
				const imageUrl = typeof imageData === 'string' ? imageData : imageData.url;
				const provider = typeof imageData === 'string' ? 'unknown' : imageData.provider;
				const fileName = typeof imageData === 'string' ? `image-${index + 1}` : (imageData.fileName || `image-${index + 1}`);
				
				return `
					<div style="position: relative; display: inline-block; margin: 5px;">
						<div style="position: absolute; top: 5px; right: 5px; background: rgba(40, 167, 69, 0.9); color: white; border-radius: 4px; padding: 2px 6px; font-size: 10px; z-index: 2;" title="GitHub Storage">
							🐙
						</div>
						<img src="${imageUrl}" 
							 alt="${fileName}" 
							 style="width: 150px; height: 100px; object-fit: cover; border-radius: 8px; cursor: pointer; border: 2px solid #ddd;"
							 onclick="showImageModal('${imageUrl}', '${fileName}', 'github')"
							 onerror="this.style.opacity='0.5'; this.alt='รูปไม่พบ';">
					</div>
				`;
			}).join('');
		}

		// 3. เพิ่มฟังก์ชัน showImageModal สำหรับ index.html
		function showImageModal(imageUrl, fileName = '', provider = '') {
			const modal = document.createElement('div');
			modal.innerHTML = `
				<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 10000;">
					<div style="position: relative; max-width: 90%; max-height: 90%; background: white; border-radius: 8px; padding: 20px;">
						<div style="text-align: center; margin-bottom: 15px;">
							<h5 style="margin: 0; color: #333;">🐙 ${fileName}</h5>
							<small style="color: #666;">จาก GitHub Image Storage</small>
						</div>
						<img src="${imageUrl}" style="max-width: 100%; max-height: 70vh; object-fit: contain; border-radius: 4px;">
						<div style="text-align: center; margin-top: 15px;">
							<button onclick="window.open('${imageUrl}', '_blank')" 
									style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">
								ดูรูปต้นฉบับ
							</button>
							<button onclick="this.closest('div').remove()" 
									style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
								ปิด
							</button>
						</div>
						<button onclick="this.closest('div').remove()" 
								style="position: absolute; top: 10px; right: 15px; background: transparent; border: none; font-size: 24px; cursor: pointer; color: #666;">×</button>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
			modal.addEventListener('click', (e) => {
				if (e.target === modal) modal.remove();
			});
		}

		// 4. ปรับปรุงการแสดงข้อมูลห้องใน search results
		function updateSearchResults(results) {
			const container = document.getElementById('searchResults');
			if (!container) return;
			
			if (results.length === 0) {
				container.innerHTML = '<div class="no-results">ไม่พบห้องที่ตรองหา</div>';
				return;
			}
			
			container.innerHTML = results.map(room => `
				<div class="search-result-item" onclick="selectRoom('${room.code}')">
					<div class="room-info">
						<h4>${room.name}</h4>
						<p><strong>รหัส:</strong> ${room.code}</p>
						<p><strong>อาคาร:</strong> ${room.building} ชั้น ${room.floor}</p>
						<p><strong>ประเภท:</strong> ${room.type}</p>
						${room.description ? `<p><strong>รายละเอียด:</strong> ${room.description}</p>` : ''}
					</div>
					<div class="room-images">
						${displayRoomImages(room)}
					</div>
				</div>
			`).join('');
		}

		console.log('🌟 GitHub Image Storage Code Added to index.html');

		// Enhanced Cache Management
		function smartCacheLoader(dataType) {
			const config = CACHE_CONFIG[dataType];
			const cacheKey = getDataCacheKey(dataType);
			const timestampKey = getDataTimestampKey(dataType);
			
			// ตรวจสอบ cache validity
			if (isCacheValid(dataType, config.maxAge)) {
				const cachedData = getCachedData(dataType);
				if (cachedData) {
					console.log(`💾 Using cached ${dataType} data`);
					return cachedData;
				}
			}
			
			return null;
		}

		// Background Sync with Smart Timing
		async function intelligentSync() {
			if (!sheetsConfig.connected) return;
			
			const syncQueue = [];
			
			// ตรวจสอบข้อมูลที่ต้อง sync
			Object.keys(CACHE_CONFIG).forEach(dataType => {
				if (!isCacheValid(dataType, CACHE_CONFIG[dataType].maxAge)) {
					syncQueue.push({
						type: dataType,
						priority: CACHE_CONFIG[dataType].priority
					});
				}
			});
			
			// เรียงลำดับตาม priority
			syncQueue.sort((a, b) => {
				const priorities = { high: 3, medium: 2, low: 1 };
				return priorities[b.priority] - priorities[a.priority];
			});
			
			// Sync ทีละรายการ
			for (const item of syncQueue) {
				try {
					await syncDataType(item.type);
					await new Promise(resolve => setTimeout(resolve, 1000)); // หน่วงเวลา 1 วินาที
				} catch (error) {
					console.error(`Failed to sync ${item.type}:`, error);
				}
			}
		}

		// เรียกใช้ทุก 10 นาที
		setInterval(intelligentSync, 10 * 60 * 1000);
		
		
		// ======= Loading Overlay Functions =======
		function showLoadingOverlay(title, message) {
			const overlay = document.getElementById('loadingOverlay');
			const titleEl = document.getElementById('loadingTitle');
			const messageEl = document.getElementById('loadingMessage');
			
			if (overlay) overlay.style.display = 'flex';
			if (titleEl) titleEl.textContent = title || 'กำลังโหลดข้อมูล';
			if (messageEl) messageEl.textContent = message || 'กรุณารอสักครู่...';
		}

		function hideLoadingOverlay() {
			const overlay = document.getElementById('loadingOverlay');
			if (overlay) overlay.style.display = 'none';
		}
				
		// ======= Enhanced Version Management แบบเล็กกะทัดรัด =======
		function updateGlobalVersionIndicator(version) {
			const indicator = document.getElementById('globalVersionIndicator');
			if (!indicator) return;
			
			if (version === 'demo') {
				indicator.innerHTML = '🎮';  // เหลือแค่สัญลักษณ์
				indicator.className = 'status-indicator status-connected';
				indicator.title = 'Demo Mode'; // ใช้ tooltip แทน
			} else {
				// Live Mode - ตรวจสอบสถานะการเชื่อมต่อ Google Sheets
				if (sheetsConfig.connected) {
					indicator.innerHTML = '🔴';
					indicator.className = 'status-indicator status-active';
					indicator.title = 'Live Mode (Connected)';
				} else {
					indicator.innerHTML = '⚠️';
					indicator.className = 'status-indicator status-error';
					indicator.title = 'Live Mode (Disconnected)';
				}
			}
		}

		// ======= Loading Overlay Functions =======
		function showLoadingOverlay(title, message) {
			const overlay = document.getElementById('loadingOverlay');
			const titleEl = document.getElementById('loadingTitle');
			const messageEl = document.getElementById('loadingMessage');
			
			if (overlay) overlay.style.display = 'flex';
			if (titleEl) titleEl.textContent = title || 'กำลังโหลดข้อมูล';
			if (messageEl) messageEl.textContent = message || 'กรุณารอสักครู่...';
		}

		function hideLoadingOverlay() {
			const overlay = document.getElementById('loadingOverlay');
			if (overlay) overlay.style.display = 'none';
		}

		// ======= Data Caching System =======
		function getDataCacheKey(dataType) {
			return `${dataType}_cache_${currentVersion}`;
		}

		function getDataTimestampKey(dataType) {
			return `${dataType}_timestamp_${currentVersion}`;
		}

		// ======= ปรับปรุงฟังก์ชัน Cache Management =======
		function isCacheValid(dataType, customMaxAge = null) {
			const config = CACHE_CONFIG[dataType];
			const maxAge = customMaxAge || (config ? config.maxAge : 30 * 60 * 1000);
			
			const timestamp = localStorage.getItem(getDataTimestampKey(dataType));
			if (!timestamp) return false;
			
			const cacheAge = Date.now() - parseInt(timestamp);
			
			if (!Environment.isLocalPC) {  //Benz: กรณี Local PC ไม่ต้องใช้ cache
				return cacheAge < maxAge;
			}else{
				return false;  
			}
		}

		function setCachedData(dataType, data) {
			try {
				const dataString = JSON.stringify(data);
				const dataSize = new Blob([dataString]).size;
				
				// ตรวจสอบขนาดข้อมูล
				if (dataSize > 5 * 1024 * 1024) { // 5MB
					console.warn(`⚠️ Large data size for ${dataType}: ${(dataSize / 1024 / 1024).toFixed(2)}MB`);
					
					// สำหรับข้อมูลขนาดใหญ่ ให้บีบอัด
					if (dataType === 'mapImages') {
						return compressAndCacheMapData(data);
					}
				}
				
				localStorage.setItem(getDataCacheKey(dataType), dataString);
				localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
				
				console.log(`💾 Cached ${dataType}: ${(dataSize / 1024).toFixed(1)}KB`);
				return true;
				
			} catch (error) {
				console.error(`❌ Failed to cache ${dataType}:`, error);
				
				// ถ้า localStorage เต็ม ให้ลบ cache เก่า
				if (error.name === 'QuotaExceededError') {
					cleanOldCache();
					try {
						localStorage.setItem(getDataCacheKey(dataType), JSON.stringify(data));
						localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
						return true;
					} catch (retryError) {
						console.error('❌ Still failed after cleanup:', retryError);
					}
				}
				return false;
			}
		}

		// ======= ฟังก์ชัน Batch Loading ใหม่ =======
		async function loadDataWithBatchAPI() {
			try {
				showProgressiveStatus('📥 กำลังโหลดข้อมูลแบบ Batch...', 'info');
				
				// ตรวจสอบ cache batch ก่อน
				if (isCacheValid('batch')) {
					const batchData = getCachedData('batch');
					if (batchData && batchData.buildings && batchData.rooms) {
						console.log('💾 Using cached batch data');
						processBatchData(batchData);
						return true;
					}
				}
				
				// เรียก API แบบ batch
				const params = new URLSearchParams();
				params.append('action', 'getBatchData');
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				
				const result = await response.json();
				
				if (result.success && result.data) {
					console.log('✅ Batch data loaded successfully');
					
					// บันทึก cache
					setCachedData('batch', result.data);
					
					// ประมวลผลข้อมูล
					processBatchData(result.data);
					
					showProgressiveStatus('✅ โหลดข้อมูลสำเร็จ', 'success');
					return true;
				} else {
					throw new Error(result.error || 'Batch loading failed');
				}
				
			} catch (error) {
				console.error('❌ Batch loading failed:', error);
				showProgressiveStatus('❌ โหลดข้อมูลล้มเหลว', 'error');
				
				// ลองใช้ cache เก่า
				return loadFromFallbackCache();
			}
		}

		// V1.1 แก้ไขส่วนที่มีปัญหาใน processBatchData
		function processBatchData(batchData) {
			// ประมวลผล Buildings
			if (batchData.buildings && Array.isArray(batchData.buildings)) {
				const buildings = {};
				batchData.buildings.forEach(building => {
					if (building.code && building.name) {
						buildings[building.code] = {
							code: building.code,
							name: building.name,
							floors: parseInt(building.floors) || 1,
							year: parseInt(building.year) || new Date().getFullYear(),
							description: building.description || '',
							status: building.status || 'active',
							rooms: parseInt(building.rooms) || 0,
							created: building.created || '',
							updated: building.updated || ''
						};
					}
				});
				
				window.buildingsData = buildings;
				setCachedData('buildings', buildings);
				console.log(`📋 Processed ${Object.keys(buildings).length} buildings`);
			}
			
			// ประมวลผล Rooms
			if (batchData.rooms && Array.isArray(batchData.rooms)) {
				const rooms = {};
				batchData.rooms.forEach(room => {
					if (room.code && room.name) {
						// 🔧 v1.1 แก้ไข: จัดการ image_urls อย่างถูกต้อง
						let processedImages = [];
						if (room.image_urls) {
							if (Array.isArray(room.image_urls)) {
								processedImages = room.image_urls;
							} else if (typeof room.image_urls === 'string') {
								try {
									processedImages = JSON.parse(room.image_urls);
								} catch (e) {
									// ถ้าไม่ได้ ลองแยกด้วย comma
									processedImages = room.image_urls.split(',').map(url => url.trim()).filter(url => url);
								}
							}
						}
						
						rooms[room.code] = {
							code: room.code,
							name: room.name,
							building: room.building,
							floor: parseInt(room.floor) || 1,
							type: room.type || 'classroom',
							description: room.description || '',
							status: room.status || 'active',
							x: parseFloat(room.x) || 0,
							y: parseFloat(room.y) || 0,
							images: processedImages, // ใช้ข้อมูลที่ process แล้ว
							image_urls: processedImages, // เก็บไว้ทั้งสองชื่อเพื่อ compatibility
							created: room.created || '',
							updated: room.updated || ''
						};
					} 					
				});
				
		 
				window.roomsData = rooms;
				setCachedData('rooms', rooms);
				console.log(`📋 Processed ${Object.keys(rooms).length} rooms`);
				
				// สำหรับ index.html ใช้ roomData
				if (typeof window.roomData !== 'undefined') {
					window.roomData = rooms;
				}
				// สำหรับ admin.html ใช้ roomsData  
				if (typeof window.roomsData !== 'undefined') {
					window.roomsData = rooms;
				}
				
				setCachedData('rooms', rooms);
				console.log(`🏠 Processed ${Object.keys(rooms).length} rooms`);
			}
			
			// อัปเดท UI
			if (typeof updateDashboardStats === 'function') {
				updateDashboardStats();
			}
			if (typeof loadBuildingsTable === 'function') {
				loadBuildingsTable();
			}
			if (typeof loadRoomsTable === 'function') {
				loadRoomsTable();
			}
		}

		function loadFromFallbackCache() {
			console.log('🔄 Trying fallback cache...');
			
			let hasData = false;
			
			// ลองโหลด buildings จาก cache
			if (isCacheValid('buildings', 60 * 60 * 1000)) { // ยอมรับ cache เก่า 1 ชั่วโมง
				const buildings = getCachedData('buildings');
				if (buildings) {
					window.buildingsData = buildings;
					hasData = true;
					console.log('💾 Loaded buildings from fallback cache');
				}
			}
			
			// ลองโหลด rooms จาก cache
			if (isCacheValid('rooms', 60 * 60 * 1000)) { // ยอมรับ cache เก่า 1 ชั่วโมง
				const rooms = getCachedData('rooms');
				if (rooms) {
					if (typeof window.roomData !== 'undefined') {
						window.roomData = rooms;
					}
					if (typeof window.roomsData !== 'undefined') {
						window.roomsData = rooms;
					}
					hasData = true;
					console.log('💾 Loaded rooms from fallback cache');
				}
			}
			
			if (hasData) {
				showProgressiveStatus('💾 ใช้ข้อมูลจาก Cache', 'warning');
				
				// อัปเดท UI
				if (typeof updateDashboardStats === 'function') {
					updateDashboardStats();
				}
				if (typeof loadBuildingsTable === 'function') {
					loadBuildingsTable();
				}
				if (typeof loadRoomsTable === 'function') {
					loadRoomsTable();
				}
				
				return true;
			}
			
			return false;
		}

		// ======= ปรับปรุงฟังก์ชัน Auto Code Generation =======
		function generateBuildingCode() {
			const existingCodes = Object.keys(buildingsData || {});
			const codeNumbers = existingCodes
				.filter(code => /^B\d+$/.test(code))
				.map(code => parseInt(code.substring(1)))
				.filter(num => !isNaN(num));
			
			const nextNumber = codeNumbers.length > 0 ? Math.max(...codeNumbers) + 1 : 1;
			return `B${nextNumber.toString().padStart(3, '0')}`;
		}

		function generateRoomCode() {
			const rooms = window.roomsData || window.roomData || {};
			const existingCodes = Object.keys(rooms);
			const codeNumbers = existingCodes
				.filter(code => /^R\d+$/.test(code))
				.map(code => parseInt(code.substring(1)))
				.filter(num => !isNaN(num));
			
			const nextNumber = codeNumbers.length > 0 ? Math.max(...codeNumbers) + 1 : 1;
			return `R${nextNumber.toString().padStart(4, '0')}`;
		}

		// ======= Cache Cleanup =======
		function cleanOldCache() {
			console.log('🧹 Cleaning old cache...');
			
			const keys = Object.keys(localStorage);
			const now = Date.now();
			let cleanedCount = 0;
			
			keys.forEach(key => {
				if (key.includes('_timestamp_')) {
					const timestamp = localStorage.getItem(key);
					const dataType = key.replace('_timestamp_', '').replace('_live', '').replace('_demo', '');
					const config = CACHE_CONFIG[dataType];
					const maxAge = config ? config.maxAge * 2 : 60 * 60 * 1000; // 2x ปกติ หรือ 1 ชั่วโมง
					
					if (timestamp && (now - parseInt(timestamp)) > maxAge) {
						const cacheKey = key.replace('_timestamp_', '_cache_');
						localStorage.removeItem(key);
						localStorage.removeItem(cacheKey);
						cleanedCount++;
						console.log(`🗑️ Removed expired cache: ${dataType}`);
					}
				}
			});
			
			console.log(`🧹 Cleaned ${cleanedCount} expired cache entries`);
		}

		// ======= Background Sync =======
		async function intelligentBackgroundSync() {
			if (!sheetsConfig.connected) return;
			
			console.log('🔄 Starting intelligent background sync...');
			
			const syncNeeded = [];
			
			// ตรวจสอบว่า cache ไหนต้อง refresh
			Object.keys(CACHE_CONFIG).forEach(dataType => {
				if (!isCacheValid(dataType)) {
					syncNeeded.push({
						type: dataType,
						priority: CACHE_CONFIG[dataType].priority
					});
				}
			});
			
			if (syncNeeded.length === 0) {
				console.log('💾 All cache is still valid');
				return;
			}
			
			// เรียงลำดับตาม priority
			const priorities = { highest: 4, high: 3, medium: 2, low: 1 };
			syncNeeded.sort((a, b) => priorities[b.priority] - priorities[a.priority]);
			
			console.log(`🔄 Need to sync: ${syncNeeded.map(s => s.type).join(', ')}`);
			
			// ถ้ามี buildings หรือ rooms ให้ใช้ batch loading
			if (syncNeeded.some(s => s.type === 'buildings' || s.type === 'rooms')) {
				try {
					await loadDataWithBatchAPI();
					console.log('✅ Background batch sync completed');
				} catch (error) {
					console.error('❌ Background batch sync failed:', error);
				}
			}
			
			// Sync map images แยก (ถ้าจำเป็น)
			if (syncNeeded.some(s => s.type === 'mapImages')) {
				try {
					await backgroundSyncMapImages();
					console.log('✅ Background map sync completed');
				} catch (error) {
					console.error('❌ Background map sync failed:', error);
				}
			}
		}

		// ======= แทนที่ฟังก์ชัน loadDataFromSheets เดิม =======
		async function loadDataFromSheets() {
			if (!sheetsConfig.connected) {
				showNotification('❌ ยังไม่ได้เชื่อมต่อ Google Sheets', 'error');
				return false;
			}
			
			try {
				// ลองใช้ batch loading ก่อน
				const batchSuccess = await loadDataWithBatchAPI();
				if (batchSuccess) {
					updateLastSyncTime();
					addSyncHistoryItem('📥 โหลดข้อมูลแบบ Batch สำเร็จ', 'success');
					return true;
				}
				
				// ถ้า batch ไม่ได้ ให้ใช้วิธีเดิม
				return await loadDataLegacyMethod();
				
			} catch (error) {
				console.error('❌ All loading methods failed:', error);
				showNotification('❌ ไม่สามารถโหลดข้อมูลได้', 'error');
				return false;
			}
		}

		// ======= เริ่มใช้งาน Background Sync =======
		// ทำงานทุก 10 นาที
		setInterval(intelligentBackgroundSync, 10 * 60 * 1000);

		// ทำ cache cleanup ทุก 30 นาที
		setInterval(cleanOldCache, 30 * 60 * 1000);

		// เริ่มทำงานทันทีเมื่อโหลดเสร็จ
		setTimeout(intelligentBackgroundSync, 5000); // หลังจากโหลดระบบแล้ว 5 วินาที

		console.log('🚀 Smart Cache และ Batch Loading System พร้อมใช้งาน');
		console.log('📊 Cache Config:', CACHE_CONFIG);

		function getCachedData(dataType) {
			const cached = localStorage.getItem(getDataCacheKey(dataType));
			return cached ? JSON.parse(cached) : null;
		}
		
		// 1. ✅ ฟังก์ชัน connectToGoogleSheets
		async function connectToGoogleSheets() {
			try {
				if (!sheetsConfig.url) {
					console.log('⚠️ No Google Sheets URL configured');
					return false;
				}
				
				console.log('🔗 Attempting to connect to Google Sheets...');
				
				// ทดสอบการเชื่อมต่อ
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', 'Buildings');
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/x-www-form-urlencoded',
					},
					body: params.toString()
				});
				
				if (response.ok) {
					const data = await response.json();
					if (data.success !== false) {
						sheetsConfig.connected = true;
						console.log('✅ Connected to Google Sheets successfully');
						showProgressiveStatus('✅ เชื่อมต่อ Google Sheets สำเร็จ', 'success');
						return true;
					}
				}
				
				throw new Error(`Connection failed: ${response.status}`);
				
			} catch (error) {
				console.warn('⚠️ Google Sheets connection failed:', error.message);
				sheetsConfig.connected = false;
				showProgressiveStatus('⚠️ ไม่สามารถเชื่อมต่อ Google Sheets', 'warning');
				return false;
			}
		}		
		 

		// 4. ✅ ฟังก์ชัน loadFallbackData
		async function loadFallbackData() {
			console.log('🔄 Loading fallback data...');
			
			// ใช้ข้อมูลจำลองขั้นต่ำ
			roomData = {
				'R001': {
					code: 'R001',
					name: 'ห้องเรียน 1',
					building: 'B001',
					floor: 1,
					type: 'classroom',
					description: 'ห้องเรียนตัวอย่าง',
					status: 'active',
					x: 300,
					y: 200,
					images: []
				}
			};
			
			buildingsData = {
				'B001': {
					code: 'B001',
					name: 'อาคารเรียน 1',
					floors: 3,
					year: 2020,
					description: 'อาคารเรียนหลัก',
					status: 'active',
					rooms: 1
				}
			};
			
			// บันทึกใน localStorage
			setCachedData('rooms', roomData);
			setCachedData('buildings', buildingsData);
			
			// อัปเดท UI
			updateRoomMarkers();
			updateRouteControls(false);
			
			console.log('✅ Fallback data loaded');
		}	

		// 6. ✅ ฟังก์ชัน loadSystemConfig
		function loadSystemConfig() {
			try {
				const savedConfig = localStorage.getItem('systemConfig');
				if (savedConfig) {
					const config = JSON.parse(savedConfig);
					
					// อัปเดท UI elements
					const maintenanceCheckbox = document.getElementById('maintenanceMode');
					const maintenanceMessage = document.getElementById('maintenanceMessage');
					
					if (maintenanceCheckbox) {
						maintenanceCheckbox.checked = config.maintenance_mode === true;
					}
					
					if (maintenanceMessage) {
						maintenanceMessage.value = config.maintenance_message || 'เว็บไซต์อยู่ระหว่างการปรับปรุง กรุณากลับมาใหม่อีกครั้ง';
					}
					
					console.log('⚙️ System config loaded');
				}
			} catch (error) {
				console.error('Error loading system config:', error);
			}
		}

		console.log('✅ Admin.html functions restored');		
		
		async function loadSystemConfigFromSheets() {
			try {
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', sheetsConfig.systemConfigSheet);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.success && result.data && result.data.length > 0) {
						const config = result.data.find(item => item.id === 'system') || result.data[0];
						return {
							version: config.version || 'demo',
							maintenance_mode: config.maintenance_mode === 'true' || config.maintenance_mode === true,
							maintenance_message: config.maintenance_message || systemConfig.maintenance_message
						};
					}
				}
				
				return null;
				
			} catch (error) {
				console.error('Failed to load system config from sheets:', error);
				return null;
			}
		}

		// ===================  เพิ่มหน้า Under Construction  =====
		function showMaintenancePage() {
			console.log('🚧 Displaying maintenance page');
			document.body.innerHTML = `
				<div style="
					font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
					background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
					margin: 0;
					padding: 20px;
					display: flex;
					align-items: center;
					justify-content: center;
					min-height: 100vh;
					color: #333;
				">
					<div style="
						background: rgba(255, 255, 255, 0.95);
						backdrop-filter: blur(20px);
						padding: 50px;
						border-radius: 20px;
						text-align: center;
						max-width: 600px;
						box-shadow: 0 25px 50px rgba(0,0,0,0.3);
					">
						<div style="font-size: 80px; margin-bottom: 30px;">🚧</div>
						<h1 style="
							font-size: 2.5em;
							margin-bottom: 20px;
							background: linear-gradient(135deg, #667eea, #764ba2);
							-webkit-background-clip: text;
							-webkit-text-fill-color: transparent;
							background-clip: text;
						">Under Construction</h1>
						<p style="
							font-size: 1.2em;
							line-height: 1.6;
							color: #666;
							margin-bottom: 30px;
						">${systemConfig.maintenance_message}</p>
						<div style="
							background: rgba(102, 126, 234, 0.1);
							padding: 20px;
							border-radius: 15px;
							border-left: 4px solid #667eea;
						">
							<p style="margin: 0; font-size: 0.9em; color: #888;">
								<i class="fas fa-info-circle"></i>
								ระบบอยู่ระหว่างการปรับปรุงเพื่อให้บริการที่ดีขึ้น
							</p>
							<small style="color: #999; margin-top: 10px; display: block;">
							Version: ${currentVersion} | Mode: ${isMaintenanceMode ? 'Maintenance' : 'Normal'}
						</small>
						</div>
					</div>
				</div>
			`;
		}
        // FIX 1: Language translations
        const translations = {
            th: {
                search_title: "ค้นหาห้องเรียนและสถานที่",
                search_btn: "ค้นหา",
                category_classroom: "ห้องเรียน",
                category_classroom_desc: "ห้องเรียนปกติทั้งหมด",
                category_special: "ห้องพิเศษ",
                category_special_desc: "ห้องปฏิบัติการ",
                category_facilities: "สิ่งอำนวยความสะดวก",
                category_facilities_desc: "ห้องสมุด โรงอาหาร",
                category_office: "ห้องสำนักงาน",
                category_office_desc: "ห้องผู้บริหาร",
                map_title: "แผนที่โรงเรียน",
                filter_building: "🏢 กรองตามอาคาร",
                hide_controls: "ซ่อนปุ่ม",
                show_controls: "แสดงปุ่ม",
                floorplan: "แผนผัง",
                real_photo: "ภาพจริง",
                fullscreen: "เต็มจอ",
                exit_fullscreen: "ออกจากเต็มจอ",
                show_route: "แสดงเส้นทาง",
                clear_route: "ล้างเส้นทาง",
                voice_nav: "นำทางด้วยเสียง",
                about_title: "เกี่ยวกับระบบ",
                system_name: "ระบบแผนที่โรงเรียนอัจฉริยะ Version1.3",
                system_desc: "ระบบนำทางและค้นหาห้องเรียนที่ทันสมัย ออกแบบมาสำหรับการใช้งานบนมือถือเป็นหลัก พร้อมระบบนำทางด้วยเสียงและการแสดงเส้นทางอย่างชัดเจน",
                features_title: "ฟีเจอร์ใหม่ในเวอร์ชัน 1.3",
                usage_title: "วิธีการใช้งาน",
                step1_title: "1. ค้นหาห้อง:",
                step1_desc: "ใช้ช่องค้นหาหรือคลิกหมวดหมู่ด่วนเพื่อหาห้องที่ต้องการ",
                step2_title: "2. กำหนดจุดเริ่มต้น:",
                step2_desc: "คลิกที่แผนที่เพื่อกำหนดจุดเริ่มต้นการนำทาง",
                step3_title: "3. ดูเส้นทาง:",
                step3_desc: "เลือกห้องที่ต้องการไป คลิก \"แสดงเส้นทาง\" เพื่อดูเส้นทางและคำแนะนำ",
                step4_title: "4. นำทางด้วยเสียง:",
                step4_desc: "เปิดเสียงเพื่อฟังคำแนะนำการเดินทางแบบขั้นตอน",
                nav_search: "ค้นหา",
                nav_map: "แผนที่",
                nav_about: "เกี่ยวกับ",
                nav_admin: "จัดการ",
				nav_Present: "อธิบายระบบ",
                info_building: "อาคาร",
                info_floor: "ชั้น",
                info_type: "ประเภทห้อง",
                info_description: "รายละเอียด",
                room_images: "รูปภาพห้อง",
                route_navigation: "เส้นทางนำทาง",
                voice: "เสียง",
                view_details: "ดูรายละเอียดห้อง",
                show_route_direct: "แสดงเส้นทาง",
                select_action: "เลือกการดำเนินการ",
				whats_new: "มีอะไรใหม่ในเวอร์ชัน 6",
				feature1_title: "การนำทางที่แม่นยำ",
				feature1_desc: "กำหนดจุดเริ่มต้นได้ทุกตำแหน่งบนแผนที่ พร้อมเส้นทางที่ชัดเจน",
				feature2_title: "นำทางด้วยเสียง",
				feature2_desc: "ระบบอ่านคำแนะนำการเดินทางแบบขั้นตอน รองรับภาษาไทยและอังกฤษ",
				feature3_title: "Mobile First",
				feature3_desc: "ออกแบบเพื่อมือถือเป็นหลัก ใช้งานง่าย UI ที่สวยงามและทันสมัย",
				new1_title: "จุดเริ่มต้นแบบ Custom",
				new1_desc: "กำหนดจุดเริ่มต้นได้ทุกตำแหน่งบนแผนที่ตามต้องการ",
				new2_title: "เส้นทางที่ชัดเจน",
				new2_desc: "แสดงเส้นทางแบบเชื่อมจุดต่อจุดพร้อมแอนิเมชัน",
				new3_title: "ประสิทธิภาพสูง",
				new3_desc: "โหลดเร็วขึ้น ใช้หน่วยความจำน้อยลง รองรับข้อมูลจำนวนมาก",
				how_to_use: "วิธีการใช้งาน",
				tech_info: "ข้อมูลทางเทคนิค",
				web_tech: "เทคโนโลยีเว็บ",
				data_source: "แหล่งข้อมูล",
				voice_tech: "เทคโนโลยีเสียง",
				responsive: "Responsive Design", 
				show_usage_guide: "แสดงวิธีการใช้งาน",
				hide_usage_guide: "ซ่อนวิธีการใช้งาน",
				usage_guide_title: "วิธีการใช้งานแผนที่",
				step1: "ขั้นตอนที่ 1: ค้นหาห้อง",
				step1_desc: "ไปหน้าค้นหา เลือกห้องที่ต้องการ หรือคลิกหมวดหมู่ด่วน",
				step2: "ขั้นตอนที่ 2: กำหนดจุดเริ่มต้น", 
				step2_desc: "คลิกที่แผนที่เพื่อกำหนดตำแหน่งที่คุณอยู่",
				step3: "ขั้นตอนที่ 3: ดูเส้นทาง",
				step3_desc: "คลิก \"แสดงเส้นทาง\" เพื่อดูการนำทางแบบ step by step"			
				
            },
            en: {
                search_title: "Search Classrooms and Places",
                search_btn: "Search",
                category_classroom: "Classrooms",
                category_classroom_desc: "All regular classrooms",
                category_special: "Special Rooms",
                category_special_desc: "Laboratories",
                category_facilities: "Facilities",
                category_facilities_desc: "Library, Cafeteria",
                category_office: "Offices",
                category_office_desc: "Administrative offices",
                map_title: "School Map",
                filter_building: "🏢 Filter by Building",
                hide_controls: "Hide Controls",
                show_controls: "Show Controls",
                floorplan: "Floor Plan",
                real_photo: "Real Photo",
                fullscreen: "Fullscreen",
                exit_fullscreen: "Exit Fullscreen",
                show_route: "Show Route",
                clear_route: "Clear Route",
                voice_nav: "Voice Navigation",
                about_title: "About System",
                system_name: "Smart School Map System Version1.3",
                system_desc: "Modern classroom search and navigation system designed primarily for mobile use with voice navigation and clear route display.",
                features_title: "New Features in version1.3",
                usage_title: "How to Use",
                step1_title: "1. Search Rooms:",
                step1_desc: "Use search box or click quick categories to find desired rooms",
                step2_title: "2. Set Starting Point:",
                step2_desc: "Click on the map to set navigation starting point",
                step3_title: "3. View Route:",
                step3_desc: "Select destination room, click \"Show Route\" to see path and directions",
                step4_title: "4. Voice Navigation:",
                step4_desc: "Enable sound to hear step-by-step navigation instructions",
                nav_search: "Search",
                nav_map: "Map",
                nav_about: "About",
                nav_admin: "Admin",
				nav_Present: "อธิบายระบบ",
                info_building: "Building",
                info_floor: "Floor",
                info_type: "Room Type",
                info_description: "Description",
                room_images: "Room Images",
                route_navigation: "Route Navigation",
                voice: "Voice",
                view_details: "View Room Details",
                show_route_direct: "Show Route",
                select_action: "Select Action",
				whats_new: "What's New in Version 6",
				feature1_title: "Precise Navigation",
				feature1_desc: "Set starting point anywhere on the map with clear route guidance",
				feature2_title: "Voice Navigation",
				feature2_desc: "Step-by-step audio directions supporting Thai and English languages",
				feature3_title: "Mobile First",
				feature3_desc: "Designed for mobile devices with beautiful and modern UI",
				new1_title: "Custom Starting Point",
				new1_desc: "Set starting point anywhere on the map as desired",
				new2_title: "Clear Route Display",
				new2_desc: "Point-to-point route visualization with animations",
				new3_title: "High Performance",
				new3_desc: "Faster loading, lower memory usage, supports large datasets",
				how_to_use: "How to Use",
				tech_info: "Technical Information",
				web_tech: "Web Technology",
				data_source: "Data Source",
				voice_tech: "Voice Technology",
				responsive: "Responsive Design",
				show_usage_guide: "Show Usage Guide",
				hide_usage_guide: "Hide Usage Guide", 
				usage_guide_title: "Map Usage Guide",
				step1: "Step 1: Search Room",
				step1_desc: "Go to search page, select desired room or click quick categories",
				step2: "Step 2: Set Starting Point",
				step2_desc: "Click on map to set your current position",
				step3: "Step 3: View Route", 
				step3_desc: "Click \"Show Route\" to see step-by-step navigation"
            }
        };

        // =================== Sample Data ===================
        const sampleRoomData = {
            'R001': {
                code: 'R001',
                name: 'ห้องเรียน ม.1/1',
                building: 'B001',
                location: 'ชั้น 1',
                description: 'ห้องเรียนปกติสำหรับนักเรียนชั้นมัธยมศึกษาปีที่ 1',
                hours: '08:00 - 16:30',
                status: 'active',
                x: 20, y: 30,
                images: ['https://picsum.photos/400/300?random=1']
            },
            'R002': {
                code: 'R002',
                name: 'ห้องเรียน ม.1/2',
                building: 'B001',
                location: 'ชั้น 1',
                description: 'ห้องเรียนปกติสำหรับนักเรียนชั้นมัธยมศึกษาปีที่ 1',
                hours: '08:00 - 16:30',
                status: 'active',
                x: 45, y: 30,
                images: ['https://picsum.photos/400/300?random=2']
            },
            'C001': {
                code: 'C001',
                name: 'ห้องคอมพิวเตอร์ 1',
                building: 'B002',
                location: 'ชั้น 2',
                description: 'ห้องปฏิบัติการคอมพิวเตอร์ มีเครื่องคอมพิวเตอร์ 30 เครื่อง',
                hours: '08:00 - 17:00',
                status: 'active',
                x: 25, y: 65,
                images: ['https://picsum.photos/400/300?random=3']
            },
            'L001': {
                code: 'L001',
                name: 'ห้องสมุดหลัก',
                building: 'B003',
                location: 'ชั้น 1',
                description: 'ห้องสมุดหลักของโรงเรียน มีหนังสือมากกว่า 15,000 เล่ม',
                hours: '07:30 - 18:00',
                status: 'active',
                x: 80, y: 70,
                images: ['https://picsum.photos/400/300?random=4']
            },
            'CAFE001': {
                code: 'CAFE001',
                name: 'โรงอาหารหลัก',
                building: 'B004',
                location: 'ชั้น 1',
                description: 'โรงอาหารหลักของโรงเรียน รองรับนักเรียน 500 คน',
                hours: '06:30 - 14:00',
                status: 'active',
                x: 85, y: 40,
                images: ['https://picsum.photos/400/300?random=5']
            }
        };

        const sampleBuildingsData = {
            'B001': { code: 'B001', name: 'อาคารเรียน 1' },
            'B002': { code: 'B002', name: 'อาคารเรียน 2' },
            'B003': { code: 'B003', name: 'อาคารสำนักงาน' },
            'B004': { code: 'B004', name: 'อาคารสิ่งอำนวยความสะดวก' }
        };

        // =================== FIX 1: Language System ===================
        
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'th' ? 'en' : 'th';
            localStorage.setItem('preferredLanguage', currentLanguage);
            updateLanguageButton();
            updateAllTranslations();
            updateSearchPlaceholder();
            showNotification(
                currentLanguage === 'th' ? '🇹🇭 เปลี่ยนเป็นภาษาไทย' : '🇺🇸 Changed to English',
                'success'
            );
        }

        function updateLanguageButton() {
            const languageText = document.getElementById('languageText');
            if (languageText) {
                languageText.textContent = currentLanguage === 'th' ? 'TH' : 'EN';
            }
        }

        function updateAllTranslations() {
            const elementsToTranslate = document.querySelectorAll('[data-translate]');
            elementsToTranslate.forEach(element => {
                const key = element.getAttribute('data-translate');
                if (translations[currentLanguage] && translations[currentLanguage][key]) {
                    if (element.tagName === 'UL' && key === 'features_list') {
                        // Special handling for features list
                        if (currentLanguage === 'en') {
                            element.innerHTML = `
                                <li>🎯 Set starting point anywhere on the map</li>
                                <li>🛣️ Clear point-to-point route display</li>
                                <li>📱 Mobile-optimized UI</li>
                                <li>🔊 Detailed voice navigation system</li>
                                <li>⚡ Better performance and lower memory usage</li>
                            `;
                        } else {
                            element.innerHTML = `
                                <li>🎯 กำหนดจุดเริ่มต้นได้ทุกตำแหน่งบนแผนที่</li>
                                <li>🛣️ แสดงเส้นทางแบบเชื่อมจุดต่อจุดอย่างชัดเจน</li>
                                <li>📱 UI ที่ปรับปรุงใหม่เหมาะกับมือถือ</li>
                                <li>🔊 ระบบนำทางด้วยเสียงที่ละเอียด</li>
                                <li>⚡ ประสิทธิภาพที่เร็วขึ้นและใช้หน่วยความจำน้อยลง</li>
                            `;
                        }
                    } else {
                        element.textContent = translations[currentLanguage][key];
                    }
                }
            });
            
            // Update title and subtitle
            const systemTitle = document.getElementById('systemTitle');
            const systemSubtitle = document.getElementById('systemSubtitle');
            
            if (currentLanguage === 'en') {
                if (systemTitle) systemTitle.textContent = '🏫 Smart School Map System';
                if (systemSubtitle) systemSubtitle.textContent = 'Find classrooms and navigate with voice guidance';
            } else {
                if (systemTitle) systemTitle.textContent = '🏫 ระบบแผนที่โรงเรียนอัจฉริยะ';
                if (systemSubtitle) systemSubtitle.textContent = 'ค้นหาห้องเรียนและสถานที่ต่างๆ พร้อมระบบนำทางด้วยเสียง';
            }
        }

        function updateSearchPlaceholder() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                const placeholder = currentLanguage === 'th' 
                    ? searchInput.getAttribute('data-placeholder-th')
                    : searchInput.getAttribute('data-placeholder-en');
                searchInput.placeholder = placeholder;
            }
        }


		// ======= localStorage Quota Management =======
		function getStorageQuota() {
			try {
				// ทดสอบ localStorage quota
				const testKey = 'storage_test_' + Date.now();
				const testData = 'x'.repeat(1024); // 1KB test
				localStorage.setItem(testKey, testData);
				localStorage.removeItem(testKey);
				return true;
			} catch (e) {
				return false;
			}
		}

		function getStorageSize() {
			let total = 0;
			for (let key in localStorage) {
				if (localStorage.hasOwnProperty(key)) {
					total += localStorage[key].length + key.length;
				}
			}
			return total;
		}

		function freeUpStorage(targetSize = 50000) { // 50KB
			const keys = Object.keys(localStorage);
			const cacheKeys = keys.filter(key => key.includes('_cache_') || key.includes('_timestamp_'));
			
			// ลบ cache เก่าตามลำดับเวลา
			cacheKeys.sort((a, b) => {
				const timeA = localStorage.getItem(a.replace('_cache_', '_timestamp_').replace('_timestamp_', '_timestamp_'));
				const timeB = localStorage.getItem(b.replace('_cache_', '_timestamp_').replace('_timestamp_', '_timestamp_'));
				return parseInt(timeA || '0') - parseInt(timeB || '0');
			});
			
			let freed = 0;
			for (const key of cacheKeys) {
				if (freed >= targetSize) break;
				const size = localStorage[key]?.length || 0;
				localStorage.removeItem(key);
				freed += size;
				console.log(`🗑️ Removed cache: ${key} (${size} bytes)`);
			}
			
			return freed;
		}

		// ======= แก้ไข: ปรับปรุง Cache Management สำหรับข้อมูลขนาดใหญ่ =======
		function safeSetCachedData(dataType, data) {
			try {
				const dataString = JSON.stringify(data);
				const dataSize = dataString.length;
				
				// แก้ไข: เพิ่มขีดจำกัดสำหรับข้อมูลประเภทต่างๆ
				const sizeLimit = {
					'mapImages': 2000000,    // 2MB สำหรับรูปภาพแผนที่
					'rooms': 1000000,       // 1MB สำหรับข้อมูลห้อง
					'buildings': 500000,    // 500KB สำหรับข้อมูลอาคาร
					'default': 500000       // 500KB สำหรับข้อมูลอื่นๆ
				};
				
				const maxSize = sizeLimit[dataType] || sizeLimit['default'];
				
				// ตรวจสอบขนาดข้อมูล
				if (dataSize > maxSize) {
					console.warn(`⚠️ Data too large for cache: ${dataType} (${dataSize} bytes) > limit (${maxSize} bytes)`);
					
					// แก้ไข: สำหรับ mapImages ให้บีบอัดหรือแบ่งเก็บ
					if (dataType === 'mapImages') {
						return compressAndCacheMapImages(data);
					}
					
					return false;
				}
				
				// ทดสอบพื้นที่ว่าง
				if (!getStorageQuota()) {
					console.log('💾 Storage quota low, freeing up space...');
					freeUpStorage(dataSize + 100000); // เพิ่ม buffer 100KB
				}
				
				localStorage.setItem(getDataCacheKey(dataType), dataString);
				localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
				
				console.log(`✅ Cached ${dataType}: ${(dataSize/1024).toFixed(1)}KB`);
				return true;
				
			} catch (error) {
				if (error.name === 'QuotaExceededError') {
					console.warn('🚨 Storage quota exceeded, attempting cleanup...');
					freeUpStorage(200000); // ล้าง 200KB
					
					try {
						// ลองอีกครั้งหลังล้าง
						localStorage.setItem(getDataCacheKey(dataType), JSON.stringify(data));
						localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
						console.log(`✅ Cached ${dataType} after cleanup`);
						return true;
					} catch (retryError) {
						console.error(`❌ Failed to cache ${dataType} even after cleanup:`, retryError);
						return false;
					}
				} else {
					console.error(`❌ Cache error for ${dataType}:`, error);
					return false;
				}
			}
		}
		
		// ======= เพิ่ม: ฟังก์ชันบีบอัดข้อมูลแผนที่ =======
		function compressAndCacheMapImages(mapData) {
			try {
				// บีบอัดรูปภาพ base64 โดยเก็บเฉพาะ metadata และ URL สั้นๆ
				const compressedData = {
					floorplan: mapData.floorplan ? 'compressed_floorplan' : null,
					realphoto: mapData.realphoto ? 'compressed_realphoto' : null,
					notes: mapData.notes || '',
					loaded: mapData.loaded || false,
					compressed: true,
					originalSizes: {
						floorplan: mapData.floorplan ? mapData.floorplan.length : 0,
						realphoto: mapData.realphoto ? mapData.realphoto.length : 0
					}
				};
				
				// เก็บรูปจริงใน session storage ชั่วคราว
				if (mapData.floorplan) {
					try {
						sessionStorage.setItem('temp_floorplan', mapData.floorplan);
					} catch (e) {
						console.warn('Cannot store floorplan in session storage');
					}
				}
				
				if (mapData.realphoto) {
					try {
						sessionStorage.setItem('temp_realphoto', mapData.realphoto);
					} catch (e) {
						console.warn('Cannot store realphoto in session storage');
					}
				}
				
				// เก็บข้อมูลที่บีบอัดแล้ว
				const compressedString = JSON.stringify(compressedData);
				localStorage.setItem(getDataCacheKey('mapImages'), compressedString);
				localStorage.setItem(getDataTimestampKey('mapImages'), Date.now().toString());
				
				console.log(`🗜️ Map images compressed and cached: ${(compressedString.length/1024).toFixed(1)}KB`);
				return true;
				
			} catch (error) {
				console.error('❌ Failed to compress map images:', error);
				return false;
			}
		}

      // ======= Progressive Data Loading สำหรับ Live Mode =======
			async function loadRoomDataFromAdmin() {
				try {
					console.log('🔄 Loading room data for version:', currentVersion);
					await progressiveLoadLiveData();
					 
					// โหลด buildings data
					await loadBuildingsData();
					
					//updateGlobalVersionIndicator(currentVersion);
					showDataSourceStatus();
					
				} catch (error) {
					console.error('❌ Error loading room data:', error);
					// Fallback to cached or sample data
					roomData = getCachedData('rooms') || { ...sampleRoomData };
					showNotification('⚠️ ใช้ข้อมูลสำรอง', 'warning');
				}
			}
			

			async function progressiveLoadLiveData() {
				// ตรวจสอบ cache ก่อน
				if (isCacheValid('rooms', 10 * 60 * 1000)) { // 10 นาที
					roomData = getCachedData('rooms') || {};
					console.log('💾 Using cached rooms:', Object.keys(roomData).length, 'rooms');
					showProgressiveStatus('🏃‍♂️ ใช้ข้อมูลจาก Cache', 'success');
					return;
				}
				
				// แสดงสถานะแทนการ Loading Overlay
				showProgressiveStatus('🌐 กำลังโหลดข้อมูลจาก Google Sheets...', 'info');
				
				try {
					// โหลดข้อมูลจาก Google Sheets
					const sheetsData = await loadRoomsFromSheets();
					
					if (sheetsData && Object.keys(sheetsData).length > 0) {
						roomData = sheetsData;
						
						// บันทึก cache แบบปลอดภัย
						const cacheSuccess = safeSetCachedData('rooms', roomData);
						
						console.log('✅ Loaded rooms from Google Sheets:', Object.keys(roomData).length, 'rooms');
						showProgressiveStatus(`✅ โหลดข้อมูลสำเร็จ ${Object.keys(roomData).length} ห้อง`, 'success');
						
						if (!cacheSuccess) {
							showProgressiveStatus('⚠️ ไม่สามารถบันทึก Cache ได้', 'warning');
						}
					} else {
						// Fallback to cache or sample
						roomData = getCachedData('rooms') || { ...sampleRoomData };
						console.log('📱 Using fallback data:', Object.keys(roomData).length, 'rooms');
						showProgressiveStatus('📱 ใช้ข้อมูลสำรอง', 'warning');
					}
					
				} catch (error) {
					console.error('❌ Failed to load from sheets:', error);
					roomData = getCachedData('rooms') || { ...sampleRoomData };
					showProgressiveStatus('❌ โหลดล้มเหลว ใช้ข้อมูลสำรอง', 'error');
				}
			}

			function showProgressiveStatus(message, type = 'info') {
				// แสดงสถานะแบบไม่บดบัง UI
				showNotification(message, type);
				
				// อัปเดต version indicator ด้วยสถานะ
				/*
				const indicator = document.getElementById('globalVersionIndicator');
				if (indicator && currentVersion === 'live') {
					if (type === 'info') {
						indicator.innerHTML = '⏳ LOADING...';
						indicator.className = 'status-indicator status-error';
					} else if (type === 'success') {
						indicator.innerHTML = '🔴 LIVE';
						indicator.className = 'status-indicator status-active';
					} else if (type === 'warning' || type === 'error') {
						indicator.innerHTML = '⚠️ ISSUES';
						indicator.className = 'status-indicator status-error';
					}
				}
				*/
			}
			
 
			// ฟังก์ชันโหลด Buildings Data
			 
			async function loadBuildingsData() {
				try {
					if (currentVersion === 'demo') {
						if (isCacheValid('buildings')) {
							buildingsData = getCachedData('buildings') || { ...sampleBuildingsData };
						} else {
							const savedBuildings = localStorage.getItem('buildingsData');
							if (savedBuildings) {
								buildingsData = JSON.parse(savedBuildings);
								setCachedData('buildings', buildingsData);
							} else {
								buildingsData = { ...sampleBuildingsData };
								setCachedData('buildings', buildingsData);
							}
						}
					} else if (currentVersion === 'live') {
						if (isCacheValid('buildings')) {
							buildingsData = getCachedData('buildings') || {};
							console.log('💾 Loaded buildings from cache:', Object.keys(buildingsData).length, 'buildings');
						} else {
							const sheetsBuildings = await loadBuildingsFromSheets();
							if (sheetsBuildings && Object.keys(sheetsBuildings).length > 0) {
								buildingsData = sheetsBuildings;
								setCachedData('buildings', buildingsData);
								console.log('✅ Loaded buildings from Google Sheets:', Object.keys(buildingsData).length, 'buildings');
							} else {
								buildingsData = getCachedData('buildings') || { ...sampleBuildingsData };
							}
						}
					}
				} catch (error) {
					console.error('❌ Error loading buildings data:', error);
					buildingsData = getCachedData('buildings') || { ...sampleBuildingsData };
				}
			}

			
			
			// ======= แก้ไข: ปรับปรุงการโหลดจาก Google Sheets =======
			async function loadRoomsFromSheets() {
				try {
					console.log('🔄 Loading rooms from Google Sheets...');
					
					// แก้ไข: เพิ่ม timeout และปรับการจัดการ error
					const controller = new AbortController();
					const timeoutId = setTimeout(() => {
						controller.abort();
						console.log('⏰ Request timeout - aborting rooms loading');
					}, 15000); // เพิ่มเป็น 15 วินาที
					
					const params = new URLSearchParams();
					params.append('action', 'getData');
					params.append('sheet', sheetsConfig.roomsSheet);
					
					const response = await fetch(sheetsConfig.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: params.toString(),
						signal: controller.signal
					});
					
					clearTimeout(timeoutId);
					
					if (!response.ok) {
						throw new Error(`HTTP ${response.status}: ${response.statusText}`);
					}
					
					const result = await response.json();
					console.log('📊 Rooms API response received');
					
					if (result.success && result.data && result.data.length > 0) {
						const rooms = {};
						
						// แก้ไข: ปรับ batch size ให้เล็กลงเพื่อป้องกัน blocking
						const batchSize = 5; // ลดจาก 10 เป็น 5
						let processedCount = 0;
						
						for (let i = 0; i < result.data.length; i += batchSize) {
							const batch = result.data.slice(i, i + batchSize);
							
							batch.forEach(row => {
								if (row.code && row.name) {
									rooms[row.code] = {
										code: row.code,
										name: row.name,
										building: row.building || '',
										location: row.location || row.floor || '',
										floor: parseInt(row.floor) || 1,
										type: row.type || 'classroom',
										description: row.description || '',
										hours: row.hours || '08:00 - 16:30',
										status: row.status || 'active',
										x: parseFloat(row.x) || 50,
										y: parseFloat(row.y) || 50,
										images: row.image_urls ? (Array.isArray(row.image_urls) ? row.image_urls : [row.image_urls]) : []
									};
									processedCount++;
								}
							});
							
							// แก้ไข: แสดงความคืบหน้า
							if (i % (batchSize * 4) === 0) { // ทุก 20 รายการ
								console.log(`📊 Processing rooms: ${processedCount}/${result.data.length}`);
								showProgressiveStatus(`📊 โหลดข้อมูลห้อง: ${processedCount}/${result.data.length}`, 'info');
							}
							
							// ให้ browser มีเวลาประมวลผล UI
							if (i + batchSize < result.data.length) {
								await new Promise(resolve => setTimeout(resolve, 20)); // เพิ่มเป็น 20ms
							}
						}
						
						console.log(`✅ Rooms processed successfully: ${Object.keys(rooms).length} rooms`);
						return rooms;
					}
					
					console.warn('⚠️ No room data received from sheets');
					return null;
					
				} catch (error) {
					if (error.name === 'AbortError') {
						console.error('⏰ Request timeout loading rooms from sheets');
						showProgressiveStatus('⏰ โหลดข้อมูลห้องใช้เวลานานเกินไป', 'warning');
					} else {
						console.error('❌ Failed to load rooms from sheets:', error);
						showProgressiveStatus(`❌ โหลดข้อมูลห้องล้มเหลว: ${error.message}`, 'error');
					}
					return null;
				}
			}
			
		 
			async function loadBuildingsFromSheets() {
				try {
					console.log('🔄 Loading buildings from Google Sheets...');
					
					const controller = new AbortController();
					const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 วินาที timeout
					
					const params = new URLSearchParams();
					params.append('action', 'getData');
					params.append('sheet', sheetsConfig.buildingsSheet);
					
					const response = await fetch(sheetsConfig.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: params.toString(),
						signal: controller.signal
					});
					
					clearTimeout(timeoutId);
					
					if (!response.ok) {
						throw new Error(`HTTP ${response.status}: ${response.statusText}`);
					}
					
					const result = await response.json();
					console.log('📊 Buildings API response received');
					
					if (result.success && result.data && result.data.length > 0) {
						const buildings = {};
						result.data.forEach(row => {
							if (row.code && row.name) {
								buildings[row.code] = {
									code: row.code,
									name: row.name,
									floors: parseInt(row.floors) || 1,
									year: parseInt(row.year) || new Date().getFullYear(),
									description: row.description || '',
									status: row.status || 'active'
								};
							}
						});
						
						console.log('✅ Buildings loaded successfully:', Object.keys(buildings).length, 'buildings');
						return buildings;
					}
					
					console.warn('⚠️ No building data received from sheets');
					return null;
					
				} catch (error) {
					if (error.name === 'AbortError') {
						console.error('⏰ Request timeout loading buildings from sheets');
					} else {
						console.error('❌ Failed to load buildings from sheets:', error);
					}
					return null;
				}
			}	

		// ======= Intelligent Cache Management =======
		function intelligentCacheManagement() {
			const maxCacheAge = {
				rooms: 15 * 60 * 1000,     // 15 นาที
				buildings: 30 * 60 * 1000,  // 30 นาที
				system: 60 * 60 * 1000      // 1 ชั่วโมง
			};
			
			const now = Date.now();
			const keys = Object.keys(localStorage);
			
			keys.forEach(key => {
				if (key.includes('_timestamp_')) {
					const dataType = key.replace('_timestamp_', '').replace('_live', '').replace('_demo', '');
					const timestamp = localStorage.getItem(key);
					const maxAge = maxCacheAge[dataType] || 15 * 60 * 1000; // default 15 minutes
					
					if (timestamp && (now - parseInt(timestamp)) > maxAge) {
						const cacheKey = key.replace('_timestamp_', '_cache_');
						localStorage.removeItem(key);
						localStorage.removeItem(cacheKey);
						console.log(`🗑️ Expired cache removed: ${dataType}`);
					}
				}
			});
		}
		
		// ======= Connection Quality Detection =======
		let connectionQuality = 'unknown';
		let lastLatency = 0;

		async function detectConnectionQuality() {
			try {
				const start = performance.now();
				
				// ทดสอบความเร็วด้วย HEAD request เล็ก ๆ
				const response = await fetch(sheetsConfig.url, {
					method: 'HEAD',
					cache: 'no-cache'
				});
				
				const end = performance.now();
				lastLatency = end - start;
				
				if (lastLatency < 500) {
					connectionQuality = 'fast';
				} else if (lastLatency < 2000) {
					connectionQuality = 'medium';
				} else {
					connectionQuality = 'slow';
				}
				
				console.log(`📶 Connection quality: ${connectionQuality} (${Math.round(lastLatency)}ms)`);
				
				// ปรับ cache time ตามความเร็วเน็ต
				if (connectionQuality === 'slow') {
					// เน็ตช้า = cache นานขึ้น
					maxCacheAge.rooms = 30 * 60 * 1000;    // 30 นาที
					maxCacheAge.buildings = 60 * 60 * 1000; // 1 ชั่วโมง
				}
				
			} catch (error) {
				connectionQuality = 'offline';
				console.log('📶 Connection: offline or error');
			}
		}
		
		// ตรวจสอบ connection quality ทุก 2 นาที
		//setInterval(detectConnectionQuality, 2 * 60 * 1000);


		// ======= ปรับปรุง Background Sync เดิมให้รวมแผนที่ =======
		async function backgroundSync() {
			if (currentVersion !== 'live' || connectionQuality === 'offline') {
				return;
			}
			
			console.log('🔄 Background sync started...');
			
			try {
				// Sync ข้อมูลห้อง
				if (!isCacheValid('rooms')) {
					const rooms = await loadRoomsFromSheets();
					if (rooms) {
						roomData = { ...roomData, ...rooms };
						safeSetCachedData('rooms', roomData);
						console.log('🔄 Background sync: rooms updated');
					}
				}
				
				// รอ 2 วินาทีก่อน sync ต่อ
				await new Promise(resolve => setTimeout(resolve, 2000));
				
				// Sync ข้อมูลอาคาร
				if (!isCacheValid('buildings')) {
					const buildings = await loadBuildingsFromSheets();
					if (buildings) {
						buildingsData = { ...buildingsData, ...buildings };
						safeSetCachedData('buildings', buildingsData);
						console.log('🔄 Background sync: buildings updated');
					}
				}
				
				// รอ 2 วินาทีก่อน sync ต่อ
				await new Promise(resolve => setTimeout(resolve, 2000));
				
				// ⭐ เพิ่มส่วนนี้ - Sync ภาพแผนที่
				await backgroundSyncMapImages();
				
			} catch (error) {
				console.log('🔄 Background sync encountered issues:', error.message);
			}
		}
		// ======= เพิ่มคำสั่ง Debug สำหรับ Console =======

		window.debugMapImages = debugMapImages;
		window.retryLoadMapImages = retryLoadMapImages;
		


		// ======= เพิ่มการตรวจสอบสถานะแผนที่ =======
		function getMapStatus() {
			return {
				version: currentVersion,
				layout: currentMapLayout,
				hasFloorplan: !!mapData.floorplan,
				hasRealPhoto: !!mapData.realphoto,
				loaded: mapData.loaded,
				cacheValid: isCacheValid('mapImages'),
				sheetsConnected: sheetsConfig.connected
			};
		}

		window.getMapStatus = getMapStatus;

		// ======= แสดงข้อมูล Map Status ใน Console =======
		console.log('🗺️ Map Images System Ready');
		console.log('📋 Available commands:');
		console.log('  - debugMapImages() - แสดงข้อมูล debug');
		console.log('  - getMapStatus() - ตรวจสอบสถานะ');
		console.log('  - retryLoadMapImages() - ลองโหลดใหม่');
		
		 

		// ความสะอาดและประสิทธิภาพ
		setInterval(intelligentCacheManagement, 5 * 60 * 1000); // ทุก 5 นาที


		function showDataSourceStatus() {
			const roomCount = Object.keys(roomData).length;
			const buildingCount = Object.keys(buildingsData).length;
			
			let statusMessage = '';
			if (currentVersion === 'demo') {
				statusMessage = `🎮 Demo Mode: ${roomCount} ห้อง, ${buildingCount} อาคาร`;
			} else {
				const cacheStatus = isCacheValid('rooms') ? '(จาก Cache)' : '(ข้อมูลใหม่)';
				statusMessage = `🔴 Live Mode: ${roomCount} ห้อง, ${buildingCount} อาคาร ${cacheStatus}`;
			}
			
			setTimeout(() => {
				showNotification(statusMessage, 'info');
			}, 1000);
		}

        // =================== FIX 5: Building Filter System ===================
        /* / ======= ลบ Building Filter Functions =======
		async function extractBuildingsList() {
				// โหลด buildings data ถ้าเป็น live mode
				if (adminDataVersion === 'live') {
					const sheetsBuildings = await loadBuildingsFromSheets();
					if (sheetsBuildings) {
						console.log('✅ Loaded buildings from Google Sheets:', Object.keys(sheetsBuildings).length, 'buildings');
					}
				}
				
				const buildings = new Set();
				Object.values(roomData).forEach(room => {
					if (room.building) {
						buildings.add(room.building);
					}
				});
				buildingsList = Array.from(buildings).sort();
				updateBuildingFilter();
			}

         function updateBuildingFilter() {
			const container = document.getElementById('buildingButtons');
			if (!container) return;
			
			const allText = currentLanguage === 'th' ? 'ทั้งหมด' : 'All';
			
			container.innerHTML = `
				<button class="building-btn ${currentBuildingFilter === 'all' ? 'active' : ''}" 
						onclick="filterByBuilding('all')">
					${allText}
				</button>
				${buildingsList.map(building => {
					// ใช้ buildingsData แทน localStorage
					const buildingName = buildingsData[building]?.name || building;
					
					return `
						<button class="building-btn ${currentBuildingFilter === building ? 'active' : ''}" 
								onclick="filterByBuilding('${building}')">
							${buildingName}
						</button>
					`;
				}).join('')}
			`;
			
			console.log('🏢 Building filter updated:', buildingsList.length, 'buildings');
		}

        function filterByBuilding(building) {
            currentBuildingFilter = building;
            updateBuildingFilter();
            updateRoomMarkers();
            
            const message = building === 'all' 
                ? (currentLanguage === 'th' ? '🏢 แสดงห้องทั้งหมด' : '🏢 Showing all rooms')
                : (currentLanguage === 'th' ? `🏢 กรองอาคาร: ${building}` : `🏢 Filtered: ${building}`);
            
            showNotification(message, 'info');
        }
		*/

        // =================== Utility Functions ===================
        
        function getRoomIcon(roomName) {
            const lowerName = roomName.toLowerCase();
            if (lowerName.includes('computer') || lowerName.includes('คอมพิวเตอร์')) return '💻';
            if (lowerName.includes('library') || lowerName.includes('สมุด')) return '📚';
            if (lowerName.includes('cafeteria') || lowerName.includes('อาหาร')) return '🍽️';
            if (lowerName.includes('music') || lowerName.includes('ดนตรี')) return '🎵';
            if (lowerName.includes('art') || lowerName.includes('ศิลปะ')) return '🎨';
            if (lowerName.includes('gym') || lowerName.includes('ยิม')) return '🏃';
            if (lowerName.includes('lab') || lowerName.includes('ปฏิบัติการ') || lowerName.includes('เคมี') || lowerName.includes('ฟิสิกส์')) return '🧪';
            if (lowerName.includes('office') || lowerName.includes('สำนักงาน') || lowerName.includes('ผู้อำนวยการ')) return '🏢';
            return '🎓';
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            if (!notification) return;
            
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function openAdminInterface() {
            // Update this URL after deployment
            window.open('./admin.html', '_blank');
        }
		function openSystemPresentation() {
            // Update this URL after deployment
            window.open('./SystemPresentation.html', '_blank');
        }


	 
		// ===== 2. เพิ่มฟังก์ชันจัดการ Persistent Destination =====
		// v1.1 เพิ่มหลังฟังก์ชัน updateRouteControls()

		function saveDestination(roomCode) {
			if (!roomData[roomCode]) return;
			
			const room = roomData[roomCode];
			
			// 🔥 เคลียร์เส้นทางเดิมเมื่อเปลี่ยน destination
			if (persistentDestination.roomCode && persistentDestination.roomCode !== roomCode) {
				console.log('🗑️ Clearing route due to destination change in saveDestination');
				forceRouteCleanup();
				updateRouteControls(false);
			}
			
			// บันทึก destination ใหม่
			persistentDestination = {
				roomCode: roomCode,
				roomName: room.name,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem('persistentDestination', JSON.stringify(persistentDestination));
				console.log('💾 Destination saved:', persistentDestination);
			} catch (error) {
				console.warn('⚠️ Could not save destination to localStorage:', error);
			}
			
			// อัปเดต UI
			updateDestinationDisplay();
		}

		function loadDestination() {
			try {
				const saved = localStorage.getItem('persistentDestination');
				if (saved) {
					const data = JSON.parse(saved);
					// ตรวจสอบว่าข้อมูลไม่เก่าเกิน 1 ชั่วโมง
					if (data.timestamp && (Date.now() - data.timestamp) < 3600000) {
						if (roomData[data.roomCode]) {
							persistentDestination = data;
							selectedRoom = data.roomCode;
							console.log('🎯 Restored destination:', data.roomName);
							return true;
						}
					}
				}
			} catch (error) {
				console.error('Error loading destination:', error);
			}
			return false;
		}

		function clearDestination() {
			persistentDestination = { roomCode: null, roomName: null, timestamp: null };
			localStorage.removeItem('persistentDestination');
			selectedRoom = null;
			console.log('🗑️ Cleared destination');
		}

		function showDestinationStatus() {
			if (persistentDestination.roomCode && roomData[persistentDestination.roomCode]) {
				const statusMessage = currentLanguage === 'th' 
					? `🎯 จุดหมาย: ${persistentDestination.roomName}`
					: `🎯 Destination: ${persistentDestination.roomName}`;
				
				showNotification(statusMessage, 'info');
				
				// อัปเดตปุ่มแสดงเส้นทาง
				const showRouteBtn = document.getElementById('showRouteBtn');
				if (showRouteBtn) {
					showRouteBtn.disabled = false;
					showRouteBtn.style.background = 'var(--accent-color)';
				}
			}
		}

		// ===== 3. แก้ไขฟังก์ชัน selectRoom() =====
		// v1.1 แทนที่ฟังก์ชัน selectRoom() เดิม

		function selectRoom(roomCode) {
			if (!roomData[roomCode]) return;
			
			const room = roomData[roomCode];
			
			console.log('🎯 Selecting new room:', room.name);
			
			// 🔥 เคลียร์เส้นทางเดิมทันทีเมื่อเลือกห้องใหม่ (ไม่ว่าจะเปลี่ยนหรือไม่)
			if (routeDisplayed) {
				console.log('🗑️ Clearing existing route due to room selection');
				
				// เคลียร์ทุก visual elements ที่เกี่ยวข้องกับเส้นทาง
				const routeElements = document.querySelectorAll(`
					.route-line, .route-marker, .route-path, .route-animated, 
					.route-line-animated, .route-marker-enhanced, 
					path[stroke="#dc3545"], circle[fill="#28a745"], circle[fill="#dc3545"],
					svg.route-path, .route-step-marker, .navigation-marker, [data-route="true"]
				`);
				
				routeElements.forEach(el => {
					console.log('Removing route element:', el.tagName, el.className);
					el.remove();
				});
				
				// เคลียร์ routePath element
				const routePath = document.getElementById('routePath');
				if (routePath) {
					routePath.innerHTML = '';
					routePath.style.display = 'none';
					routePath.remove(); // ลบทิ้งเลย
				}
				
				// เคลียร์ SVG ใน map container
				const mapContainer = ensureMapContainer();
				if (mapContainer) {
					const svgElements = mapContainer.querySelectorAll('svg.route-path, .route-animated, .route-line-animated');
					svgElements.forEach(el => {
						console.log('Removing SVG from map:', el.tagName);
						el.remove();
					});
				}
				
				// รีเซ็ต route state ทันที
				routeDisplayed = false;
				currentRoute = null;
				
				console.log('✅ Route cleared completely before setting new destination');
			}
			
			// ตรวจสอบว่าเป็นการเปลี่ยนจุดหมายใหม่หรือไม่
			const isChangingDestination = selectedRoom && selectedRoom !== roomCode;
			
			if (isChangingDestination) {
				// แจ้งเตือนว่าเปลี่ยนจุดหมายแล้ว
				const changeMessage = currentLanguage === 'th' 
					? `🎯 เปลี่ยนจุดหมายเป็น: ${room.name}`
					: `🎯 Destination changed to: ${room.name}`;
				showNotification(changeMessage, 'info');
			}
			
			// ตั้งค่าห้องใหม่
			selectedRoom = roomCode;
			persistentDestination = {
				roomCode: roomCode,
				roomName: room.name,
				building: room.building || '',
				floor: room.floor || ''
			};
			
			// บันทึกลง localStorage
			localStorage.setItem('persistentDestination', JSON.stringify(persistentDestination));
			
			// อัพเดต UI
			highlightSelectedRoom(roomCode);
			showRoomDetails(room);
			updatePersistentDestinationStatus();
			
			// อัพเดตปุ่มเส้นทาง
			updateRouteControls();
			
			console.log('✅ Room selected successfully:', {
				roomCode,
				roomName: room.name,
				hasStartPoint: !!startPoint,
				routeDisplayed
			});
		}
		
		// ===== v1.1  ปรับปรุงฟังก์ชัน updateRouteControls() =====
		/*
       function updateRouteControls(showRoute) {
			const showRouteBtn = document.getElementById('showRouteBtn');
			const clearRouteBtn = document.getElementById('clearRouteBtn');
			const voiceBtn = document.getElementById('voiceNavigationBtn');
			
			console.log('🎮 Enhanced route controls update:', { 
				showRoute, 
				hasStartPoint: !!startPoint, 
				hasSelectedRoom: !!selectedRoom,
				routeDisplayed: routeDisplayed
			});
			
			if (showRouteBtn) {
				// 🔥 แสดงปุ่ม "แสดงเส้นทาง" เฉพาะเมื่อ:
				// 1. มีจุดเริ่มต้นและจุดปลายทาง
				// 2. แต่ยังไม่มีเส้นทางแสดงอยู่ (routeDisplayed = false)
				const hasRequiredPoints = startPoint && selectedRoom && roomData[selectedRoom];
				const shouldShowBtn = hasRequiredPoints && !routeDisplayed;
				
				if (shouldShowBtn) {
					showRouteBtn.style.display = 'inline-block';
					showRouteBtn.disabled = false;
					showRouteBtn.style.background = 'var(--primary-color)';
					showRouteBtn.style.opacity = '1';
					showRouteBtn.style.cursor = 'pointer';
					
					// 🆕 เพิ่ม animation เพื่อดึงดูดความสนใจ
					showRouteBtn.style.animation = 'pulse 2s infinite';
					
					console.log('✅ Show Route button is now visible and active');
				} else {
					showRouteBtn.style.display = 'none';
					showRouteBtn.style.animation = 'none';
					
					console.log('❌ Show Route button hidden - missing requirements');
				}
				
				console.log('ShowRouteBtn status:', {
					hasRequiredPoints,
					routeDisplayed,
					shouldShowBtn,
					display: showRouteBtn.style.display
				});
			}
			
			if (clearRouteBtn) {
				// แสดงปุ่ม "ลบเส้นทาง" เฉพาะเมื่อมีเส้นทางแสดงอยู่
				if (routeDisplayed) {
					clearRouteBtn.style.display = 'inline-block';
					clearRouteBtn.style.background = '#dc3545';
					clearRouteBtn.style.opacity = '1';
				} else {
					clearRouteBtn.style.display = 'none';
				}
			}
			
			if (voiceBtn) {
				// แสดงปุ่ม voice navigation เฉพาะเมื่อมีเส้นทางแสดงอยู่
				voiceBtn.style.display = routeDisplayed ? 'inline-block' : 'none';
			}
		}*/
		
		// v1.1 แทนที่ฟังก์ชัน updateRouteControls() ด้วยรุ่นที่มีประสิทธิภาพสูง
		function updateRouteControls() {
			const showRouteBtn = document.getElementById('showRouteBtn');
			const clearRouteBtn = document.getElementById('clearRouteBtn');
			const voiceBtn = document.getElementById('voiceNavigationBtn');
			
			console.log('🎮 Updating route controls:', { 
				hasStartPoint: !!startPoint, 
				hasSelectedRoom: !!selectedRoom,
				routeDisplayed: routeDisplayed
			});
			
			if (showRouteBtn) {
				// 🔥 แสดงปุ่ม "แสดงเส้นทาง" เฉพาะเมื่อ:
				// 1. มีจุดเริ่มต้นและปลายทาง
				// 2. แต่ยังไม่มีเส้นทางแสดงอยู่ (routeDisplayed = false)
				const hasRequiredPoints = startPoint && selectedRoom && roomData[selectedRoom];
				const shouldShowBtn = hasRequiredPoints && !routeDisplayed;
				
				if (shouldShowBtn) {
					showRouteBtn.style.display = 'inline-block';
					showRouteBtn.disabled = false;
					showRouteBtn.style.background = 'var(--primary-color)';
					showRouteBtn.style.opacity = '1';
					showRouteBtn.style.cursor = 'pointer';
					showRouteBtn.style.color = '#fff';
				} else {
					// ซ่อนปุ่มเมื่อไม่ครบเงื่อนไข หรือมีเส้นทางแสดงอยู่แล้ว
					showRouteBtn.style.display = 'none';
				}
				
				console.log('ShowRouteBtn status:', {
					hasRequiredPoints,
					routeDisplayed,
					shouldShowBtn,
					display: showRouteBtn.style.display
				});
			}
			
			if (clearRouteBtn) {
				// แสดงปุ่ม "ลบเส้นทาง" เฉพาะเมื่อมีเส้นทางแสดงอยู่
				if (routeDisplayed) {
					clearRouteBtn.style.display = 'inline-block';
					clearRouteBtn.style.background = '#dc3545';
					clearRouteBtn.style.opacity = '1';
					clearRouteBtn.style.color = '#fff';
				} else {
					clearRouteBtn.style.display = 'none';
				}
			}
			
			if (voiceBtn) {
				// แสดงปุ่ม voice navigation เฉพาะเมื่อมีเส้นทางแสดงอยู่
				voiceBtn.style.display = routeDisplayed ? 'inline-block' : 'none';
			}
		}
		 
		
		// v1.1 เพิ่มฟังก์ชันสำหรับเคลียร์เส้นทางอย่างสมบูรณ์
		function forceRouteCleanup() {
			console.log('🧹 Ultimate route cleanup starting...');
			
			// หยุด animations ทันที
			const animatedElements = document.querySelectorAll('[style*="animation"]');
			animatedElements.forEach(el => {
				if (el.style.animation.includes('dash') || el.style.animation.includes('pulse')) {
					el.style.animation = 'none';
				}
			});
			
			// รายการ selectors ที่ครอบคลุมทุกกรณี
			const routeSelectors = [
				'.route-line', '.route-marker', '.route-path', '.route-step-marker',
				'.navigation-marker', '[data-route="true"]', '.route-animated',
				'.route-line-animated', '.route-marker-enhanced', 'path[stroke="#dc3545"]',
				'circle[fill="#28a745"]', 'circle[fill="#dc3545"]', 'polygon[fill="#dc3545"]',
				'svg[class*="route"]', 'path[class*="route"]', 'circle[class*="route"]',
				'polygon[class*="route"]'
				// ลบ '[class*="route-"]' ออกเพราะมันจะลบปุ่ม controls ด้วย
			];
			
			// ลบทุก element ที่เกี่ยวข้องกับ route จาก document ทั้งหมด
			routeSelectors.forEach(selector => {
				try {
					const elements = document.querySelectorAll(selector);
					elements.forEach(el => {
						console.log('Ultimate removing:', el.tagName, el.className || el.getAttribute('class'));
						if (el && el.parentNode) {
							el.parentNode.removeChild(el);
						}
					});
				} catch (e) {
					console.warn('Selector error:', selector, e);
				}
			});
			
			// ลบ routePath และสร้างใหม่
			const existingRoutePath = document.getElementById('routePath');
			if (existingRoutePath) {
				existingRoutePath.remove();
				console.log('✅ Removed existing routePath');
			}
			
			// ลบทุก SVG elements ที่มี route properties จากทุก container
			const allPossibleContainers = [
				document.getElementById('mapContainer'),
				document.getElementById('mapArea'),
				document.querySelector('.map-area'),
				document.querySelector('.map-container'),
				document.querySelector('#mapImage')?.parentElement,
				document.body
			].filter(Boolean);
			
			allPossibleContainers.forEach(container => {
				if (container && container.nodeType === 1) {
					// ลบ SVG ที่เป็น route ทั้งหมด
					const allSvgElements = container.querySelectorAll('svg, path, circle, polygon, line, polyline');
					allSvgElements.forEach(el => {
						const isRouteElement = 
							el.getAttribute('stroke') === '#dc3545' ||
							el.getAttribute('fill') === '#28a745' ||
							el.getAttribute('fill') === '#dc3545' ||
							el.className.baseVal?.includes('route') ||
							el.classList.contains('route-path') ||
							el.classList.contains('route-animated') ||
							el.getAttribute('data-route') === 'true';
						
						if (isRouteElement) {
							console.log('Removing route SVG:', el.tagName);
							if (el.parentNode) {
								el.parentNode.removeChild(el);
							}
						}
					});
				}
			});
			
			// รีเซ็ต global states
			window.routeDisplayed = false;
			window.currentRoute = null;
			
		 
			// ⭐ เพิ่มบรรทัดนี้เพื่อ restore ปุ่ม controls หลัง cleanup
			setTimeout(() => {
				updateRouteControls(); 
			}, 100);
		}

		// ===== v1.1 แก้ไขฟังก์ชัน handleMapClick() =====
		function handleMapClick(event) {
			if (!event) return;
			
			console.log('🖱️ Map clicked');
			
			// ตรวจสอบว่าคลิกที่ element ที่ไม่ใช่แผนที่
			if (event.target.closest('.room-marker') || 
				event.target.closest('.route-controls') ||
				event.target.closest('.search-container')) {
				return;
			}
			
			const rect = event.currentTarget.getBoundingClientRect();
			const x = ((event.clientX - rect.left) / rect.width) * 100;
			const y = ((event.clientY - rect.top) / rect.height) * 100;
			
			console.log('📍 Click coordinates:', { x: x.toFixed(2), y: y.toFixed(2) });
			
			// 🔥 แก้ไข: เมื่อเปลี่ยนจุดเริ่มต้น ไม่ให้ลบจุดปลายทางเดิม
			if (startPoint) {
				console.log('📍 Updating existing start point (preserving destination)');
				
				// เคลียร์เฉพาะเส้นทาง ไม่ลบจุดปลายทาง
				if (routeDisplayed) {
					console.log('🗑️ Clearing route for new start point');
					clearRoute(); // ลบเส้นทางเดิม
				}
			} else {
				console.log('📍 Setting initial start point');
			}
			
			// อัพเดตจุดเริ่มต้นใหม่
			startPoint = { x, y };
			
			// บันทึกลง localStorage (คงจุดปลายทางเดิมไว้)
			localStorage.setItem('startPoint', JSON.stringify(startPoint));
			
			// อัพเดต UI marker
			updateStartPointMarker(x, y);
			
			// ตรวจสอบสถานะและอัพเดตปุ่ม
			const hasDestination = selectedRoom && roomData[selectedRoom];
			
			if (hasDestination) {
				console.log('✅ Both start point and destination available');
				
				// แสดง notification
				const statusMessage = currentLanguage === 'th' 
					? `📍 ตั้งจุดเริ่มต้นใหม่ (จุดหมาย: ${persistentDestination.roomName})`
					: `📍 Start point updated (Destination: ${persistentDestination.roomName})`;
				
				showNotification(statusMessage, 'success');
				
				// อัพเดตปุ่มแสดงเส้นทาง
				updateRouteControls();
			} else {
				const message = currentLanguage === 'th' 
					? '📍 ตั้งจุดเริ่มต้นแล้ว กรุณาเลือกจุดหมาย'
					: '📍 Start point set. Please select destination';
				showNotification(message, 'info');
			}
			
			console.log('📍 Start point updated:', { 
				startPoint, 
				hasDestination,
				selectedRoom
			});
		}
		
		// v1.1 เพิ่มฟังก์ชัน updateStartPointMarker() หากยังไม่มี
		function updateStartPointMarker(x, y) {
			// ไม่แสดงจุดเริ่มต้นให้ผู้ใช้เห็น - จุดนี้จะซ่อนอยู่
			debugLog('📍 Start point updated (hidden from user)', { x: x.toFixed(2), y: y.toFixed(2) });
			
			// อัปเดต internal state เท่านั้น ไม่สร้าง visual marker
			// สำหรับ debugging เท่านั้น
			if (window.debugMode) {
				console.log('Hidden start point:', { x, y });
			}
		}

		// ===== เพิ่มฟังก์ชันตรวจสอบและแก้ไขปัญหา state =====
		function validateRouteState() {
			console.log('🔍 Validating route state...');
			
			// ตรวจสอบ persistent destination
			if (persistentDestination.roomCode && !roomData[persistentDestination.roomCode]) {
				console.warn('⚠️ Persistent destination refers to non-existent room');
				clearDestination();
				return false;
			}
			
			// ตรวจสอบ selectedRoom
			if (selectedRoom && !roomData[selectedRoom]) {
				console.warn('⚠️ Selected room does not exist');
				selectedRoom = null;
				return false;
			}
			
			// ซิงค์ระหว่าง selectedRoom และ persistentDestination
			if (persistentDestination.roomCode && selectedRoom !== persistentDestination.roomCode) {
				console.log('🔧 Syncing selected room with persistent destination');
				selectedRoom = persistentDestination.roomCode;
			}
			
			return true;
		}

		// ===== เพิ่มฟังก์ชัน Debug สำหรับตรวจสอบปัญหา =====
		// เรียกใช้ debug function นี้ใน console เมื่อมีปัญหา: debugRouteProblem()
		function debugRouteProblem() {
			console.group('🐛 Route State Debug');
			console.log('startPoint:', startPoint);
			console.log('selectedRoom:', selectedRoom);
			console.log('persistentDestination:', persistentDestination);
			console.log('Room data exists:', selectedRoom ? !!roomData[selectedRoom] : 'No room selected');
			console.log('Route displayed:', document.querySelector('.route-line') ? 'Yes' : 'No');
			console.log('LocalStorage persistent:', localStorage.getItem('persistentDestination'));
			console.log('LocalStorage startPoint:', localStorage.getItem('startPoint'));
			console.groupEnd();
		}



        // =================== Page Management ===================
		// ======= v1.1 ปรับปรุงฟังก์ชัน showPage สำหรับแผนที่ =======
		function showPage(pageId) {
		
		    // เพิ่มการจัดการ body class สำหรับ map page
		const body = document.body;
		
		// ลบ class เก่าทั้งหมด
		body.classList.remove('map-page', 'search-page', 'help-page');
		
		// เพิ่ม class ตาม page ปัจจุบัน
		if (pageId === 'map') {
			body.classList.add('map-page');
			body.setAttribute('data-current-page', 'map');
		} else if (pageId === 'search') {
			body.classList.add('search-page');
			body.setAttribute('data-current-page', 'search');
		} else if (pageId === 'help') {
			body.classList.add('help-page');
			body.setAttribute('data-current-page', 'help');
		}
	
			document.querySelectorAll('.page').forEach(page => {
				page.classList.remove('active');
			});
			
			document.querySelectorAll('.nav-item').forEach(item => {
				item.classList.remove('active');
			});
			
			const targetPage = document.getElementById(pageId + '-page');
			if (targetPage) {
				targetPage.classList.add('active');
			}
			
			if (pageId === 'search') {
				document.querySelector('.nav-item:nth-child(1)').classList.add('active');
			} else if (pageId === 'map') {
				document.querySelector('.nav-item:nth-child(2)').classList.add('active');
				
				// 🔥 เคลียร์เส้นทางเมื่อเข้าหน้า map (กรณีมาจากการเลือกห้องใหม่)
				setTimeout(() => {
					console.log('📍 Loading map page...');
					
					// ตรวจสอบว่ามีการเปลี่ยนจุดหมายหรือไม่
					const destinationLoaded = loadDestination();
					
					// ตรวจสอบ state consistency
					validateRouteState();
					
					// อัปเดตการแสดงผล
					if (destinationLoaded && persistentDestination.roomCode) {
						console.log('🎯 Destination available:', persistentDestination.roomName);
						updateDestinationDisplay();
						
						// 🔥 แน่ใจว่าไม่มีเส้นทางแสดงเมื่อเข้าหน้า map จากการเลือกห้องใหม่
						updateRouteControls(false);
						
					} else {
						console.log('📍 No destination set');
						updateRouteControls(false);
						
						setTimeout(() => {
							const selectMessage = currentLanguage === 'th' 
								? '🏫 กรุณาค้นหาและเลือกห้องปลายทาง'
								: '🏫 Please search and select a destination room';
							showNotification(selectMessage, 'info');
						}, 1000);
					}
				}, 100);
			}
		}
		 
		
		// ===== 7. เพิ่ม Error Handling สำหรับรูปภาพ =====
		// เพิ่มฟังก์ชันใหม่:

		function handleImageLoadError(imgElement, roomName = '') {
			console.warn('⚠️ Image load failed:', imgElement.src);
			
			imgElement.style.display = 'none';
			
			// สร้าง placeholder
			const placeholder = document.createElement('div');
			placeholder.style.cssText = `
				text-align: center; 
				padding: 40px; 
				background: #f8f9fa; 
				border-radius: 8px; 
				color: var(--text-secondary);
				border: 2px dashed #dee2e6;
			`;
			placeholder.innerHTML = `
				<i class="fas fa-image" style="font-size: 32px; opacity: 0.3; margin-bottom: 10px;"></i>
				<p>ไม่สามารถโหลดรูปภาพได้</p>
				${roomName ? `<small>ห้อง: ${roomName}</small>` : ''}
			`;
			
			imgElement.parentNode.insertBefore(placeholder, imgElement.nextSibling);
		}	
		
		window.debugRouteState = function() {
			console.log('🐛 Route Debug State:');
			console.log('selectedRoom:', selectedRoom);
			console.log('persistentDestination:', persistentDestination);
			console.log('startPoint:', startPoint);
			console.log('Room exists:', selectedRoom ? !!roomData[selectedRoom] : 'N/A');
			console.log('Route lines on page:', document.querySelectorAll('.route-line').length);
			console.log('Route markers on page:', document.querySelectorAll('.route-marker').length);
		};
		
		// ======= เพิ่มการจัดการ Error สำหรับภาพแผนที่ =======
		function handleMapImageError(event) {
			console.error('❌ Map image failed to load:', event.target.src);
			
			// ลองสลับไปภาพอื่นก่อน
			if (currentMapLayout === 'photo' && mapData.floorplan) {
				console.log('🔄 Photo failed, trying floorplan...');
				currentMapLayout = 'floorplan';
				updateMapDisplay();
				showNotification('⚠️ ภาพจริงโหลดไม่ได้ เปลี่ยนเป็นแผนผัง', 'warning');
				return;
			} else if (currentMapLayout === 'floorplan' && mapData.realphoto) {
				console.log('🔄 Floorplan failed, trying photo...');
				currentMapLayout = 'photo';
				updateMapDisplay();
				showNotification('⚠️ แผนผังโหลดไม่ได้ เปลี่ยนเป็นภาพจริง', 'warning');
				return;
			}
			
			// ถ้าไม่มีภาพอื่นให้ลอง แสดง fallback
			showFallbackMap();
			showNotification('⚠️ ไม่สามารถโหลดภาพแผนที่ได้', 'warning');
		}
		
		// ======= เพิ่ม Auto-retry สำหรับการโหลดแผนที่ =======
		async function retryLoadMapImages(maxRetries = 3) {
			for (let i = 0; i < maxRetries; i++) {
				try {
					console.log(`🔄 Retry loading map images: attempt ${i + 1}/${maxRetries}`);
					await loadMapDataFromSheets();
					
					if (mapData.floorplan || mapData.realphoto) {
						console.log('✅ Map images loaded successfully on retry');
						return true;
					}
				} catch (error) {
					console.warn(`⚠️ Retry ${i + 1} failed:`, error.message);
					
					if (i < maxRetries - 1) {
						// รอ 2 วินาทีก่อนลองใหม่
						await new Promise(resolve => setTimeout(resolve, 2000));
					}
				}
			}
			
			console.error('❌ All retry attempts failed');
			return false;
		}
		
		// ======= Background Sync สำหรับแผนที่ =======
		async function backgroundSyncMapImages() {
			if (currentVersion !== 'live') return;
			
			// ตรวจสอบว่า cache หมดอายุหรือไม่
			if (!isCacheValid('mapImages', 60 * 60 * 1000)) { // 1 ชั่วโมง
				console.log('🔄 Background sync: Map images cache expired, refreshing...');
				
				try {
					await loadMapDataFromSheets();
					console.log('✅ Background sync: Map images updated');
				} catch (error) {
					console.log('⚠️ Background sync: Map images failed -', error.message);
				}
			}
		}

		// ======= Cache Management Functions =======
		function clearDataCache() {
			// ลบ cache ทั้งหมดเมื่อต้องการให้โหลดข้อมูลใหม่
			const keys = Object.keys(localStorage);
			keys.forEach(key => {
				if (key.includes('_cache_') || key.includes('_timestamp_')) {
					localStorage.removeItem(key);
				}
			});
			console.log('🗑️ Data cache cleared');
		}

		function getCacheInfo() {
			// ฟังก์ชันสำหรับ debug - ดูข้อมูลใน cache
			const cacheInfo = {
				rooms: {
					cached: !!getCachedData('rooms'),
					timestamp: localStorage.getItem(getDataTimestampKey('rooms')),
					valid: isCacheValid('rooms')
				},
				buildings: {
					cached: !!getCachedData('buildings'),
					timestamp: localStorage.getItem(getDataTimestampKey('buildings')),
					valid: isCacheValid('buildings')
				}
			};
			console.log('📊 Cache Info:', cacheInfo);
			return cacheInfo;
		}

        // =================== Search Functions ===================
        
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchRoom();
            }
        }

       
		// ✅ แก้ไขฟังก์ชัน liveSearch ให้แสดงจำนวนทันที
		function liveSearch() {
			try {
				const searchInput = document.getElementById('liveSearchInput');
				const resultsContainer = document.getElementById('liveResults');
				
				if (!searchInput || !resultsContainer) return;
				
				const searchTerm = searchInput.value.trim();
				
				if (searchTerm.length === 0) {
					resultsContainer.innerHTML = '';
					return;
				}
				
				if (searchTerm.length < 2) {
					resultsContainer.innerHTML = `
						<div style="text-align: center; padding: 20px; color: var(--text-secondary);">
							กรุณาพิมพ์อย่างน้อย 2 ตัวอักษร
						</div>
					`;
					return;
				}
				
				// ค้นหาและแสดงจำนวนทันที
				const results = searchRooms(searchTerm);
				
				// ✅ แสดงจำนวนผลการค้นหาทันที
				const statsMessage = results.length > 0 
					? `🔍 พบ ${results.length} ห้องที่ตรงกับ "${searchTerm}"`
					: `🔍 ไม่พบห้องที่ตรงกับ "${searchTerm}"`;
					
				// แสดงสถิติด้านบน
				resultsContainer.innerHTML = `
					<div style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: var(--border-radius); margin-bottom: 15px; text-align: center; color: var(--primary-color); font-weight: 600;">
						${statsMessage}
					</div>
				`;
				
				if (results.length > 0) {
					displaySearchResults(results);
				} else {
					resultsContainer.innerHTML += `
						<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
							<div style="font-size: 48px; margin-bottom: 15px; opacity: 0.7;">🔍</div>
							<p style="margin-bottom: 10px; font-weight: 600;">ไม่พบผลการค้นหา</p>
							<p style="font-size: 12px;">ลองค้นหาด้วยคำอื่น เช่น "ห้องเรียน", "คอมพิวเตอร์", "ชั้น 1"</p>
						</div>
					`;
				}
				
			} catch (error) {
				console.error('Search error:', error);
				showNotification('❌ เกิดข้อผิดพลาดในการค้นหา กรุณาลองใหม่', 'error');
			}
		}


        // ✅ ปรับปรุงฟังก์ชัน searchRoom หลัก
		function searchRoom() {
			const searchInput = document.getElementById('searchInput');
			if (!searchInput) return;
			
			const searchTerm = searchInput.value.toLowerCase().trim();
			
			if (!searchTerm) {
				showNotification('❌ กรุณาใส่คำค้นหา', 'error');
				return;
			}
			
			try {
				// ✅ เพิ่ม error handling และ fallback
				let results = searchRooms(searchTerm);
				
				// ถ้าไม่เจออะไรเลย ลองใช้ advanced search
				if (results.length === 0) {
					results = searchRoomsAdvanced(searchTerm);
				}
				
				displaySearchResults(results);
				
				// แสดงสถิติการค้นหา
				const statsMessage = results.length > 0 
					? `🔍 พบ ${results.length} ห้องที่ตรงกับ "${searchTerm}"`
					: `🔍 ไม่พบห้องที่ตรงกับ "${searchTerm}"`;
					
				setTimeout(() => {
					showNotification(statsMessage, results.length > 0 ? 'info' : 'warning');
				}, 500);
				
			} catch (error) {
				console.error('Main search error:', error);
				showNotification('❌ เกิดข้อผิดพลาดในการค้นหา กรุณาลองใหม่', 'error');
			}
		}
		
		
		
		// ✅ เพิ่มฟังก์ชัน debug สำหรับตรวจสอบข้อมูลห้อง
		function debugRoomData() {
			const rooms = Object.values(roomData);
			console.log('🔍 Room Data Debug:');
			console.log(`Total rooms: ${rooms.length}`);
			
			const fieldsCheck = {
				name: 0,
				code: 0,
				location: 0,
				building: 0,
				description: 0,
				type: 0
			};
			
			rooms.forEach(room => {
				Object.keys(fieldsCheck).forEach(field => {
					if (room[field] && room[field].toString().trim().length > 0) {
						fieldsCheck[field]++;
					}
				});
			});
			
			console.log('Field completion:');
			Object.entries(fieldsCheck).forEach(([field, count]) => {
				console.log(`  ${field}: ${count}/${rooms.length} (${(count/rooms.length*100).toFixed(1)}%)`);
			});
			
			// แสดงห้องที่ไม่มี location
			const roomsWithoutLocation = rooms.filter(room => !room.location || room.location.toString().trim().length === 0);
			if (roomsWithoutLocation.length > 0) {
				console.log(`⚠️ Rooms without location: ${roomsWithoutLocation.length}`);
				roomsWithoutLocation.slice(0, 5).forEach(room => {
					console.log(`  - ${room.code}: ${room.name} (floor: ${room.floor || 'N/A'})`);
				});
			}
		}

		console.log('✅ Search functions fixed with error handling');
		console.log('🔧 Available debug command: debugRoomData()');

		// ใช้งานฟังก์ชัน debug เพื่อตรวจสอบข้อมูล
		if (typeof roomData !== 'undefined' && Object.keys(roomData).length > 0) {
			debugRoomData();
		}
	 
		
		// ✅ แก้ไข: ปรับปรุงฟังก์ชัน searchRooms พื้นฐาน
		function searchRooms(searchTerm) {
			const rooms = Object.values(roomData);
			return rooms.filter(room => {
				if (!room || room.status !== 'active') return false;
				
				try {
					// ✅ แก้ไข: ใช้ safeToString แทนการแปลงโดยตรง
					const searchFields = [
						safeToString(room.name).toLowerCase(),
						safeToString(room.code).toLowerCase(),
						safeToString(room.location || room.floor).toLowerCase(),
						safeToString(room.building).toLowerCase(),
						safeToString(room.description).toLowerCase(),
						safeToString(room.type).toLowerCase()
					].filter(field => field.length > 0);
					
					return searchFields.some(field => field.includes(searchTerm.toLowerCase()));
					
				} catch (error) {
					console.warn('Basic search error for room:', room.code, error);
					return false;
				}
			});
		}
		
		
		// ✅ แก้ไข: เพิ่ม type checking และ error handling
		function searchRoomsAdvanced(searchTerm) {
			const rooms = Object.values(roomData);
			const normalizedTerm = searchTerm.toLowerCase().trim();
			
			return rooms.filter(room => {
				if (!room || room.status !== 'active') return false;
				
				try {
					// ✅ แก้ไข: ใช้ฟังก์ชัน helper สำหรับแปลงเป็น string อย่างปลอดภัย
					const basicFields = [
						safeToString(room.name).toLowerCase(),
						safeToString(room.code).toLowerCase(),
						safeToString(room.location).toLowerCase(),
						safeToString(room.building).toLowerCase(),
						safeToString(room.description).toLowerCase(),
						safeToString(room.type).toLowerCase()
					].filter(field => field.length > 0);
					
					const basicMatch = basicFields.some(field => field.includes(normalizedTerm));
					
					// การค้นหาขั้นสูง
					const advancedMatches = [
						// ค้นหาตามชั้น
						normalizedTerm.includes('ชั้น') && safeToString(room.floor || room.location).includes(normalizedTerm.replace('ชั้น', '').trim()),
						normalizedTerm.includes('floor') && safeToString(room.floor || room.location).includes(normalizedTerm.replace('floor', '').trim()),
						
						// ค้นหาตามประเภทห้อง
						normalizedTerm.includes('เรียน') && safeToString(room.name).toLowerCase().includes('เรียน'),
						normalizedTerm.includes('classroom') && safeToString(room.type).toLowerCase().includes('classroom'),
						normalizedTerm.includes('คอม') && safeToString(room.name).toLowerCase().includes('คอม'),
						normalizedTerm.includes('computer') && safeToString(room.name + room.type).toLowerCase().includes('computer'),
						normalizedTerm.includes('ห้องน้ำ') && safeToString(room.name).toLowerCase().includes('ห้องน้ำ'),
						normalizedTerm.includes('toilet') && safeToString(room.name + room.type).toLowerCase().includes('toilet'),
						
						// ค้นหาตามอาคาร
						normalizedTerm.includes('อาคาร') && safeToString(room.building).toLowerCase().includes(normalizedTerm),
						normalizedTerm.includes('building') && safeToString(room.building).toLowerCase().includes(normalizedTerm)
					];
					
					return basicMatch || advancedMatches.some(match => match);
					
				} catch (error) {
					console.warn('Search error for room:', room.code, error);
					return false;
				}
			});
		}
		
		// ✅ เพิ่ม: ฟังก์ชัน helper สำหรับแปลงค่าเป็น string อย่างปลอดภัย
		function safeToString(value) {
			if (value === null || value === undefined) return '';
			if (typeof value === 'string') return value;
			if (typeof value === 'number') return value.toString();
			if (typeof value === 'boolean') return value.toString();
			if (typeof value === 'object') return JSON.stringify(value);
			return String(value);
		}
		

     // ✅ แก้ไข: เพิ่ม safety checks ในการแสดงผล
		function displaySearchResults(results) {
			const resultsContainer = document.getElementById('liveResults');
			if (!resultsContainer) return;
			
			if (results.length > 0) {
				resultsContainer.innerHTML = results.map(room => {
					// ✅ เพิ่ม safety checks
					const buildingName = buildingsData[room.building]?.name || safeToString(room.building) || 'ไม่ระบุอาคาร';
					const roomLocation = safeToString(room.location) || (room.floor ? `ชั้น ${room.floor}` : 'ไม่ระบุตำแหน่ง');
					const roomDescription = safeToString(room.description) || 'ไม่มีรายละเอียด';
					const roomName = safeToString(room.name) || 'ไม่มีชื่อ';
					const roomCode = safeToString(room.code) || 'ไม่มีรหัส';
					
					return `
						<div class="search-result-item" onclick="viewOnMap('${roomCode}')">
							<div class="search-result-header">
								<div class="search-result-title">
									${getRoomIcon(roomName)} ${roomName}
								</div>
								<div class="search-result-code">${roomCode}</div>
							</div>
							<div class="search-result-info">
								<div style="margin-bottom: 5px;">
									<i class="fas fa-building" style="color: var(--primary-color); margin-right: 5px;"></i>
									${buildingName} - ${roomLocation}
								</div>
								${room.type ? `
									<div style="margin-bottom: 5px;">
										<i class="fas fa-tag" style="color: var(--accent-color); margin-right: 5px;"></i>
										${safeToString(room.type)}
									</div>
								` : ''}
								${roomDescription !== 'ไม่มีรายละเอียด' ? `
									<div style="font-size: 12px; color: var(--text-secondary);">
										<i class="fas fa-info-circle" style="margin-right: 5px;"></i>
										${roomDescription}
									</div>
								` : ''}
							</div>
						</div>
					`;
				}).join('');
				
				// แสดงคำแนะนำ
				const hintMessage = currentLanguage === 'th' 
					? '💡 คลิกที่ผลการค้นหาเพื่อดูตำแหน่งบนแผนที่'
					: '💡 Click search result to view location on map';
				
				resultsContainer.innerHTML += `
					<div style="text-align: center; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: var(--border-radius); margin-top: 10px; color: var(--primary-color); font-size: 12px;">
						${hintMessage}
					</div>
				`;
			} else {
				const noResultsText = currentLanguage === 'th' ? 'ไม่พบผลการค้นหา' : 'No results found';
				const suggestionText = currentLanguage === 'th' 
					? 'ลองค้นหาด้วยคำอื่น เช่น "ห้องเรียน", "คอมพิวเตอร์", "ชั้น 1"'
					: 'Try searching with other terms like "classroom", "computer", "floor 1"';
					
				resultsContainer.innerHTML = `
					<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
						<div style="font-size: 48px; margin-bottom: 15px; opacity: 0.7;">🔍</div>
						<p style="margin-bottom: 10px; font-weight: 600;">${noResultsText}</p>
						<p style="font-size: 12px; color: var(--text-secondary);">${suggestionText}</p>
					</div>
				`;
			}
		}

        function quickSearch(category) {
            let searchResults = [];
            
            switch(category) {
                case 'classroom':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('ห้องเรียน') || room.name.includes('Classroom') || room.name.includes('ม.'))
                    );
                    break;
                case 'special':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('คอมพิวเตอร์') || room.name.includes('Computer') ||
                        room.name.includes('ปฏิบัติการ') || room.name.includes('Lab'))
                    );
                    break;
                case 'facilities':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('สมุด') || room.name.includes('Library') ||
                        room.name.includes('อาหาร') || room.name.includes('Cafeteria'))
                    );
                    break;
                case 'office':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('สำนักงาน') || room.name.includes('Office'))
                    );
                    break;
            }
            
            displaySearchResults(searchResults);
        }

        // =================== Map Functions ===================
		// ======= Updated Search Functions =======
		function viewOnMap(roomCode) {
			showPage('map');
			setTimeout(() => {
				// เซ็ตห้องที่เลือกและแสดง marker
				selectedRoom = roomCode;
				updateRoomMarkers();
				
				// แสดงข้อมูลห้อง
				showRoomInfoOverlay(roomCode);
				
				// แจ้งเตือนให้ตั้งจุดเริ่มต้น
				if (!startPoint) {
					const message = currentLanguage === 'th' 
						? '💡 คลิกที่แผนที่เพื่อตั้งจุดเริ่มต้น จากนั้นคลิก "แสดงเส้นทาง" เพื่อดูการนำทาง'
						: '💡 Click on map to set starting point, then click "Show Route" for navigation';
					
					setTimeout(() => {
						showNotification(message, 'info');
					}, 1000);
				}
			}, 300);
		}


        function highlightRoom(roomCode) {
            document.querySelectorAll('.room-marker').forEach(marker => {
                marker.classList.remove('highlighted');
            });
            
            const targetMarker = document.querySelector(`[data-room="${roomCode}"]`);
            if (targetMarker) {
                targetMarker.classList.add('highlighted');
                selectedRoom = roomCode;
                
                setTimeout(() => {
                    targetMarker.classList.remove('highlighted');
                }, 3000);
            }
        }

        // 1.1: Toggle map controls visibility
        function toggleMapControls() {
			const mapControls = document.getElementById('mapControls');
			const toggleBtn = document.getElementById('toggleControlsBtn');
			const showControlsBtn = document.getElementById('showControlsBtn');
			
			if (!mapControls || !toggleBtn) return;
			
			const isHidden = mapControls.classList.contains('hidden');
			
			if (isHidden) {
				// Show controls
				mapControls.classList.remove('hidden');
				toggleBtn.innerHTML = `<i class="fas fa-eye-slash"></i> <span data-translate="hide_controls">${currentLanguage === 'th' ? 'ซ่อนปุ่ม' : 'Hide Controls'}</span>`;
				if (showControlsBtn) {
					showControlsBtn.style.display = 'none';
				}
				showNotification(
					currentLanguage === 'th' ? '👁️ แสดงปุ่มควบคุม' : '👁️ Controls shown',
					'info'
				);
			} else {
				// Hide controls
				mapControls.classList.add('hidden');
				toggleBtn.innerHTML = `<i class="fas fa-eye"></i> <span data-translate="show_controls">${currentLanguage === 'th' ? 'แสดงปุ่ม' : 'Show Controls'}</span>`;
				if (showControlsBtn) {
					showControlsBtn.style.display = 'block';
				}
				showNotification(
					currentLanguage === 'th' ? '🙈 ซ่อนปุ่มควบคุม' : '🙈 Controls hidden',
					'info'
				);
			}
		}
		
		function showAllControls() {
			const mapControls = document.getElementById('mapControls');
			const toggleBtn = document.getElementById('toggleControlsBtn');
			const showControlsBtn = document.getElementById('showControlsBtn');
			
			if (!mapControls || !toggleBtn) return;
			
			mapControls.classList.remove('hidden');
			toggleBtn.innerHTML = `<i class="fas fa-eye-slash"></i> <span data-translate="hide_controls">${currentLanguage === 'th' ? 'ซ่อนปุ่ม' : 'Hide Controls'}</span>`;
			if (showControlsBtn) {
				showControlsBtn.style.display = 'none';
			}
			showNotification(
				currentLanguage === 'th' ? '👁️ แสดงปุ่มควบคุมทั้งหมด' : '👁️ All controls shown',
				'info'
			);
		}



        // 1.1: Set map layout (floorplan/photo)
        function setMapLayout(layout) {
            currentMapLayout = layout;
            
            document.querySelectorAll('.map-control-btn[data-layout]').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const targetBtn = document.querySelector(`[data-layout="${layout}"]`);
            if (targetBtn) {
                targetBtn.classList.add('active');
            }
            
            // In real implementation, would switch between different map images
            const mapImage = document.getElementById('mapImage');
            if (mapImage) {
                if (layout === 'photo') {
                    // Replace with actual photo map
                    showNotification(
                        currentLanguage === 'th' ? '📸 เปลี่ยนเป็นภาพจริง' : '📸 Switched to photo view',
                        'success'
                    );
                } else {
                    // Use floorplan
                    showNotification(
                        currentLanguage === 'th' ? '📐 เปลี่ยนเป็นแผnผัง' : '📐 Switched to floor plan',
                        'success'
                    );
                }
            }
        }
		

        // 1.1: Toggle fullscreen mode
		// 🔧 FIXED toggleFullscreen Function - แก้ไข DOM positioning issue
		  

		function toggleFullscreen() {
			const mapArea = document.getElementById('mapArea');
			const fullscreenBtn = document.getElementById('fullscreenBtn');
			const mapControls = document.getElementById('mapControls');
			const body = document.body;
			const mapContainer = document.querySelector('.map-container');
			
			if (!mapArea || !fullscreenBtn) {
				console.log('Required elements not found');
				return;
			}
			
			if (isFullscreen) {
				// ========== EXIT FULLSCREEN ==========
				console.log('Exiting fullscreen mode...');
				
				// Remove existing controls
				const existingControls = document.getElementById('fullscreenControls');
				if (existingControls) existingControls.remove();
				
				// Find map-section or create if missing
				let mapSection = document.querySelector('.map-section');
				if (!mapSection) {
					mapSection = document.createElement('div');
					mapSection.className = 'map-section';
					
					const pageActive = document.querySelector('.page.active');
					if (pageActive) {
						pageActive.appendChild(mapSection);
					}
				}
				
				// Move map-container back to map-section
				if (mapContainer && mapSection) {
					mapSection.appendChild(mapContainer);
				}
				
				// Reset map-container styles
				if (mapContainer) {
					mapContainer.removeAttribute('style');
				}
				
				// Move ORIGINAL buttons below map (not create new ones)
				moveOriginalButtonsBelowMap(mapSection);
				
				// Remove fullscreen class
				body.classList.remove('fullscreen-active');
				if (mapControls) {
					mapControls.classList.remove('fullscreen-controls');
				}
				
				// Update button
				fullscreenBtn.innerHTML = `<i class="fas fa-expand"></i> <span data-translate="fullscreen">${currentLanguage === 'th' ? 'เต็มจอ' : 'Fullscreen'}</span>`;
				isFullscreen = false;
				
				// Show notification
				showNotification(
					currentLanguage === 'th' ? '📱 ออกจากโหมดเต็มจอ' : '📱 Exited fullscreen mode',
					'info'
				);
				
			} else {
				// ========== ENTER FULLSCREEN ==========
				console.log('Entering fullscreen mode...');
				
				// Move map-container to body
				if (mapContainer) {
					document.body.appendChild(mapContainer);
				}
				
				body.classList.add('fullscreen-active');
				
				// Create Enhanced Fullscreen Controls (3 buttons)
				const controls = document.createElement('div');
				controls.id = 'fullscreenControls';
				controls.style.cssText = `
					position: fixed !important;
					top: 20px !important;
					right: 20px !important;
					z-index: 99999 !important;
					background: rgba(255,255,255,0.95) !important;
					padding: 12px !important;
					border-radius: 10px !important;
					box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
					backdrop-filter: blur(10px) !important;
					display: flex !important;
					gap: 8px !important;
					opacity: 1 !important;
					visibility: visible !important;
				`;
				
				// Exit Button (Primary)
				const exitBtn = document.createElement('button');
				exitBtn.innerHTML = '🚪';
				exitBtn.title = 'ออกจากโหมดเต็มจอ';
				exitBtn.style.cssText = `
					padding: 8px 10px !important;
					background: linear-gradient(135deg, #667eea, #764ba2) !important;
					color: white !important;
					border: none !important;
					border-radius: 6px !important;
					cursor: pointer !important;
					font-size: 14px !important;
					font-weight: 600 !important;
					min-width: 40px !important;
					transition: background 0.2s ease !important;
				`;
				exitBtn.onmouseover = () => exitBtn.style.background = 'linear-gradient(135deg, #5a67d8, #667eea) !important';
				exitBtn.onmouseout = () => exitBtn.style.background = 'linear-gradient(135deg, #667eea, #764ba2) !important';
				exitBtn.onclick = () => toggleFullscreen();
				
				// Voice Control Button
				const voiceBtn = document.createElement('button');
				voiceBtn.innerHTML = '🎤';
				voiceBtn.title = 'เปิด/ปิดการสั่งงานด้วยเสียง';
				voiceBtn.style.cssText = `
					padding: 8px 10px !important;
					background: rgba(0,0,0,0.7) !important;
					color: white !important;
					border: none !important;
					border-radius: 6px !important;
					cursor: pointer !important;
					font-size: 14px !important;
					min-width: 40px !important;
					transition: background 0.2s ease !important;
				`;
				voiceBtn.onmouseover = () => voiceBtn.style.background = 'rgba(0,0,0,0.9) !important';
				voiceBtn.onmouseout = () => voiceBtn.style.background = 'rgba(0,0,0,0.7) !important';
				voiceBtn.onclick = () => {
					if (typeof toggleVoiceRecognition === 'function') {
						toggleVoiceRecognition();
					}
				};
				
				// Language Toggle Button
				const langBtn = document.createElement('button');
				langBtn.innerHTML = '🌐';
				langBtn.title = 'เปลี่ยนภาษา';
				langBtn.style.cssText = `
					padding: 8px 10px !important;
					background: rgba(0,0,0,0.7) !important;
					color: white !important;
					border: none !important;
					border-radius: 6px !important;
					cursor: pointer !important;
					font-size: 14px !important;
					min-width: 40px !important;
					transition: background 0.2s ease !important;
				`;
				langBtn.onmouseover = () => langBtn.style.background = 'rgba(0,0,0,0.9) !important';
				langBtn.onmouseout = () => langBtn.style.background = 'rgba(0,0,0,0.7) !important';
				langBtn.onclick = () => {
					if (typeof toggleLanguage === 'function') {
						toggleLanguage();
					}
				};
				
				// Add all buttons to controls
				controls.appendChild(exitBtn);
				controls.appendChild(voiceBtn);
				controls.appendChild(langBtn);
				document.body.appendChild(controls);
				
				// Update button text
				fullscreenBtn.innerHTML = `<i class="fas fa-compress"></i> <span data-translate="exit_fullscreen">${currentLanguage === 'th' ? 'ออกจากเต็มจอ' : 'Exit Fullscreen'}</span>`;
				isFullscreen = true;
				
				// Show notification
				showNotification(
					currentLanguage === 'th' ? '🖥️ เข้าโหมดเต็มจอ' : '🖥️ Entered fullscreen mode',
					'info'
				);
			}
		}

		// Helper function สำหรับย้ายปุ่มเดิม (ไม่สร้างใหม่)
		function moveOriginalButtonsBelowMap(mapSection) {
			   // หาปุ่มทั้ง 3 ปุ่มที่ใช้งานได้จริง
			const showRouteBtn = document.querySelector('#showRouteBtn, [onclick*="showRoute"], .btn-primary') || 
							Array.from(document.querySelectorAll('button')).find(btn => 
								btn.textContent.includes('แสดงเส้นทาง') && btn.style.display !== 'none');
							
			const clearRouteBtn = document.querySelector('#clearRouteBtn, [onclick*="clearRoute"], .btn-danger') || 
								 Array.from(document.querySelectorAll('button')).find(btn => 
									 btn.textContent.includes('ล้าง') && btn.style.display !== 'none');

			const voiceNavBtn = document.querySelector('#voiceNavBtn, [onclick*="voice"], .btn-success') || 
							   Array.from(document.querySelectorAll('button')).find(btn => 
								   btn.textContent.includes('เสียง') && btn.style.display !== 'none');

			if (mapSection && (clearRouteBtn || voiceNavBtn)) {
				// ลบ container เก่าถ้ามี (ที่มีปุ่ม copy)
				const oldContainer = document.getElementById('map-bottom-buttons');
				if (oldContainer) {
					oldContainer.remove();
				}
				
				// สร้าง container ใหม่สำหรับปุ่มเดิม
				const buttonContainer = document.createElement('div');
				buttonContainer.id = 'map-bottom-buttons';
				buttonContainer.style.cssText = `
					display: flex !important;
					justify-content: center !important;
					gap: 15px !important;
					margin: 20px 0 !important;
					padding: 15px !important;
					background: transparent !important;
					flex-wrap: wrap !important; //อาจจะลบทิ้งได้
				`;
				 
				
				mapSection.appendChild(buttonContainer);
				
				 // ย้ายปุ่มแสดงเส้นทาง (น้ำเงิน)
				if (showRouteBtn) {
					showRouteBtn.style.cssText += `
						margin: 0 !important;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
						transition: all 0.2s ease !important;
					`;
					buttonContainer.appendChild(showRouteBtn);
				}
				
				// ย้ายปุ่มล้างเส้นทาง (แดง)
				if (clearRouteBtn) {
					// เพิ่ม styling เล็กน้อยให้ปุ่มเดิม
					clearRouteBtn.style.cssText += `
						margin: 0 !important;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
						transition: all 0.2s ease !important;
					`;
					
					// ย้ายปุ่มเดิมไปยัง container ใหม่
					buttonContainer.appendChild(clearRouteBtn);
				}
				
				// ย้ายปุ่มนำทางด้วยเสียง (เขียว)
				if (voiceNavBtn) {
					// เพิ่ม styling เล็กน้อยให้ปุ่มเดิม
					voiceNavBtn.style.cssText += `
						margin: 0 !important;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
						transition: all 0.2s ease !important;
					`;
					
					// ย้ายปุ่มเดิมไปยัง container ใหม่
					buttonContainer.appendChild(voiceNavBtn);
				}
				
				console.log('Moved original buttons below map');
			}
		}

		// 🎹 Keyboard shortcut - ESC key support
		document.addEventListener('keydown', function(event) {
			if (event.key === 'Escape' && isFullscreen) {
				toggleFullscreen();
			}
		});
		
		
		function createEnhancedFullscreenControlsPatch() {
			const controls = document.createElement('div');
			controls.id = 'fullscreenControls';
			controls.style.cssText = `
				position: fixed !important;
				top: 20px !important;
				right: 20px !important;
				z-index: 99999 !important;
				background: rgba(255,255,255,0.95) !important;
				padding: 12px !important;
				border-radius: 10px !important;
				box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
				backdrop-filter: blur(10px) !important;
				display: flex !important;
				gap: 8px !important;
				opacity: 1 !important;
				visibility: visible !important;
			`;
			
			// Exit Button
			const exitBtn = document.createElement('button');
			exitBtn.innerHTML = '🚪';
			exitBtn.title = 'ออกจากโหมดเต็มจอ';
			exitBtn.style.cssText = `
				padding: 8px 10px !important;
				background: linear-gradient(135deg, #667eea, #764ba2) !important;
				color: white !important;
				border: none !important;
				border-radius: 6px !important;
				cursor: pointer !important;
				font-size: 14px !important;
				font-weight: 600 !important;
			`;
			exitBtn.onclick = () => toggleFullscreen();
			
			// Voice Button
			const voiceBtn = document.createElement('button');
			voiceBtn.innerHTML = '🎤';
			voiceBtn.title = 'เปิด/ปิดการสั่งงานด้วยเสียง';
			voiceBtn.style.cssText = `
				padding: 8px 10px !important;
				background: rgba(0,0,0,0.7) !important;
				color: white !important;
				border: none !important;
				border-radius: 6px !important;
				cursor: pointer !important;
				font-size: 14px !important;
			`;
			voiceBtn.onclick = () => {
				if (typeof toggleVoiceRecognition === 'function') {
					toggleVoiceRecognition();
				}
			};
			
			// Language Button
			const langBtn = document.createElement('button');
			langBtn.innerHTML = '🌐';
			langBtn.title = 'เปลี่ยนภาษา';
			langBtn.style.cssText = `
				padding: 8px 10px !important;
				background: rgba(0,0,0,0.7) !important;
				color: white !important;
				border: none !important;
				border-radius: 6px !important;
				cursor: pointer !important;
				font-size: 14px !important;
			`;
			langBtn.onclick = () => {
				if (typeof toggleLanguage === 'function') {
					toggleLanguage();
				}
			};
			
			controls.appendChild(exitBtn);
			controls.appendChild(voiceBtn);
			controls.appendChild(langBtn);
			document.body.appendChild(controls);
			
			return controls;
		}

		// ========== PATCH 2: เพิ่ม .map-section ที่หายไป ==========
		// เพิ่ม function นี้และเรียกใช้ใน toggleFullscreen
		function ensureMapSectionExistsPatch() {
			let mapSection = document.querySelector('.map-section');
			if (!mapSection) {
				mapSection = document.createElement('div');
				mapSection.className = 'map-section';
				
				const mapContainer = document.querySelector('.map-container');
				if (mapContainer && mapContainer.parentElement) {
					mapContainer.parentElement.insertBefore(mapSection, mapContainer);
					mapSection.appendChild(mapContainer);
				}
			}
			return mapSection;
		}

		// ========== PATCH 3: แก้ไข Exit Logic ให้ย้าย DOM ถูกต้อง ==========
		// เพิ่ม function นี้สำหรับ exit fullscreen
		function exitFullscreenPatch() {
			// Remove existing controls
			const existingControls = document.getElementById('fullscreenControls');
			if (existingControls) {
				existingControls.remove();
			}
			
			// ตรวจสอบให้แน่ใจว่ามี map-section
			const mapSection = ensureMapSectionExistsPatch();
			const mapContainer = document.querySelector('.map-container');
			
			// ย้าย map-container กลับไปที่ map-section
			if (mapContainer && mapSection && !mapSection.contains(mapContainer)) {
				mapSection.appendChild(mapContainer);
			}
			
			// Reset inline styles
			if (mapContainer) {
				mapContainer.style.position = '';
				mapContainer.style.top = '';
				mapContainer.style.left = '';
				mapContainer.style.width = '';
				mapContainer.style.height = '';
				mapContainer.style.zIndex = '';
			}
		}
		// ========== End of  PATCH =====================================
		
        // =================== FIX 2: Route Persistence Functions ===================
      // ===== 4. ปรับปรุงฟังก์ชัน showRouteToSelected() ให้ทำงานได้เร็วขึ้น =====
		function showRouteToSelected() {
			console.log('🛣️ Showing route to selected room...');
			
			// ตรวจสอบจุดหมายจาก persistent storage ก่อน
			if (!selectedRoom && persistentDestination.roomCode) {
				selectedRoom = persistentDestination.roomCode;
				console.log('🎯 Using persistent destination:', persistentDestination.roomName);
			}
			
			if (!selectedRoom || !roomData[selectedRoom]) {
				const selectMessage = currentLanguage === 'th' 
					? '❌ กรุณาเลือกห้องปลายทางก่อน'
					: '❌ Please select a destination room first';
				showNotification(selectMessage, 'error');
				return;
			}
			
			if (!startPoint || startPoint.x === null || startPoint.y === null) {
				const startMessage = currentLanguage === 'th' 
					? '❌ กรุณาคลิกที่แผนที่เพื่อกำหนดจุดเริ่มต้น'
					: '❌ Please click on map to set starting point';
				showNotification(startMessage, 'error');
				return;
			}
			
			// ลบเส้นทางเดิมอย่างสมบูรณ์
			document.querySelectorAll('.route-line, .route-marker, .route-animated, .route-line-animated').forEach(el => el.remove());
			const routePath = document.getElementById('routePath');
			if (routePath) {
				routePath.innerHTML = '';
			}
			
			// อัปเดต persistent destination เพื่อให้แน่ใจ
			if (selectedRoom !== persistentDestination.roomCode) {
				saveDestination(selectedRoom);
			}
			
			const room = roomData[selectedRoom];
			currentRoute = { start: startPoint, destination: room };
			
			console.log('🔍 Creating route from:', startPoint, 'to:', room);
			
			// แสดงเส้นทางใหม่
			showStraightRoutePath(startPoint, room);
			routeBtn.disabled = false;
            routeBtn.innerHTML = `<i class="fas fa-route"></i> <span data-translate="route_navigation">${currentLanguage === 'th' ? 'เส้นทางนำทาง' : 'Route Navigation'}</span>`;
			 
			
			// 🔥 อัปเดต state และ controls
			routeDisplayed = true;
			updateRouteControls(true);  // ส่ง true เพราะตอนนี้มีเส้นทางแสดงแล้ว
			updateRoomMarkers();
			
			// แสดงข้อความยืนยัน
			const message = currentLanguage === 'th' 
				? `🛣️ แสดงเส้นทางไปยัง ${room.name}`
				: `🛣️ Route shown to ${room.name}`;
			showNotification(message, 'success');
			
			console.log('✅ Route displayed. New state:', {
				routeDisplayed,
				currentRoute: !!currentRoute,
				selectedRoom
			});
		}
		
		// แก้ไข ensureRoutePath function
		 function ensureRoutePath() {
			let routePath = document.getElementById('routePath');
			
			if (!routePath) {
				const mapContainer = document.getElementById('mapArea') || 
								   document.querySelector('.map-area') ||
								   document.querySelector('.map-container');
				
				if (mapContainer) {
					routePath = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
					routePath.id = 'routePath';
					routePath.className = 'route-path';
					
					// 🔧 FIX: ใช้ #mapImage ที่ถูกต้อง แทน querySelector('img')
					const mapImage = document.getElementById('mapImage') || 
									document.querySelector('.map-image');
					
					let viewBoxWidth = 800;
					let viewBoxHeight = 600;
					
					if (mapImage) {
						viewBoxWidth = mapImage.naturalWidth || mapImage.offsetWidth || 800;
						viewBoxHeight = mapImage.naturalHeight || mapImage.offsetHeight || 600;
						console.log('📐 Using correct map image dimensions:', { viewBoxWidth, viewBoxHeight });
					} else {
						console.log('⚠️ Using default viewBox dimensions');
					}
					
					// 🔧 FIX: เพิ่ม viewBox ที่ถูกต้อง
					routePath.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
					routePath.setAttribute('preserveAspectRatio', 'xMidYMid meet');
					
					routePath.style.position = 'absolute';
					routePath.style.top = '0';
					routePath.style.left = '0';
					routePath.style.width = '100%';
					routePath.style.height = '100%';
					routePath.style.pointerEvents = 'none';
					routePath.style.zIndex = '10';
					
					mapContainer.appendChild(routePath);
					
					console.log('✅ Created routePath with viewBox:', routePath.getAttribute('viewBox'));
				}
			} else {
				// 🔧 FIX: แก้ไข routePath ที่มีอยู่แล้วถ้าไม่มี viewBox
				if (!routePath.getAttribute('viewBox')) {
					const mapImage = document.getElementById('mapImage') || 
									document.querySelector('.map-image');
					
					const viewBoxWidth = mapImage?.naturalWidth || mapImage?.offsetWidth || 800;
					const viewBoxHeight = mapImage?.naturalHeight || mapImage?.offsetHeight || 600;
					
					routePath.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
					routePath.setAttribute('preserveAspectRatio', 'xMidYMid meet');
					
					console.log('🔧 Fixed existing routePath viewBox:', routePath.getAttribute('viewBox'));
				}
			}
			
			return routePath;
		}

        // ========== 2. แก้ไข showStraightRoutePath function ==========
		function showStraightRoutePath(start, destination) {
			try {
				console.log('🎨 Creating route with FIXED coordinate system...');
				console.log('📍 Input coordinates:', { start, destination });
				
				// ล้าง route elements เก่า
				document.querySelectorAll('.route-line, .route-marker, .route-line-border, .route-start-marker, .route-end-marker, .route-waypoint').forEach(el => el.remove());
				
				let routePath = ensureRoutePath();
				if (!routePath) {
					console.error('❌ Cannot create route path SVG');
					return;
				}
				
				// ล้างเนื้อหาเดิม
				routePath.innerHTML = '';
				routePath.style.display = 'block';
				
				// ใช้ coordinates โดยตรง
				const startX = start.x;
				const startY = start.y;
				const endX = destination.x;
				const endY = destination.y;
				
				console.log('🎯 Final coordinates:', { startX, startY, endX, endY });
				console.log('📐 ViewBox:', routePath.getAttribute('viewBox'));
				
				// สร้างเส้นขาว (background)
				const borderLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
				borderLine.className = 'route-line-border';
				borderLine.setAttribute('x1', startX);
				borderLine.setAttribute('y1', startY);
				borderLine.setAttribute('x2', endX);
				borderLine.setAttribute('y2', endY);
				borderLine.setAttribute('stroke', '#ffffff');
				borderLine.setAttribute('stroke-width', '6');
				borderLine.setAttribute('opacity', '0.8');
				borderLine.setAttribute('stroke-linecap', 'round');
				routePath.appendChild(borderLine);
				
				// สร้างเส้นหลัก
				const mainLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
				mainLine.className = 'route-line-animated';
				mainLine.setAttribute('x1', startX);
				mainLine.setAttribute('y1', startY);
				mainLine.setAttribute('x2', endX);
				mainLine.setAttribute('y2', endY);
				mainLine.setAttribute('stroke', '#dc3545');
				mainLine.setAttribute('stroke-width', '3');
				mainLine.setAttribute('stroke-dasharray', '8 4');
				mainLine.setAttribute('stroke-linecap', 'round');
				routePath.appendChild(mainLine);
				
				// จุดเริ่มต้น
				const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				startMarker.className = 'route-start-marker';
				startMarker.setAttribute('cx', startX);
				startMarker.setAttribute('cy', startY);
				startMarker.setAttribute('r', '8');
				startMarker.setAttribute('fill', '#28a745');
				startMarker.setAttribute('stroke', '#ffffff');
				startMarker.setAttribute('stroke-width', '2');
				routePath.appendChild(startMarker);
				
				// จุดปลายทาง
				const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				endMarker.className = 'route-end-marker';
				endMarker.setAttribute('cx', endX);
				endMarker.setAttribute('cy', endY);
				endMarker.setAttribute('r', '10');
				endMarker.setAttribute('fill', '#dc3545');
				endMarker.setAttribute('stroke', '#ffffff');
				endMarker.setAttribute('stroke-width', '2');
				routePath.appendChild(endMarker);
				
				console.log('✅ Fixed route created with', routePath.children.length, 'elements');
				
				// แสดง notification
				const routeMessage = typeof currentLanguage !== 'undefined' && currentLanguage === 'th' 
					? '🛣️ แสดงเส้นทางเรียบร้อยแล้ว' 
					: '🛣️ Route displayed successfully';
				
				if (typeof showNotification === 'function') {
					showNotification(routeMessage, 'success');
				}
				
				return true;
				
			} catch (error) {
				console.error('❌ Error creating fixed route:', error);
				
				const errorMessage = typeof currentLanguage !== 'undefined' && currentLanguage === 'th' 
					? 'เกิดข้อผิดพลาดในการแสดงเส้นทาง'
					: 'Error displaying route';
					
				if (typeof showNotification === 'function') {
					showNotification(errorMessage, 'error');
				}
				
				return false;
			}
		}
		
		// เพิ่มใน initializeSystem() หลังจาก setMapLayout('floorplan');
		function ensureRouteAnimationCSS() {
			if (document.getElementById('route-animation-styles')) return;
			
			const style = document.createElement('style');
			style.id = 'route-animation-styles';
			style.textContent = `
				@keyframes route-dash {
					0% { stroke-dashoffset: 0; }
					100% { stroke-dashoffset: -24; }
				}
				
				.route-line-animated {
					animation: route-dash 2s linear infinite;
				}
				
				.route-start-marker, .route-end-marker {
					filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
					transition: all 0.3s ease;
				}
				
				.route-line-border {
					filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
				}
				
				.route-start-marker:hover, .route-end-marker:hover {
					transform: scale(1.2);
				}
			`;
			
			document.head.appendChild(style);
			console.log('✅ Animation CSS added');
		}

		// เรียกใช้ฟังก์ชัน
		ensureRouteAnimationCSS();
		
		 
		
		// v1.1 เพิ่มฟังก์ชันสำหรับสร้าง CSS animation
		function ensureAnimationCSS() {
			// ตรวจสอบว่ามี animation CSS แล้วหรือไม่
			if (document.head.querySelector('style[data-route-animation]')) {
				return;
			}
			
			// สร้าง CSS animation
			const style = document.createElement('style');
			style.setAttribute('data-route-animation', 'true');
			style.textContent = `
				/* Route Animation Styles */
				@keyframes route-dash {
					0% { 
						stroke-dashoffset: 0; 
					}
					100% { 
						stroke-dashoffset: -30; 
					}
				}
				
				.route-line-animated {
					animation: route-dash 3s linear infinite;
				}
				
				/* Enhanced Route Styles */
				.route-path {
					position: absolute;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					pointer-events: none;
					z-index: 10;
				}
				
				.route-marker-enhanced {
					animation: route-marker-pulse 2s ease-in-out infinite;
				}
				
				@keyframes route-marker-pulse {
					0%, 100% { 
						opacity: 0.8;
						transform: scale(1);
					}
					50% { 
						opacity: 1;
						transform: scale(1.2);
					}
				}
			`;
			
			document.head.appendChild(style);
			console.log('✅ Animation CSS added to document');
		}
		
		
		
		// v1.1 เพิ่มฟังก์ชันสำหรับสร้าง route markers
		// ซ่อน start point ใน route markers ด้วย
		function addRouteMarkers(startPoint, endPoint) {
			const routePath = document.getElementById('routePath');
			if (!routePath) return;
			
			// แสดงเฉพาะ End marker (จุดปลายทาง)
			const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			endMarker.setAttribute('cx', endPoint.x);
			endMarker.setAttribute('cy', endPoint.y);
			endMarker.setAttribute('r', '1.2');
			endMarker.setAttribute('fill', '#dc3545');
			endMarker.setAttribute('stroke', '#fff');
			endMarker.setAttribute('stroke-width', '0.3');
			endMarker.setAttribute('class', 'route-marker route-marker-enhanced');
			routePath.appendChild(endMarker);
			
			// ไม่แสดง start marker
			debugLog('🎯 Only destination marker shown, start point hidden');
		}
		
		// ========== 2. Fixed 6x6 Walkable Grid System ==========

		// Fixed walkable grid data structure
		const FIXED_WALKABLE_GRID = {
			// การตั้งค่าหลัก
			config: {
				gridSize: 6,           // 6x6 grid
				totalNodes: 36,        // 36 nodes หลัก
				extraNodes: 12,        // 12 nodes เพิ่มเติม (กลาง, มุม, ทางผ่าน)
				connectionRadius: 35,  // 35% radius
				maxConnections: 5,     // เชื่อมต่อสูงสุด 5 จุด
				minConnections: 3      // เชื่อมต่อขั้นต่ำ 3 จุด
			},
			
			// Fixed node positions - คำนวณล่วงหน้าเพื่อประสิทธิภาพ
			nodePositions: null,
			edgeConnections: null,
			isGenerated: false
		};

		// สร้าง Fixed Grid Positions
		function generateFixedGridPositions() {
			if (FIXED_WALKABLE_GRID.isGenerated) {
				return FIXED_WALKABLE_GRID.nodePositions;
			}
			
			debugLog('🏗️ Generating fixed 6x6 walkable grid...');
			
			const positions = [];
			let nodeId = 1;
			
			// 1. สร้าง Main Grid 6x6 (36 nodes)
			const gridSpacing = 80 / (FIXED_WALKABLE_GRID.config.gridSize - 1); // 16% spacing
			
			for (let row = 0; row < FIXED_WALKABLE_GRID.config.gridSize; row++) {
				for (let col = 0; col < FIXED_WALKABLE_GRID.config.gridSize; col++) {
					const x = 10 + (col * gridSpacing);  // 10% margin, then 16% spacing
					const y = 10 + (row * gridSpacing);  // 10% margin, then 16% spacing
					
					positions.push({
						id: nodeId.toString(),
						x: Math.round(x * 10) / 10,  // round to 1 decimal
						y: Math.round(y * 10) / 10,
						type: 'grid',
						gridRow: row,
						gridCol: col
					});
					nodeId++;
				}
			}
			
			// 2. เพิ่ม Strategic Nodes (12 nodes เพิ่มเติม)
			const strategicNodes = [
				// Center cluster (4 nodes)
				{x: 50, y: 50, type: 'center'},     // แท้จริงกลาง
				{x: 45, y: 50, type: 'center'},     // กลาง-ซ้าย
				{x: 55, y: 50, type: 'center'},     // กลาง-ขวา
				{x: 50, y: 45, type: 'center'},     // กลาง-บน
				
				// Corridor nodes (4 nodes)
				{x: 25, y: 50, type: 'corridor'},   // ทางผ่านซ้าย
				{x: 75, y: 50, type: 'corridor'},   // ทางผ่านขวา
				{x: 50, y: 25, type: 'corridor'},   // ทางผ่านบน
				{x: 50, y: 75, type: 'corridor'},   // ทางผ่านล่าง
				
				// Corner connectors (4 nodes)
				{x: 20, y: 20, type: 'corner'},     // มุมซ้ายบน
				{x: 80, y: 20, type: 'corner'},     // มุมขวาบน
				{x: 20, y: 80, type: 'corner'},     // มุมซ้ายล่าง
				{x: 80, y: 80, type: 'corner'}      // มุมขวาล่าง
			];
			
			strategicNodes.forEach(node => {
				positions.push({
					id: nodeId.toString(),
					x: node.x,
					y: node.y,
					type: node.type
				});
				nodeId++;
			});
			
			FIXED_WALKABLE_GRID.nodePositions = positions;
			
			debugLog('✅ Fixed grid positions generated:', {
				totalNodes: positions.length,
				gridNodes: positions.filter(n => n.type === 'grid').length,
				strategicNodes: positions.filter(n => n.type !== 'grid').length
			});
			
			return positions;
		}

		// สร้าง Fixed Edge Connections
		function generateFixedEdgeConnections(positions) {
			debugLog('🔗 Generating fixed edge connections...');
			
			const edges = [];
			const config = FIXED_WALKABLE_GRID.config;
			
			for (let i = 0; i < positions.length; i++) {
				const nodeA = positions[i];
				const connections = [];
				
				// หาทุกจุดที่อยู่ในรัศมี
				for (let j = 0; j < positions.length; j++) {
					if (i === j) continue;
					
					const nodeB = positions[j];
					const distance = distanceBetweenPoints(nodeA, nodeB);
					
					if (distance <= config.connectionRadius) {
						connections.push({
							targetNode: nodeB,
							distance: distance,
							weight: distance * walkableRoutingData.settings.metersPerPercent
						});
					}
				}
				
				// เรียงตามระยะทางและเลือกเชื่อมต่อ
				connections.sort((a, b) => a.distance - b.distance);
				
				// เชื่อมต่อกับ 3-5 จุดที่ใกล้ที่สุด
				const connectCount = Math.min(
					Math.max(config.minConnections, connections.length),
					config.maxConnections
				);
				
				for (let k = 0; k < connectCount; k++) {
					const conn = connections[k];
					
					// ตรวจสอบว่ามี edge นี้แล้วหรือไม่ (bidirectional)
					const existingEdge = edges.find(edge => 
						(edge.from === nodeA.id && edge.to === conn.targetNode.id) ||
						(edge.from === conn.targetNode.id && edge.to === nodeA.id)
					);
					
					if (!existingEdge) {
						edges.push({
							from: nodeA.id,
							to: conn.targetNode.id,
							weight: conn.weight,
							distance: conn.distance,
							bidirectional: true,
							type: 'fixed'
						});
					}
				}
			}
			
			FIXED_WALKABLE_GRID.edgeConnections = edges;
			
			debugLog('✅ Fixed edge connections generated:', {
				totalEdges: edges.length,
				avgConnectionsPerNode: (edges.length * 2 / positions.length).toFixed(1)
			});
			
			return edges;
		}
		
		// แทนที่ฟังก์ชัน createRobustSampleWalkableData เดิม
		function createFixedWalkableGrid() {
			debugLog('🏗️ Creating fixed walkable grid (preparing for Google Sheets integration)...');
			
			// Clear existing data
			walkableRoutingData.nodes = {};
			walkableRoutingData.edges = [];
			
			// Generate fixed positions
			const positions = generateFixedGridPositions();
			const edges = generateFixedEdgeConnections(positions);
			
			// Convert to walkableRoutingData format
			positions.forEach(pos => {
				walkableRoutingData.nodes[pos.id] = {
					id: pos.id,
					x: pos.x,
					y: pos.y,
					type: pos.type || 'grid',
					building: walkableRoutingData.currentBuilding,
					isFixed: true  // flag สำหรับระบุว่าเป็น fixed node
				};
			});
			
			walkableRoutingData.edges = edges.map(edge => ({
				from: edge.from,
				to: edge.to,
				weight: edge.weight,
				bidirectional: edge.bidirectional,
				type: edge.type,
				isFixed: true  // flag สำหรับระบุว่าเป็น fixed edge
			}));
			
			FIXED_WALKABLE_GRID.isGenerated = true;
			
			// Statistics
			const stats = {
				totalNodes: Object.keys(walkableRoutingData.nodes).length,
				totalEdges: walkableRoutingData.edges.length,
				gridNodes: positions.filter(n => n.type === 'grid').length,
				strategicNodes: positions.filter(n => n.type !== 'grid').length,
				avgConnections: (walkableRoutingData.edges.length * 2 / positions.length).toFixed(1),
				coverage: '100%'  // ครอบคลุมทั้งแผนที่
			};
			
			debugLog('✅ Fixed walkable grid created:', stats);
			
			// บันทึกลง localStorage สำหรับใช้งานต่อไป
			try {
				const building = getCurrentBuilding();
				const storageKey = `walkableData_${building}`;
				const dataToSave = {
					nodes: walkableRoutingData.nodes,
					edges: walkableRoutingData.edges,
					settings: walkableRoutingData.settings,
					gridInfo: {
						type: 'fixed_grid',
						version: '1.0',
						generated: new Date().toISOString(),
						stats: stats
					},
					timestamp: new Date().toISOString()
				};
				localStorage.setItem(storageKey, JSON.stringify(dataToSave));
				debugLog('💾 Fixed grid data saved to localStorage');
			} catch (error) {
				console.warn('⚠️ Could not save fixed grid to localStorage:', error);
			}
			
			return stats;
		}
		 

		// เพิ่มฟังก์ชันสำหรับลูกศรทิศทาง
		function addDirectionArrow(startX, startY, endX, endY, svgElement) {
			try {
				// คำนวณจุดกึ่งกลาง
				const midX = (startX + endX) / 2;
				const midY = (startY + endY) / 2;
				
				// คำนวณมุม
				const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
				
				// สร้างลูกศร
				const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
				arrow.setAttribute('points', '-1.5,0 1.5,-1 1.5,1');
				arrow.setAttribute('fill', '#dc3545');
				arrow.setAttribute('stroke', '#fff');
				arrow.setAttribute('stroke-width', '0.5');
				arrow.setAttribute('transform', `translate(${midX}, ${midY}) rotate(${angle})`);
				arrow.className = 'route-marker route-marker-enhanced';
				
				svgElement.appendChild(arrow);
				
			} catch (error) {
				console.warn('⚠️ Could not add direction arrow:', error);
			}
		}
		
		// ===== 7. เพิ่มฟังก์ชันอัปเดตการแสดงผลจุดหมาย =====
		function updateDestinationDisplay() {
			const statusElement = document.getElementById('destinationStatus');
			const textElement = document.getElementById('destinationText');
			
			if (!statusElement || !textElement) return;
			
			if (persistentDestination.roomCode && roomData[persistentDestination.roomCode]) {
				const displayText = currentLanguage === 'th' 
					? `จุดหมาย: ${persistentDestination.roomName}`
					: `Destination: ${persistentDestination.roomName}`;
				
				textElement.textContent = displayText;
				statusElement.style.display = 'block';
			} else {
				statusElement.style.display = 'none';
			}
		}
		
		
		// v1.1 เพิ่มฟังก์ชันตรวจสอบ map container
		function ensureMapContainer() {
			let mapContainer = document.getElementById('mapContainer');
			
			if (!mapContainer) {
				// ลองหา container อื่น
				mapContainer = document.querySelector('.map-area') || 
							  document.querySelector('.map-container') ||
							  document.querySelector('#mapArea');
			}
			
			if (!mapContainer) {
				console.error('❌ No map container found in DOM');
				return null;
			}
			
			// ตรวจสอบว่า container มี style ที่เหมาะสม
			if (!mapContainer.style.position || mapContainer.style.position === 'static') {
				mapContainer.style.position = 'relative';
			}
			
			return mapContainer;
		}
		
		 

       // ===== v1.1 แก้ไข clearRoute() ให้ชัดเจนขึ้น =====
		function clearRoute() {
			console.log('🗑️ Clearing route...');
			
			// ลบทุก element ที่เกี่ยวข้องกับเส้นทาง
			const routeSelectors = [
				'.route-line', 
				'.route-marker', 
				'.route-path',
				'.route-step-marker',
				'.navigation-marker',
				'[data-route="true"]',
				'.route-animated',
				'.route-line-animated',
				'.route-marker-enhanced',
				'.destination-marker',              // เพิ่ม
				'.destination-label',               // เพิ่ม
				'.waypoint-group',                  // เพิ่ม
				'.route-line-glow',                 // เพิ่ม
				'[data-marker-type="destination"]', // เพิ่ม
				'path[stroke="#dc3545"]',
				'circle[fill="#28a745"]',
				'circle[fill="#dc3545"]'
			];
			
			let removedCount = 0;
			routeSelectors.forEach(selector => {
				document.querySelectorAll(selector).forEach(el => {
					el.remove();
					removedCount++;
				});
			});
			
			// ลบหรือซ่อน routePath
			const routePath = document.getElementById('routePath');
			if (routePath) {
				routePath.innerHTML = '';
				routePath.style.display = 'none';
			}
			
			// รีเซ็ต route state
			routeDisplayed = false;
			currentRoute = null;
			
			// อัพเดท UI controls
			setTimeout(() => {
				updateRouteControls(); 
			}, 100);
			
			console.log(`✅ Route cleared completely (${removedCount} elements removed)`);
			
			const clearMessage = currentLanguage === 'th' 
				? '🗑️ ลบเส้นทางแล้ว (จุดหมายยังคงอยู่)'
				: '🗑️ Route cleared (destination preserved)';
			showNotification(clearMessage, 'info');
		}		
		
		
		// ===== 6. เพิ่มฟังก์ชันตรวจสอบและแก้ไข state =====
		function validateAndFixRouteState() {
			console.log('🔍 Validating route state...');
			
			// ตรวจสอบ localStorage
			try {
				const savedDestination = localStorage.getItem('persistentDestination');
				const savedStartPoint = localStorage.getItem('startPoint');
				
				if (savedDestination) {
					const parsed = JSON.parse(savedDestination);
					if (parsed.roomCode && roomData[parsed.roomCode]) {
						persistentDestination = parsed;
						selectedRoom = parsed.roomCode;
						console.log('✅ Restored destination from localStorage:', parsed.roomName);
					} else {
						// ข้อมูลเสียหาย ล้างออก
						localStorage.removeItem('persistentDestination');
						clearDestination();
					}
				}
				
				if (savedStartPoint) {
					const parsed = JSON.parse(savedStartPoint);
					if (parsed.x !== null && parsed.y !== null) {
						startPoint = parsed;
						console.log('✅ Restored start point from localStorage:', parsed);
					}
				}
				
			} catch (error) {
				console.error('❌ Error validating state:', error);
				// ล้างข้อมูลที่เสียหาย
				localStorage.removeItem('persistentDestination');
				localStorage.removeItem('startPoint');
				clearDestination();
				startPoint = null;
			}
			
			// อัปเดต UI
			updateDestinationDisplay();
			updateRouteControls(routeDisplayed);
			
			console.log('🎯 Final state:', {
				selectedRoom,
				persistentDestination: persistentDestination.roomCode,
				startPoint: startPoint ? `(${Math.round(startPoint.x)}, ${Math.round(startPoint.y)})` : null
			});
		}

        function generateCompleteRoute() {
            showRouteToSelected();
        }

        // Remove old curved path and replace with simple straight line
        function showModernRoutePath(start, destination) {
            // Use the new straight path function
            showStraightRoutePath(start, destination);
        }

        function hideRoutePath() {
            const routePath = document.getElementById('routePath');
            if (routePath) {
                routePath.style.display = 'none';
                routePath.innerHTML = '';
            }
        }

        // =================== FIX 3: Continuous Voice Navigation ===================
        
        function startContinuousVoiceNavigation() {
            if (!currentRoute) {
                const message = currentLanguage === 'th' 
                    ? '❌ ยังไม่มีเส้นทางสำหรับการนำทาง' 
                    : '❌ No route available for navigation';
                showNotification(message, 'error');
                return;
            }
            
            if (isVoiceNavigating) {
                stopVoiceNavigation();
                return;
            }
            
            if (!('speechSynthesis' in window)) {
                const message = currentLanguage === 'th' 
                    ? '❌ เบราว์เซอร์ไม่รองรับการอ่านเสียง' 
                    : '❌ Browser does not support speech synthesis';
                showNotification(message, 'error');
                return;
            }
            
            generateVoiceQueue();
            startVoiceSequence();
        }

        function generateVoiceQueue() {
            voiceQueue = [];
            
            if (!currentRoute) return;
            
            const { start, destination } = currentRoute;
            const deltaX = destination.x - start.x;
            const deltaY = destination.y - start.y;
            const distance = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 2);
            
            let direction = '';
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                direction = deltaX > 0 
                    ? (currentLanguage === 'th' ? 'ทางขวา' : 'to the right')
                    : (currentLanguage === 'th' ? 'ทางซ้าย' : 'to the left');
            } else {
                direction = deltaY > 0 
                    ? (currentLanguage === 'th' ? 'ด้านล่าง' : 'downward')
                    : (currentLanguage === 'th' ? 'ด้านบน' : 'upward');
            }
            
            if (currentLanguage === 'th') {
                voiceQueue = [
                    'เริ่มต้นการนำทาง',
                    `เดินไป${direction} ประมาณ ${distance} เมตร`,
                    `มองหาอาคาร ${destination.building}`,
                    `เข้าสู่ ${destination.name}`,
                    'ถึงจุดหมายแล้ว การนำทางเสร็จสิ้น'
                ];
            } else {
                voiceQueue = [
                    'Starting navigation',
                    `Walk ${direction} approximately ${distance} meters`,
                    `Look for building ${destination.building}`,
                    `Enter ${destination.name}`,
                    'Destination reached. Navigation complete'
                ];
            }
        }

        function startVoiceSequence() {
            if (voiceQueue.length === 0) return;
            
            isVoiceNavigating = true;
            updateVoiceButton(true);
            
            const message = currentLanguage === 'th' 
                ? '🔊 เริ่มการนำทางด้วยเสียง' 
                : '🔊 Starting voice navigation';
            showNotification(message, 'success');
            
            speakNextInQueue();
        }

        function speakNextInQueue() {
            if (voiceQueue.length === 0 || !isVoiceNavigating) {
                finishVoiceNavigation();
                return;
            }
            
            const text = voiceQueue.shift();
            
            if (currentSpeech) {
                speechSynthesis.cancel();
            }
            
            currentSpeech = new SpeechSynthesisUtterance(text);
            currentSpeech.lang = currentLanguage === 'th' ? 'th-TH' : 'en-US';
            currentSpeech.rate = 0.8;
            currentSpeech.pitch = 1.0;
            
            currentSpeech.onend = () => {
                if (isVoiceNavigating) {
                    // Wait 2 seconds before next instruction
                    voiceTimeout = setTimeout(() => {
                        speakNextInQueue();
                    }, 2000);
                }
            };
            
            currentSpeech.onerror = () => {
                finishVoiceNavigation();
            };
            
            speechSynthesis.speak(currentSpeech);
        }

        function stopVoiceNavigation() {
            isVoiceNavigating = false;
            voiceQueue = [];
            
            if (voiceTimeout) {
                clearTimeout(voiceTimeout);
                voiceTimeout = null;
            }
            
            if (currentSpeech) {
                speechSynthesis.cancel();
                currentSpeech = null;
            }
            
            updateVoiceButton(false);
            
            const message = currentLanguage === 'th' 
                ? '🔇 หยุดการนำทางด้วยเสียง' 
                : '🔇 Voice navigation stopped';
            showNotification(message, 'warning');
        }

        function finishVoiceNavigation() {
            isVoiceNavigating = false;
            updateVoiceButton(false);
            
            const message = currentLanguage === 'th' 
                ? '✅ การนำทางด้วยเสียงเสร็จสิ้น' 
                : '✅ Voice navigation completed';
            showNotification(message, 'success');
        }

        function updateVoiceButton(isActive) {
            const voiceBtn = document.getElementById('voiceNavigationBtn');
            if (!voiceBtn) return;
            
            if (isActive) {
                voiceBtn.classList.add('speaking');
                voiceBtn.innerHTML = `
                    <i class="fas fa-stop"></i> 
                    <span>${currentLanguage === 'th' ? 'หยุดเสียง' : 'Stop Voice'}</span>
                `;
            } else {
                voiceBtn.classList.remove('speaking');
                voiceBtn.innerHTML = `
                    <i class="fas fa-volume-up"></i> 
                    <span data-translate="voice_nav">${currentLanguage === 'th' ? 'นำทางด้วยเสียง' : 'Voice Navigation'}</span>
                `;
            }
        }

        // Legacy voice functions for compatibility
        function toggleVoiceNavigation() {
            if (isVoiceNavigating) {
                stopVoiceNavigation();
            } else {
                startContinuousVoiceNavigation();
            }
        }

        function speakStep(text) {
            if (!('speechSynthesis' in window)) {
                const message = currentLanguage === 'th' 
                    ? '❌ เบราว์เซอร์ไม่รองรับการอ่านเสียง' 
                    : '❌ Browser does not support speech synthesis';
                showNotification(message, 'error');
                return;
            }
            
            if (currentSpeech) {
                speechSynthesis.cancel();
            }
            
            currentSpeech = new SpeechSynthesisUtterance(text);
            currentSpeech.lang = currentLanguage === 'th' ? 'th-TH' : 'en-US';
            currentSpeech.rate = 0.8;
            currentSpeech.pitch = 1.0;
            
            speechSynthesis.speak(currentSpeech);
        }

        function speakText(text) {
            speakStep(text);
        }

        // =================== Room Markers ===================
        
        let selectedRoomForAction = null;
		// ======= Updated Room Markers - ไม่แสดง Pin ทั้งหมด =======
		function updateRoomMarkers() {
			const markersContainer = document.getElementById('roomMarkers');
			if (!markersContainer) return;
			
			// แสดงเฉพาะจุดเริ่มต้นและปลายทางที่เลือก
			let markersHTML = '';
			
			// แสดงจุดเริ่มต้น
			if (startPoint) {
				markersHTML += `
					<div class="room-marker start-point-marker" 
						 style="top: ${startPoint.y}%; left: ${startPoint.x}%;"
						 title="${currentLanguage === 'th' ? 'จุดเริ่มต้น' : 'Starting Point'}"
						 onclick="showStartPointInfo()">
						🚩
					</div>
				`;
			}
			
			// แสดงปลายทางที่เลือกจากการค้นหา
			if (selectedRoom && roomData[selectedRoom]) {
				const room = roomData[selectedRoom];
				markersHTML += `
					<div class="room-marker highlighted" 
						 data-room="${room.code}" 
						 style="top: ${room.y}%; left: ${room.x}%;"
						 title="${room.name}"
						 onclick="showRoomActionOverlay('${room.code}', event)">
						🎯
					</div>
				`;
			}
			
			markersContainer.innerHTML = markersHTML;
		}
        // ======= Updated Room Markers - version เก่าแสดง Pin ทั้งหมด =======
        function updateRoomMarkers_Old_ShowAllPinPoint() {
            const markersContainer = document.getElementById('roomMarkers');
            if (!markersContainer) return;
            
            let activeRooms = Object.values(roomData).filter(room => room.status === 'active');
            
            // FIX 5: Apply building filter
            if (currentBuildingFilter !== 'all') {
                activeRooms = activeRooms.filter(room => room.building === currentBuildingFilter);
            }
            
            markersContainer.innerHTML = activeRooms.map(room => {
                return `
                    <div class="room-marker" 
                         data-room="${room.code}" 
                         onclick="showRoomActionOverlay('${room.code}', event)" 
                         style="top: ${room.y}%; left: ${room.x}%;"
                         title="${room.name}">
                        ${getRoomIcon(room.name)}
                    </div>
                `;
            }).join('') + (startPoint ? `
                <div class="room-marker start-point-marker" 
                     style="top: ${startPoint.y}%; left: ${startPoint.x}%;"
                     title="${currentLanguage === 'th' ? 'จุดเริ่มต้น' : 'Starting Point'}"
                     onclick="showStartPointInfo()">
                    🚩
                </div>
            ` : '');
        }

        // 1.2: Show action overlay when clicking room marker
        // ======= Room Action Overlay Functions - ปรับปรุงให้ทำงานกับระบบใหม่ =======
		function showRoomActionOverlay(roomCode, event) {
			const room = roomData[roomCode];
			if (!room) return;
			
			selectedRoom = roomCode;
			
			const overlay = document.getElementById('roomActionOverlay');
			const header = document.getElementById('roomActionHeader');
			
			if (!overlay || !header) return;
			
			// อัปเดต header ด้วยชื่อห้อง
			header.textContent = `${room.name} - ${currentLanguage === 'th' ? 'เลือกการดำเนินการ' : 'Select Action'}`;
			
			overlay.style.display = 'block';
			
			// อัปเดตการแปลภาษาสำหรับปุ่มใน overlay
			updateActionOverlayTranslations();
			
			// ซ่อน overlay เมื่อคลิกข้างนอก
			setTimeout(() => {
				document.addEventListener('click', hideRoomActionOverlayOnClickOutside, { once: true });
			}, 100);
		}

        function hideRoomActionOverlayOnClickOutside(event) {
            const overlay = document.getElementById('roomActionOverlay');
            if (overlay && !overlay.contains(event.target) && !event.target.classList.contains('room-marker')) {
                overlay.style.display = 'none';
            }
        }

        function updateActionOverlayTranslations() {
            const buttons = document.querySelectorAll('#roomActionOverlay [data-translate]');
            buttons.forEach(button => {
                const key = button.getAttribute('data-translate');
                if (translations[currentLanguage] && translations[currentLanguage][key]) {
                    button.textContent = translations[currentLanguage][key];
                }
            });
        }

        // V1.1: Action functions
        function showRoomDetails() {
		
			 if (isFullscreen) {
				alert(currentLanguage === 'th' ? 
					'กรุณาออกจากโหมดเต็มจอ ก่อนดูรายละเอียด' : 
					'Please exit fullscreen mode first');
				return;
			}
	
            // 🔧 แก้ไข: ใช้ selectedRoom แทน selectedRoomForAction
			if (!selectedRoom) return;
            
            // Hide action overlay
            const overlay = document.getElementById('roomActionOverlay');
            if (overlay) overlay.style.display = 'none';
            
            // Show room info overlay
            showRoomInfoOverlay(selectedRoom);
        }

       function showRouteDirectly() {
			if (!selectedRoom) return;
			
			// ซ่อน action overlay
			const overlay = document.getElementById('roomActionOverlay');
			if (overlay) overlay.style.display = 'none';
			
			if (!startPoint) {
				const message = currentLanguage === 'th' 
					? '💡 คลิกที่แผนที่เพื่อตั้งจุดเริ่มต้นก่อน' 
					: '💡 Click on map to set starting point first';
				showNotification(message, 'info');
				return;
			}
			
			// แสดงเส้นทางโดยตรง
			showRouteToSelected();
		}

        function showStartPointInfo() {
            if (!startPoint) return;
            const message = currentLanguage === 'th' 
                ? `🚩 จุดเริ่มต้นการนำทาง` 
                : `🚩 Navigation starting point`;
            showNotification(message, 'info');
        }

        // =================== Room Info Functions ===================
        
        function getRoomTypeText(type) {
            const types = {
                'classroom': currentLanguage === 'th' ? 'ห้องเรียน' : 'Classroom',
                'computer': currentLanguage === 'th' ? 'ห้องคอมพิวเตอร์' : 'Computer Lab',
                'lab': currentLanguage === 'th' ? 'ห้องปฏิบัติการ' : 'Laboratory',
                'library': currentLanguage === 'th' ? 'ห้องสมุด' : 'Library',
                'office': currentLanguage === 'th' ? 'ห้องสำนักงาน' : 'Office',
                'facility': currentLanguage === 'th' ? 'สิ่งอำนวยความสะดวก' : 'Facility',
                'special': currentLanguage === 'th' ? 'ห้องพิเศษ' : 'Special Room'
            };
            return types[type] || type;
        }
        
        function showRoomInfoOverlay(roomCode) {
            const room = roomData[roomCode];
            if (!room) return;

            selectedRoom = roomCode;
            updateRouteControls(false);
            
            const overlay = document.getElementById('roomInfoOverlay');
            if (!overlay) return;
            
            const roomName = document.getElementById('overlayRoomName');
            const roomLocation = document.getElementById('overlayRoomLocation');
            const roomBuilding = document.getElementById('overlayRoomBuilding');
            const roomFloor = document.getElementById('overlayRoomFloor');
            const roomType = document.getElementById('overlayRoomType');
            const roomDescription = document.getElementById('overlayRoomDescription');
            const routeBtn = document.getElementById('routeBtn');
            
            if (roomName) roomName.innerHTML = `${getRoomIcon(room.name)} ${room.name}`;
            if (roomLocation) roomLocation.textContent = room.location || room.floor || 'N/A';
            
            // 1.3: Enhanced room information display (removed status)
            // Get building name from admin data
            const buildingData = JSON.parse(localStorage.getItem('buildingsData') || '{}');
            const buildingName = buildingData[room.building]?.name || room.building;
            if (roomBuilding) roomBuilding.textContent = buildingName;
            
            // Display floor information
            if (roomFloor) {
                const floorText = room.floor 
                    ? (currentLanguage === 'th' ? `ชั้น ${room.floor}` : `Floor ${room.floor}`)
                    : (currentLanguage === 'th' ? 'ไม่ระบุ' : 'Not specified');
                roomFloor.textContent = floorText;
            }
            
            // Display room type
            if (roomType) roomType.textContent = getRoomTypeText(room.type || 'classroom');
            
            // 1.3: Remove status display - no longer shown
            
            if (roomDescription) roomDescription.textContent = room.description || (currentLanguage === 'th' ? 'ไม่มีรายละเอียด' : 'No description available');
            
            // Update route button state
            if (routeBtn) {
                if (!startPoint) {
                    routeBtn.disabled = true;
                    routeBtn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> <span>${currentLanguage === 'th' ? 'ตั้งจุดเริ่มต้นก่อน' : 'Set start point first'}</span>`;
                } else {
                    routeBtn.disabled = false;
                    routeBtn.innerHTML = `<i class="fas fa-route"></i> <span data-translate="route_navigation">${currentLanguage === 'th' ? 'เส้นทางนำทาง' : 'Route Navigation'}</span>`;
                }
            }
            
            // Display all images 
			updateOverlayImageGallery(room); // v1.1 ส่ง room object ทั้งหมด
            generateOverlayNavigationSteps(room);
            
            overlay.style.display = 'flex';
        }

        function closeRoomInfoOverlay() {
            const overlay = document.getElementById('roomInfoOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            selectedRoom = null;
            updateRouteControls(false);
        }

        function generateOverlayNavigationSteps(room) {
            const routeSteps = document.getElementById('overlayRouteSteps');
            if (!routeSteps) return;
            
            if (!startPoint) {
                const noStartText = currentLanguage === 'th' 
                    ? 'คลิกที่แผนที่เพื่อตั้งจุดเริ่มต้นก่อน'
                    : 'Click on map to set starting point first';
                    
                routeSteps.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: #fff3cd; border-radius: var(--border-radius); color: #856404;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p style="margin: 8px 0 0 0; font-size: 14px;">
                            ${noStartText}
                        </p>
                    </div>
                `;
                return;
            }
            
            const deltaX = room.x - startPoint.x;
            const deltaY = room.y - startPoint.y;
            const distance = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 2);
            
            let direction = '';
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                direction = deltaX > 0 
                    ? (currentLanguage === 'th' ? 'ทางขวา' : 'to the right')
                    : (currentLanguage === 'th' ? 'ทางซ้าย' : 'to the left');
            } else {
                direction = deltaY > 0 
                    ? (currentLanguage === 'th' ? 'ด้านล่าง' : 'downward')
                    : (currentLanguage === 'th' ? 'ด้านบน' : 'upward');
            }
            
            const steps = currentLanguage === 'th' ? [
                {
                    step: 1,
                    text: 'เริ่มต้นจากจุดเริ่มต้น',
                    distance: '0m'
                },
                {
                    step: 2,
                    text: `เดินไป${direction} ประมาณ ${distance} เมตร`,
                    distance: `${distance}m`
                },
                {
                    step: 3,
                    text: `มองหา ${room.building}`,
                    distance: '10m'
                },
                {
                    step: 4,
                    text: `เข้าสู่ ${room.name}`,
                    distance: '0m'
                }
            ] : [
                {
                    step: 1,
                    text: 'Start from starting point',
                    distance: '0m'
                },
                {
                    step: 2,
                    text: `Walk ${direction} approximately ${distance} meters`,
                    distance: `${distance}m`
                },
                {
                    step: 3,
                    text: `Look for ${room.building}`,
                    distance: '10m'
                },
                {
                    step: 4,
                    text: `Enter ${room.name}`,
                    distance: '0m'
                }
            ];
            
            const stepsTitle = currentLanguage === 'th' ? 'ขั้นตอนการเดินทาง' : 'Navigation Steps';
            
            routeSteps.innerHTML = `
                <div class="route-steps">
                    <h4 style="margin: 0 0 15px 0; font-size: 16px; color: var(--primary-color);">
                        <i class="fas fa-route"></i> ${stepsTitle}
                    </h4>
                    ${steps.map(step => `
                        <div class="route-step">
                            <div class="step-number">${step.step}</div>
                            <div class="step-content">${step.text}</div>
                            <div class="step-distance">${step.distance}</div>
                            <button class="step-voice-btn" onclick="speakStep('${step.text}')">
                                <i class="fas fa-volume-up"></i>
                            </button>
                        </div>
                    `).join('')}
                </div>
            `;
        }
		
		// 🔧 v1.1 เพิ่ม ensureRouteConsistency function ที่หายไป
		function ensureRouteConsistency() {
			console.log('🔄 ensureRouteConsistency called');
			
			   // ตรวจสอบสถานะ routing
			if (typeof window.routeState === 'undefined') {
				window.routeState = {
					showRoute: false,
					hasStartPoint: false,
					hasSelectedRoom: false,
					startPoint: null,
					selectedRoom: null
				};
			}
			
			// อัพเดท UI controls ตามสถานะ
			/*
			const routeControls = document.querySelector('.route-controls');
			if (routeControls) {
				const showRouteBtn = routeControls.querySelector('#showRouteBtn');
				const clearRouteBtn = routeControls.querySelector('#clearRouteBtn');
				
				if (showRouteBtn) {
					showRouteBtn.style.display = window.routeState.hasStartPoint && window.routeState.hasSelectedRoom ? 'inline-block' : 'none';
				}
				
				if (clearRouteBtn) {
					clearRouteBtn.style.display = window.routeState.showRoute ? 'inline-block' : 'none';
				}
			}
			console.log('✅ Route consistency ensured:', window.routeState);
			*/
		}
		
		
		// 🔧 v1.1 ตรวจสอบและสร้าง gallery elements หากไม่มี
		function ensureGalleryElements() {
			console.log('🔍 Checking gallery elements...');
			
			let galleryContainer = document.getElementById('overlayRoomGallery');
			let gallery = document.getElementById('roomGalleryImages');
			
			// หาก overlayRoomGallery ไม่มี ให้สร้างใหม่
			if (!galleryContainer) {
				console.log('🔨 Creating overlayRoomGallery element...');
				
				// หา roomDetails container เพื่อเพิ่ม gallery
				const roomDetails = document.getElementById('roomDetails');
				if (roomDetails) {
					galleryContainer = document.createElement('div');
					galleryContainer.id = 'overlayRoomGallery';
					galleryContainer.style.cssText = `
						max-height: 400px;
						overflow-y: auto;
						border: 1px solid var(--border-color, #ddd);
						border-radius: 8px;
						padding: 15px;
						background: var(--background-color, #fff);
						margin-top: 15px;
						display: none;
					`;
					roomDetails.appendChild(galleryContainer);
					console.log('✅ Created overlayRoomGallery');
				}
			}
			
			// หาก roomGalleryImages ไม่มี ให้สร้างใหม่
			if (!gallery && galleryContainer) {
				console.log('🔨 Creating roomGalleryImages element...');
				
				gallery = document.createElement('div');
				gallery.id = 'roomGalleryImages';
				gallery.style.cssText = `
					display: block;
					width: 100%;
				`;
				galleryContainer.appendChild(gallery);
				console.log('✅ Created roomGalleryImages');
			}
			
			return { galleryContainer, gallery };
		}

     // 🔧 v1.1 แทนที่ฟังก์ชัน updateOverlayImageGallery  
		function updateOverlayImageGallery(room) {
			console.log(`🖼️ Processing images for room ${room.code}:`, room);
			
			// ✅ ค้นหา gallery elements และสร้างถ้าไม่มี
			let gallery = document.getElementById('overlayImageGallery');
			let galleryContainer = document.getElementById('overlayRoomGallery');
			
			// หาก overlayImageGallery ไม่มี ให้ใช้ roomGalleryImages แทน
			if (!gallery) {
				gallery = document.getElementById('roomGalleryImages');
				console.log('🔍 Using roomGalleryImages as fallback gallery');
			}
			
			// หาก galleryContainer ไม่มี ให้สร้าง
			if (!galleryContainer) {
				console.log('🔨 Creating overlayRoomGallery element...');
				
				// หา roomDetails container เพื่อเพิ่ม gallery
				const roomDetails = document.getElementById('roomDetails') || 
								   document.getElementById('overlayContent') ||
								   document.querySelector('.room-info-content');
				
				if (roomDetails) {
					galleryContainer = document.createElement('div');
					galleryContainer.id = 'overlayRoomGallery';
					galleryContainer.style.cssText = `
						max-height: 400px;
						overflow-y: auto;
						border: 1px solid var(--border-color, #ddd);
						border-radius: 8px;
						padding: 15px;
						background: var(--background-color, #fff);
						margin-top: 15px;
						display: block !important;
						visibility: visible !important;
					`;
					roomDetails.appendChild(galleryContainer);
					console.log('✅ Created overlayRoomGallery');
				}
			}
			
			// หาก gallery ยังไม่มี ให้สร้าง
			if (!gallery && galleryContainer) {
				console.log('🔨 Creating gallery element...');
				gallery = document.createElement('div');
				gallery.id = 'overlayImageGallery';
				gallery.style.cssText = 'display: block !important; width: 100%; visibility: visible !important;';
				galleryContainer.appendChild(gallery);
				console.log('✅ Created overlayImageGallery');
			}
			
			if (!gallery || !galleryContainer) {
				console.error('❌ Cannot create gallery elements');
				return;
			}

			// 🔍 Debug: แสดงข้อมูล room structure 
			console.log('🏠 Room data structure:', {
				code: room.code,
				name: room.name,
				images: room.images,
				image_urls: room.image_urls,
				images_type: typeof room.images,
				images_length: Array.isArray(room.images) ? room.images.length : 'not array'
			});

			// ✅ Fixed: จัดการ images array ที่มี JSON string
			let imageUrls = [];
			
			// ตรวจสอบ room.images ก่อน (จาก log เห็นว่าใช้ images)
			if (room.images && Array.isArray(room.images)) {
				console.log('🔍 Processing room.images array:', room.images);
				
				room.images.forEach((item, index) => {
					console.log(`🔍 Processing images[${index}]:`, item, 'type:', typeof item);
					
					if (typeof item === 'string' && item.trim()) {
						// ตรวจสอบว่าเป็น JSON array string หรือไม่
						if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
							try {
								const parsed = JSON.parse(item.trim());
								if (Array.isArray(parsed)) {
									const validUrls = parsed.filter(url => url && typeof url === 'string' && url.trim());
									imageUrls.push(...validUrls);
									console.log(`✅ Parsed JSON array from images[${index}], found ${validUrls.length} URLs:`, validUrls);
								}
							} catch (e) {
								console.warn(`⚠️ Failed to parse JSON from images[${index}]:`, e.message);
								// ถ้า parse ไม่ได้ ลองใช้เป็น URL ธรรมดา
								if (isValidImageUrl(item.trim())) {
									imageUrls.push(item.trim());
								}
							}
						} else if (isValidImageUrl(item.trim())) {
							// URL ธรรมดา
							imageUrls.push(item.trim());
						}
					}
				});
			}
			
			// Fallback: ลอง room.image_urls หากไม่มี images
			if (imageUrls.length === 0 && room.image_urls) {
				console.log('🔍 Fallback to room.image_urls:', room.image_urls);
				// ใช้ logic เดียวกัน
				if (Array.isArray(room.image_urls)) {
					room.image_urls.forEach((item, index) => {
						if (typeof item === 'string' && item.trim()) {
							if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
								try {
									const parsed = JSON.parse(item.trim());
									if (Array.isArray(parsed)) {
										imageUrls.push(...parsed.filter(url => url && typeof url === 'string' && url.trim()));
									}
								} catch (e) {
									if (isValidImageUrl(item.trim())) {
										imageUrls.push(item.trim());
									}
								}
							} else if (isValidImageUrl(item.trim())) {
								imageUrls.push(item.trim());
							}
						}
					});
				}
			}

			console.log(`🖼️ Total imageUrls parsed: ${imageUrls.length}`);
			imageUrls.forEach((url, index) => {
				console.log(`🖼️ URL ${index + 1}:`, url);
			});

			if (!imageUrls || imageUrls.length === 0) {
				galleryContainer.style.display = 'none';
				gallery.innerHTML = '';
				console.log('📷 No images to display - hiding gallery');
				return;
			}

			// ✅ ประมวลผลแต่ละ URL แยกกัน
			const processedImages = [];
			
			imageUrls.forEach((url, index) => {
				console.log(`🔄 Processing individual URL ${index + 1}:`, url);
				
				if (!url || typeof url !== 'string') {
					console.log(`⚠️ Skipping invalid URL at index ${index}:`, url);
					return;
				}
				
				// ส่ง URL แต่ละตัวไปยัง processImageUrl (หากมี function นี้)
				let processedUrl = url; // fallback ใช้ original URL
				if (typeof processImageUrl === 'function') {
					processedUrl = processImageUrl(url);
					console.log(`🔄 processImageUrl result for "${url}":`, processedUrl);
				} else {
					console.log(`⚠️ processImageUrl function not found, using original URL`);
				}
				
				if (processedUrl) {
					processedImages.push({
						original: url,
						processed: processedUrl,
						index: processedImages.length
					});
					console.log(`✅ Added processed image ${processedImages.length}: "${url}" -> "${processedUrl}"`);
				} else {
					console.log(`❌ Rejected URL ${index + 1}: "${url}"`);
				}
			});

			console.log(`📊 Final processed images: ${processedImages.length} out of ${imageUrls.length} URLs`);

			if (processedImages.length === 0) {
				galleryContainer.style.display = 'block';
				gallery.innerHTML = `
					<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
						<i class="fas fa-exclamation-triangle" style="font-size: 48px; opacity: 0.3; margin-bottom: 15px; color: orange;"></i>
						<p>ไม่พบรูปภาพที่ใช้งานได้</p>
						<small style="display: block; margin-top: 10px; opacity: 0.7; font-family: monospace;">
							Raw images: ${JSON.stringify(room.images)}<br>
							Parsed URLs: ${imageUrls.length}<br>
							Room: ${room.code}
						</small>
					</div>
				`;
				return;
			}

			// 🎨 สร้าง HTML สำหรับ Gallery - ไม่มี crossorigin และเพิ่ม referrerpolicy
			galleryContainer.style.display = 'block';
			galleryContainer.style.visibility = 'visible';
			
			const galleryHTML = processedImages.map((imageData, index) => {
				const imgId = `gallery-img-${room.code}-${index}`;
				const escapedProcessed = imageData.processed.replace(/'/g, "\\'");
				const escapedRoomName = room.name.replace(/'/g, "\\'");
				const escapedOriginal = imageData.original.replace(/'/g, "\\'");
				
				return `
				<div class="gallery-item" style="position: relative; margin-bottom: 15px; display: block !important; visibility: visible !important;">
					<img id="${imgId}"
						 src="${imageData.processed}" 
						 alt="Room image ${index + 1}" 
						 style="width: 100%; border-radius: 8px; cursor: pointer; display: block !important; visibility: visible !important;"
						 referrerpolicy="no-referrer-when-downgrade"
						 onclick="openImageModal && openImageModal('${escapedProcessed}', '${escapedRoomName}')"
						 onerror="handleImageError(this, '${escapedOriginal}', ${imageData.index})"
						 onload="handleImageSuccess(this, ${imageData.index})">
					<div class="image-error-fallback" style="display: none; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; color: var(--text-secondary);">
						<i class="fas fa-broken-image"></i>
						<p>ไม่สามารถโหลดรูปภาพได้</p>
						<small style="font-family: monospace; font-size: 11px; opacity: 0.7;">
							Original: ${imageData.original}<br>
							Processed: ${imageData.processed}<br>
							Index: ${imageData.index}
						</small>
					</div>
				</div>`;
			}).join('');
			
			gallery.innerHTML = galleryHTML;
			gallery.style.display = 'block';
			gallery.style.visibility = 'visible';
			
			console.log(`✅ Gallery HTML created with ${processedImages.length} images`);
			console.log(`✅ Displayed ${processedImages.length}/${imageUrls.length} valid images in overlay gallery`);
			
			// 🔧 Debug gallery visibility
			setTimeout(() => {
				const galleryItems = gallery.querySelectorAll('.gallery-item');
				console.log(`🔍 Gallery Debug:`, {
					galleryDisplay: galleryContainer.style.display,
					galleryVisible: galleryContainer.style.visibility,
					itemsCount: galleryItems.length,
					firstItemVisible: galleryItems[0] ? galleryItems[0].style.display : 'no items',
					containerInDOM: !!document.getElementById('overlayRoomGallery')
				});
			}, 1000);
		}
		
		// V1.1 🔧 เพิ่ม Missing Image Handler Functions
		function handleImageSuccess(imgElement, index) {
			console.log(`✅ Image ${index + 1} loaded successfully:`, {
				src: imgElement.src,
				naturalWidth: imgElement.naturalWidth,
				naturalHeight: imgElement.naturalHeight,
				display: imgElement.style.display,
				visibility: imgElement.style.visibility,
				parentVisible: imgElement.parentElement ? imgElement.parentElement.style.display : 'unknown'
			});
			
			// 🔧 Force image to be visible
			imgElement.style.display = 'block';
			imgElement.style.visibility = 'visible';
			imgElement.style.opacity = '1';
			
			// ซ่อน loading indicator หากมี
			const container = imgElement.closest('.gallery-item');
			if (container) {
				const loadingIndicator = container.querySelector('.loading-indicator');
				if (loadingIndicator) {
					loadingIndicator.style.display = 'none';
				}
				
				// 🔧 Force container to be visible
				container.style.display = 'block';
				container.style.visibility = 'visible';
			}
			
			// 🔧 Force gallery container to be visible
			const galleryContainer = document.getElementById('overlayRoomGallery') || 
									document.getElementById('overlayImageGallery');
			if (galleryContainer) {
				galleryContainer.style.display = 'block';
				galleryContainer.style.visibility = 'visible';
				console.log('🔧 Forced gallery container to be visible');
			}
		}

		// V1.1
		function handleImageError(imgElement, originalUrl, index) {
			console.error(`❌ Image ${index + 1} failed to load:`, originalUrl);
			
			// 🔧 Check if this is a CORS error and if retry mechanism exists
			if (originalUrl.includes('retry=')) {
				console.log('⚠️ Image failed even after retry, showing fallback');
				
				// แสดง error fallback
				const container = imgElement.closest('.gallery-item');
				if (container) {
					const errorFallback = container.querySelector('.image-error-fallback');
					if (errorFallback) {
						imgElement.style.display = 'none';
						errorFallback.style.display = 'block';
					} else {
						// สร้าง fallback ใหม่หากไม่มี
						container.innerHTML = `
							<div style="text-align: center; padding: 20px; border: 2px dashed #dc3545; 
										border-radius: 8px; background: rgba(220, 53, 69, 0.1);">
								<i class="fas fa-broken-image" style="font-size: 24px; color: #dc3545; margin-bottom: 8px;"></i>
								<p style="color: #dc3545; margin: 0; font-size: 12px;">ไม่สามารถโหลดรูปภาพได้</p>
								<small style="color: #666;">CORS Policy ไม่อนุญาต</small>
							</div>
						`;
					}
				}
			} else {
				// 🔧 Let existing retry mechanism handle first failure
				console.log('🔄 Letting existing retry mechanism handle this error');
			}
		}

       // 🔧 v1.1 . Enhanced Image Modal Function
		function openImageModal(imageUrl, roomName) {
			const modal = document.createElement('div');
			modal.style.cssText = `
				position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
				background: rgba(0,0,0,0.9); display: flex; align-items: center; 
				justify-content: center; z-index: 10000; cursor: pointer;
			`;
			
			modal.innerHTML = `
				<div style="position: relative; max-width: 90%; max-height: 90%;" onclick="event.stopPropagation()">
					<img src="${imageUrl}" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 8px;"
						 onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
					<div style="display: none; text-align: center; padding: 40px; background: #fff; border-radius: 8px; color: #333;">
						<i class="fas fa-broken-image" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
						<p>ไม่สามารถโหลดรูปภาพได้</p>
					</div>
					<div style="text-align: center; color: white; margin-top: 10px; font-size: 14px;">
						${roomName} - รูปภาพห้อง
					</div>
					<button onclick="this.closest('div').parentElement.remove()" 
							style="position: absolute; top: -10px; right: -10px; background: #dc3545; color: white; 
								   border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
				</div>
			`;
			
			modal.onclick = () => modal.remove();
			document.body.appendChild(modal);
		}

        // =================== Event Setup ===================
        
       // แก้ไข: ปรับปรุงฟังก์ชัน setupMapEvents เพื่อรักษาจุดหมายไว้
		function setupMapEvents() {
			const mapArea = document.getElementById('mapArea');
			if (!mapArea) return;
			
			mapArea.addEventListener('click', function(event) {
				// ไม่ตั้งจุดเริ่มต้นเมื่อคลิกที่ room markers หรือ action overlay
				if (event.target.classList.contains('room-marker') || 
					event.target.closest('.room-action-overlay')) {
					return;
				}
				
				// คำนวณตำแหน่งบนแผนที่
				const rect = mapArea.getBoundingClientRect();
				const x = ((event.clientX - rect.left) / rect.width) * 100;
				const y = ((event.clientY - rect.top) / rect.height) * 100;
				
				// ตรวจสอบว่าตำแหน่งอยู่ในขอบเขต
				if (x >= 0 && x <= 100 && y >= 0 && y <= 100) {
					// ล้างเส้นทางเดิมถ้ามีการเปลี่ยนจุดเริ่มต้น
					if (routeDisplayed) {
						clearRoute();
					}
					
					// ตั้งจุดเริ่มต้น (แต่ไม่เปลี่ยน selectedRoom)
					const oldStartPoint = startPoint;
					startPoint = {
						name: currentLanguage === 'th' ? 'จุดเริ่มต้น' : 'Starting Point',
						x: x,
						y: y
					};
					
					localStorage.setItem('startPoint', JSON.stringify(startPoint));
					
					// อัปเดต markers โดยรักษา selectedRoom ไว้
					updateRoomMarkers(); 
					updateRouteControls(false);
					
					const message = currentLanguage === 'th' 
						? `🎯 เปลี่ยนจุดเริ่มต้นใหม่ (${Math.round(x)}, ${Math.round(y)})`
						: `🎯 Start point updated (${Math.round(x)}, ${Math.round(y)})`;
					showNotification(message, 'success');
					
					// แสดงเส้นทางอัตโนมัติถ้ามีห้องที่เลือกแล้ว
					if (selectedRoom && roomData[selectedRoom]) {
						setTimeout(() => {
							showRouteToSelected();
							
							// แจ้งเตือนว่าสามารถดูเส้นทางใหม่ได้แล้ว
							const routeMessage = currentLanguage === 'th' 
								? `🛣️ เส้นทางใหม่ไปยัง ${roomData[selectedRoom].name}`
								: `🛣️ New route to ${roomData[selectedRoom].name}`;
							setTimeout(() => {
								showNotification(routeMessage, 'info');
							}, 1000);
						}, 500);
					} else {
						// แจ้งให้ผู้ใช้ค้นหาห้องก่อน
						setTimeout(() => {
							const searchMessage = currentLanguage === 'th' 
								? '💡 ไปหน้าค้นหาเพื่อเลือกห้องปลายทาง จากนั้นกลับมาดูเส้นทาง'
								: '💡 Go to search page to select destination room, then return to view route';
							showNotification(searchMessage, 'info');
						}, 1000);
					}
				}
			});
		}
		
		
		

        function setupWindowEvents() {
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    updateRoomMarkers();
                }, 500);
            });

            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateRoomMarkers();
                }, 250);
            });

            window.addEventListener('beforeunload', function(e) {
                if (startPoint) {
                    localStorage.setItem('startPoint', JSON.stringify(startPoint));
                }
            });

            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                    e.preventDefault();
                    const searchInput = document.getElementById('searchInput');
                    if (searchInput) {
                        searchInput.focus();
                    }
                }
                
                if (e.key === 'Escape') {
                    closeRoomInfoOverlay();
                    
                    const imageModal = document.querySelector('div[style*="position: fixed"][style*="background: rgba(0,0,0,0.9)"]');
                    if (imageModal) {
                        imageModal.remove();
                    }
                    
                    if (isVoiceNavigating) {
                        stopVoiceNavigation();
                    }
                }
                
                if (e.key === ' ' && isVoiceNavigating) {
                    e.preventDefault();
                    stopVoiceNavigation();
                }
            });
        }


		// ======= แก้ไข: ปรับปรุงการโหลดภาพแผนที่ =======
		async function loadMapDataFromSheets() {
			if (currentVersion !== 'live' || !sheetsConfig.url) {
				console.log('🗺️ Not loading map images (Demo mode or no sheets URL)');
				return;
			}
			
			try {
				console.log('🗺️ Loading map images from Google Sheets...');
				showProgressiveStatus('🗺️ โหลดภาพแผนที่...', 'info');
				
				// แก้ไข: เพิ่ม timeout สำหรับ map images
				const controller = new AbortController();
				const timeoutId = setTimeout(() => {
					controller.abort();
					console.log('⏰ Map images request timeout');
				}, 20000); // 20 วินาที สำหรับรูปภาพ
				
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', sheetsConfig.mapImagesSheet);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString(),
					signal: controller.signal
				});
				
				clearTimeout(timeoutId);
				
				if (response.ok) {
					const result = await response.json();
					console.log('🗺️ Map images response received');
					
					if (result.success && result.data && result.data.length > 0) {
						let sheetMapData = result.data.find(item => 
							item.id === 'main_map' || item.id === 'maps'
						);
						
						if (!sheetMapData && result.data.length > 0) {
							sheetMapData = result.data[0];
						}
						
						if (sheetMapData) {
							// อัปเดทข้อมูลแผนที่
							if (sheetMapData.floorplan) {
								mapData.floorplan = sheetMapData.floorplan;
								console.log('✅ Floorplan loaded from sheets');
							}
							if (sheetMapData.realphoto) {
								mapData.realphoto = sheetMapData.realphoto;
								console.log('✅ Real photo loaded from sheets');
							}
							if (sheetMapData.notes) {
								mapData.notes = sheetMapData.notes;
							}
							
							mapData.loaded = true;
							
							// แก้ไข: ใช้ฟังก์ชันบีบอัดสำหรับข้อมูลขนาดใหญ่
							const cacheSuccess = safeSetCachedData('mapImages', mapData);
							if (!cacheSuccess) {
								console.warn('⚠️ Map images too large to cache, using session storage');
							}
							
							updateMapDisplay();
							showProgressiveStatus('✅ โหลดภาพแผนที่สำเร็จ', 'success');
							
							console.log('✅ Map images loaded successfully');
						} else {
							console.log('⚠️ No map data found in sheets');
							showProgressiveStatus('⚠️ ไม่พบข้อมูลภาพแผนที่', 'warning');
						}
					} else {
						console.log('⚠️ No map images data in response');
						showProgressiveStatus('⚠️ ไม่มีข้อมูลภาพแผนที่', 'warning');
					}
				} else {
					console.error('❌ Failed to fetch map images:', response.status);
					showProgressiveStatus('❌ โหลดภาพแผนที่ล้มเหลว', 'error');
				}
			} catch (error) {
				if (error.name === 'AbortError') {
					console.error('⏰ Map images request timeout');
					showProgressiveStatus('⏰ โหลดภาพแผนที่ใช้เวลานานเกินไป', 'warning');
				} else {
					console.error('❌ Error loading map images:', error);
					showProgressiveStatus('❌ เกิดข้อผิดพลาดในการโหลดภาพแผนที่', 'error');
				}
			}
		}

		// ======= อัปเดตการแสดงผลแผนที่ =======
		function updateMapDisplay() {
			const mapImage = document.getElementById('mapImage');
			if (!mapImage) return;
			
			let imageToShow = null;
			
			// เลือกภาพตาม layout ปัจจุบัน
			if (currentMapLayout === 'photo' && mapData.realphoto) {
				imageToShow = mapData.realphoto;
				console.log('🗺️ Displaying real photo');
			} else if (currentMapLayout === 'floorplan' && mapData.floorplan) {
				imageToShow = mapData.floorplan;
				console.log('🗺️ Displaying floorplan');
			}
			
			if (imageToShow) {
				mapImage.src = imageToShow;
				mapImage.onerror = function() {
					console.error('❌ Failed to load map image:', imageToShow);
					showFallbackMap();
				};
				mapImage.onload = function() {
					console.log('✅ Map image loaded successfully');
				};
			} else {
				// แสดงแผนที่ default หรือข้อความแจ้งเตือน
				showFallbackMap();
			}
		}

		// ======= แสดงแผนที่ default เมื่อไม่มีภาพ =======
		function showFallbackMap() {
			const mapImage = document.getElementById('mapImage');
			if (!mapImage) return;
			
			const fallbackText = currentMapLayout === 'photo' ? 'ภาพจริง' : 'แผนผัง';
			const missingText = currentLanguage === 'th' 
				? `ไม่มี${fallbackText}` 
				: `No ${currentMapLayout} available`;
			
			mapImage.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='600' viewBox='0 0 800 600'%3E%3Crect width='800' height='600' fill='%23f0f8ff'/%3E%3Ctext x='400' y='280' text-anchor='middle' font-family='Arial' font-size='28' fill='%23667eea' font-weight='bold'%3E🏫 ${encodeURIComponent('แผนที่โรงเรียนอัจฉริยะ')}%3C/text%3E%3Ctext x='400' y='320' text-anchor='middle' font-family='Arial' font-size='16' fill='%23999'%3E${encodeURIComponent(missingText)}%3C/text%3E%3Ctext x='400' y='350' text-anchor='middle' font-family='Arial' font-size='14' fill='%23667eea'%3E📍 ${encodeURIComponent('คลิกจุดบนแผนที่เพื่อดูข้อมูลห้อง')}%3C/text%3E%3C/svg%3E`;
		}

		// ======= แก้ไขฟังก์ชัน setMapLayout เดิม =======
		function setMapLayout(layout) {
			currentMapLayout = layout;
			
			// อัปเดต UI ปุ่ม
			document.querySelectorAll('.map-control-btn[data-layout]').forEach(btn => {
				btn.classList.remove('active');
			});
			
			const targetBtn = document.querySelector(`[data-layout="${layout}"]`);
			if (targetBtn) {
				targetBtn.classList.add('active');
			}
			
			// อัปเดตแผนที่
			updateMapDisplay();
			
			// แสดงการแจ้งเตือน
			const layoutName = layout === 'photo' 
				? (currentLanguage === 'th' ? 'ภาพจริง' : 'Real Photo')
				: (currentLanguage === 'th' ? 'แผนผัง' : 'Floor Plan');
			
			showNotification(
				currentLanguage === 'th' ? `🗺️ เปลี่ยนเป็น${layoutName}` : `🗺️ Switched to ${layoutName}`,
				'info'
			);
		}
		
		// ======= แก้ไข: ปรับปรุงการจัดการ Session Storage สำหรับ Map Images =======
		function loadMapFromSessionStorage() {
			try {
				const floorplan = sessionStorage.getItem('temp_floorplan');
				const realphoto = sessionStorage.getItem('temp_realphoto');
				
				if (floorplan) {
					mapData.floorplan = floorplan;
				}
				if (realphoto) {
					mapData.realphoto = realphoto;
				}
				
				if (floorplan || realphoto) {
					mapData.loaded = true;
					updateMapDisplay();
					console.log('🗺️ Map images loaded from session storage');
				}
			} catch (error) {
				console.warn('⚠️ Could not load map images from session storage:', error);
			}
		}

		// ======= แก้ไข: เรียกใช้ session storage เมื่อโหลดระบบ =======
		async function initializeMapImages() {
			console.log('🗺️ Initializing map images...');
			
			// ลองโหลดจาก session storage ก่อน
			loadMapFromSessionStorage();
			
			// ถ้า session storage มีข้อมูลแล้ว ไม่ต้องโหลดจาก cache/sheets
			if (mapData.loaded && (mapData.floorplan || mapData.realphoto)) {
				console.log('💾 Map images available from session storage');
				return;
			}
			
			// ลองโหลดจาก cache
			if (isCacheValid('mapImages', 60 * 60 * 1000)) { // 1 hour cache
				const cachedMapData = getCachedData('mapImages');
				if (cachedMapData && !cachedMapData.compressed) {
					mapData = { ...mapData, ...cachedMapData };
					updateMapDisplay();
					console.log('💾 Map images loaded from cache');
					return;
				} else if (cachedMapData && cachedMapData.compressed) {
					console.log('🗜️ Found compressed cache, loading from session storage');
					loadMapFromSessionStorage();
					return;
				}
			}
			
			// โหลดจาก Google Sheets (Live mode เท่านั้น และเพียงครั้งเดียว)
			if (currentVersion === 'live') {
				await loadMapDataFromSheets();
			} else {
				console.log('🎮 Demo mode: Using default map images');
				showFallbackMap();
			}
		}

		// ======= เพิ่มการ Debug สำหรับแผนที่ =======
		function debugMapImages() {
			console.log('🔍 === MAP IMAGES DEBUG ===');
			console.log('Current version:', currentVersion);
			console.log('Current layout:', currentMapLayout);
			console.log('Map data:', {
				hasFloorplan: !!mapData.floorplan,
				hasRealPhoto: !!mapData.realphoto,
				loaded: mapData.loaded,
				floorplanLength: mapData.floorplan ? mapData.floorplan.length : 0,
				realPhotoLength: mapData.realphoto ? mapData.realphoto.length : 0
			});
			console.log('Sheets config:', {
				url: sheetsConfig.url ? 'SET' : 'NOT SET',
				mapImagesSheet: sheetsConfig.mapImagesSheet
			});
			
			const mapImage = document.getElementById('mapImage');
			if (mapImage) {
				console.log('Map image element:', {
					src: mapImage.src.substring(0, 100) + '...',
					naturalWidth: mapImage.naturalWidth,
					naturalHeight: mapImage.naturalHeight
				});
			}
		}
		// ===== 8. เพิ่มฟังก์ชัน debug เพื่อตรวจสอบปัญหา =====
		// เพิ่มให้สามารถเรียกใช้ใน console: debugCurrentState()
			function debugCurrentState() {
				console.group('🐛 Current Route State Debug');
				console.log('📍 startPoint:', startPoint);
				console.log('🎯 selectedRoom:', selectedRoom);
				console.log('💾 persistentDestination:', persistentDestination);
				console.log('🛣️ routeDisplayed:', routeDisplayed);
				console.log('📱 currentRoute:', currentRoute);
				console.log('🗃️ localStorage destination:', localStorage.getItem('persistentDestination'));
				console.log('🗃️ localStorage startPoint:', localStorage.getItem('startPoint'));
				console.log('🔍 Route elements on page:', document.querySelectorAll('.route-line, .route-marker').length);
				
				// ตรวจสอบปุ่มต่างๆ
				const showBtn = document.getElementById('showRouteBtn');
				const clearBtn = document.getElementById('clearRouteBtn');
				console.log('🎮 Show button:', showBtn ? { disabled: showBtn.disabled, display: showBtn.style.display } : 'Not found');
				console.log('🎮 Clear button:', clearBtn ? { display: clearBtn.style.display } : 'Not found');
				
				console.groupEnd();
			}



		// แก้ไข: ฟังก์ชัน Toggle Usage Guide
		function toggleUsageGuide() {
			const content = document.getElementById('usageGuideContent');
			const toggleText = document.getElementById('usageGuideToggleText');
			const chevron = document.getElementById('usageGuideChevron');
			
			if (!content || !toggleText || !chevron) return;
			
			const isHidden = content.style.display === 'none';
			
			if (isHidden) {
				// Show content
				content.style.display = 'block';
				toggleText.innerHTML = `<span data-translate="hide_usage_guide">ซ่อนวิธีการใช้งาน</span>`;
				chevron.style.transform = 'rotate(180deg)';
				
				// Update translation
				const hideText = currentLanguage === 'th' ? 'ซ่อนวิธีการใช้งาน' : 'Hide Usage Guide';
				toggleText.textContent = hideText;
				
				showNotification(
					currentLanguage === 'th' ? '📖 แสดงวิธีการใช้งาน' : '📖 Usage guide shown',
					'info'
				);
			} else {
				// Hide content
				content.style.display = 'none';
				toggleText.innerHTML = `<span data-translate="show_usage_guide">แสดงวิธีการใช้งาน</span>`;
				chevron.style.transform = 'rotate(0deg)';
				
				// Update translation
				const showText = currentLanguage === 'th' ? 'แสดงวิธีการใช้งาน' : 'Show Usage Guide';
				toggleText.textContent = showText;
				
				showNotification(
					currentLanguage === 'th' ? '📖 ซ่อนวิธีการใช้งาน' : '📖 Usage guide hidden',
					'info'
				);
			}
		}
		
		
		// 🔧 V1.1  Enhanced Image URL Validation Function
		function isValidImageUrl(url) {
			if (!url || typeof url !== 'string') return false;
			
			const trimmedUrl = url.trim();
			if (trimmedUrl === '') return false;
			
			// กรองค่า placeholder
			const invalidValues = ['available', 'none', 'null', 'undefined', 'error', 'pending', '[]', '{}', 'N/A'];
			if (invalidValues.includes(trimmedUrl.toLowerCase())) {
				return false;
			}
			
			// Data URLs และ HTTP/HTTPS URLs
			if (trimmedUrl.startsWith('data:image/') || 
				trimmedUrl.startsWith('http://') || 
				trimmedUrl.startsWith('https://')) {
				return true;
			}
			
			// Web Server - relative paths และ extensions
			if (Environment.isWebServer) {
				if (trimmedUrl.startsWith('./') || 
					trimmedUrl.startsWith('../') || 
					trimmedUrl.startsWith('/') ||
					trimmedUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
					return true;
				}
			}
			
			return false;
		}
			
		// 🔧 v1.1  Enhanced Image URL Processing Function
		function processImageUrl(url) {
			console.log('🔄 processImageUrl input:', url);
			
			if (!url || typeof url !== 'string') {
				console.log('❌ processImageUrl: Invalid input');
				return null;
			}
			
			// ทำความสะอาด URL
			let cleanedUrl = url.trim()
				.replace(/^["'\[\]]+|["'\[\]]+$/g, '')
				.replace(/\\"/g, '"')
				.trim();
			
			console.log('🧹 Cleaned URL:', cleanedUrl);
			
			if (!isValidImageUrl(cleanedUrl)) {
				console.log('❌ processImageUrl: URL validation failed');
				return null;
			}
			
			// HTTP/HTTPS URLs ใช้ได้เลย
			if (cleanedUrl.startsWith('http://') || cleanedUrl.startsWith('https://')) {
				console.log('✅ processImageUrl: HTTP/HTTPS URL accepted');
				return cleanedUrl;
			}
			
			// Data URLs
			if (cleanedUrl.startsWith('data:')) {
				console.log('✅ processImageUrl: Data URL accepted');
				return cleanedUrl;
			}
			
			// Web Server - relative paths
			if (Environment.isWebServer) {
				if (cleanedUrl.startsWith('./') || cleanedUrl.startsWith('../')) {
					console.log('✅ processImageUrl: Relative path accepted');
					return cleanedUrl;
				}
				if (cleanedUrl.startsWith('/')) {
					console.log('✅ processImageUrl: Absolute path accepted');
					return cleanedUrl;
				}
				if (cleanedUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
					const result = './' + cleanedUrl;
					console.log('✅ processImageUrl: Added relative path prefix:', result);
					return result;
				}
			}
			
			console.log('✅ processImageUrl: Using original URL');
			return cleanedUrl;
		}
	
		// v1.1🔧 Enhanced parseImageUrls Function - แก้ไขการ parse JSON array
		function parseImageUrls(input) {
			console.log('🔍 parseImageUrls input:', input, 'type:', typeof input);
			
			if (!input) {
				console.log('❌ parseImageUrls: No input provided');
				return [];
			}
			
			let result = [];
			
			// กรณีที่เป็น Array อยู่แล้ว
			if (Array.isArray(input)) {
				// 🆕 ตรวจสอบแต่ละ element ใน array ว่าเป็น JSON string หรือไม่
				const flattenedUrls = [];
				
				input.forEach((item, index) => {
					console.log(`🔍 Processing array item ${index}:`, item, 'type:', typeof item);
					
					if (typeof item === 'string' && item.trim()) {
						// ตรวจสอบว่าเป็น JSON array string หรือไม่
						if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
							try {
								const parsed = JSON.parse(item.trim());
								if (Array.isArray(parsed)) {
									flattenedUrls.push(...parsed.filter(url => url && typeof url === 'string' && url.trim()));
									console.log(`✅ parseImageUrls: Parsed nested JSON from item ${index}, found ${parsed.length} URLs`);
								}
							} catch (e) {
								console.warn(`⚠️ parseImageUrls: Failed to parse JSON from item ${index}:`, e.message);
								// ถ้า parse ไม่ได้ ให้ใช้เป็น URL ธรรมดา
								flattenedUrls.push(item.trim());
							}
						} else {
							// ถ้าไม่ใช่ JSON ให้ใช้เป็น URL ธรรมดา
							flattenedUrls.push(item.trim());
						}
					}
				});
				
				result = flattenedUrls.filter(url => url && typeof url === 'string' && url.trim());
				console.log('✅ parseImageUrls: Array processed, flattened to', result.length, 'URLs');
				return result;
			}
			
			// กรณีที่เป็น String
			if (typeof input === 'string') {
				const trimmed = input.trim();
				
				if (!trimmed) {
					console.log('❌ parseImageUrls: Empty string input');
					return [];
				}
				
				// ตรวจสอบว่าเป็น JSON array หรือไม่
				if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
					try {
						const parsed = JSON.parse(trimmed);
						if (Array.isArray(parsed)) {
							result = parsed.filter(url => url && typeof url === 'string' && url.trim());
							console.log('✅ parseImageUrls: JSON array parsed, found', result.length, 'URLs');
							return result;
						}
					} catch (e) {
						console.warn('⚠️ parseImageUrls: JSON parse failed, trying alternative methods:', e.message);
						
						// ลองแก้ไข JSON ที่เสียหาย
						try {
							let fixedJson = trimmed
								.replace(/^[\[\s]*"?/, '["')  // แก้ไขตำแหน่งเริ่มต้น
								.replace(/"?\s*\]$/, '"]')    // แก้ไขตำแหน่งสิ้นสุด
								.replace(/",\s*"/g, '","')   // แก้ไข spacing ระหว่าง URLs
								.replace(/"\s*,\s*"/g, '","'); // แก้ไข spacing อีกรอบ
							
							const parsed = JSON.parse(fixedJson);
							if (Array.isArray(parsed)) {
								result = parsed.filter(url => url && typeof url === 'string' && url.trim());
								console.log('✅ parseImageUrls: Fixed JSON parsed, found', result.length, 'URLs');
								return result;
							}
						} catch (e2) {
							console.warn('⚠️ parseImageUrls: JSON fix failed:', e2.message);
						}
					}
				}
				
				// ลองแยกด้วย comma เป็นทางเลือกสุดท้าย
				if (trimmed.includes(',')) {
					result = trimmed
						.split(',')
						.map(url => url.trim().replace(/^["'\[\]]+|["'\[\]]+$/g, ''))
						.filter(url => url && isValidImageUrl(url));
					
					console.log('✅ parseImageUrls: Comma-separated parsed, found', result.length, 'URLs');
					return result;
				}
				
				// URL เดียว
				if (isValidImageUrl(trimmed)) {
					console.log('✅ parseImageUrls: Single URL detected');
					return [trimmed];
				}
			}
			
			console.log('❌ parseImageUrls: Could not parse input');
			return [];
		}
		
		// v1.1
        function isValidImageUrl(url) {
			if (!url || typeof url !== 'string') return false;
			
			// ตรวจสอบ HTTP/HTTPS URLs
			if (url.match(/^https?:\/\/.+\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
				return true;
			}
			
			// ตรวจสอบ Data URLs
			if (url.startsWith('data:image/')) {
				return true;
			}
			
			// ตรวจสอบ relative paths
			if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
				return true;
			}
			
			return false;
		}   
		
	
		// v1.1🔧 แก้ไข showRoomGallery Function
		function showRoomGallery(room) {
			console.log('🎯 showRoomGallery called with room:', room);
			
			// ✅ ตรวจสอบและสร้าง elements หากจำเป็น
			const { galleryContainer, gallery } = ensureGalleryElements();
			
			if (!galleryContainer || !gallery) {
				console.error('❌ Cannot create gallery elements');
				return;
			}

			// 🔍 Debug: แสดงข้อมูล room structure 
			console.log('🏠 Room data structure:', {
				code: room.code,
				name: room.name,
				images: room.images,
				image_urls: room.image_urls,
				images_type: typeof room.images,
				images_length: Array.isArray(room.images) ? room.images.length : 'not array'
			});

			// ✅ Fixed: จัดการ images array ที่มี JSON string
			let imageUrls = [];
			
			// ตรวจสอบ room.images ก่อน (จาก log เห็นว่าใช้ images)
			if (room.images && Array.isArray(room.images)) {
				console.log('🔍 Processing room.images array:', room.images);
				
				room.images.forEach((item, index) => {
					console.log(`🔍 Processing images[${index}]:`, item, 'type:', typeof item);
					
					if (typeof item === 'string' && item.trim()) {
						// ตรวจสอบว่าเป็น JSON array string หรือไม่
						if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
							try {
								const parsed = JSON.parse(item.trim());
								if (Array.isArray(parsed)) {
									const validUrls = parsed.filter(url => url && typeof url === 'string' && url.trim());
									imageUrls.push(...validUrls);
									console.log(`✅ Parsed JSON array from images[${index}], found ${validUrls.length} URLs:`, validUrls);
								}
							} catch (e) {
								console.warn(`⚠️ Failed to parse JSON from images[${index}]:`, e.message);
								// ถ้า parse ไม่ได้ ลองใช้เป็น URL ธรรมดา
								if (isValidImageUrl && isValidImageUrl(item.trim())) {
									imageUrls.push(item.trim());
								}
							}
						} else if (isValidImageUrl && isValidImageUrl(item.trim())) {
							// URL ธรรมดา
							imageUrls.push(item.trim());
						}
					}
				});
			}
			
			// Fallback: ลอง room.image_urls หากไม่มี images
			if (imageUrls.length === 0 && room.image_urls) {
				console.log('🔍 Fallback to room.image_urls:', room.image_urls);
				// ใช้ logic เดียวกัน
				if (Array.isArray(room.image_urls)) {
					room.image_urls.forEach((item, index) => {
						if (typeof item === 'string' && item.trim()) {
							if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
								try {
									const parsed = JSON.parse(item.trim());
									if (Array.isArray(parsed)) {
										imageUrls.push(...parsed.filter(url => url && typeof url === 'string' && url.trim()));
									}
								} catch (e) {
									if (isValidImageUrl && isValidImageUrl(item.trim())) {
										imageUrls.push(item.trim());
									}
								}
							} else if (isValidImageUrl && isValidImageUrl(item.trim())) {
								imageUrls.push(item.trim());
							}
						}
					});
				}
			}

			console.log(`🖼️ Total imageUrls parsed: ${imageUrls.length}`);
			imageUrls.forEach((url, index) => {
				console.log(`🖼️ URL ${index + 1}:`, url);
			});

			if (!imageUrls || imageUrls.length === 0) {
				galleryContainer.style.display = 'none';
				gallery.innerHTML = '';
				console.log('📷 No images to display - hiding gallery');
				return;
			}

			// ✅ ประมวลผลแต่ละ URL แยกกัน
			const processedImages = [];
			
			imageUrls.forEach((url, index) => {
				console.log(`🔄 Processing individual URL ${index + 1}:`, url);
				
				if (!url || typeof url !== 'string') {
					console.log(`⚠️ Skipping invalid URL at index ${index}:`, url);
					return;
				}
				
				// ส่ง URL แต่ละตัวไปยัง processImageUrl (หากมี function นี้)
				let processedUrl = url; // fallback ใช้ original URL
				if (typeof processImageUrl === 'function') {
					processedUrl = processImageUrl(url);
					console.log(`🔄 processImageUrl result for "${url}":`, processedUrl);
				} else {
					console.log(`⚠️ processImageUrl function not found, using original URL`);
				}
				
				if (processedUrl) {
					processedImages.push({
						original: url,
						processed: processedUrl,
						index: processedImages.length
					});
					console.log(`✅ Added processed image ${processedImages.length}: "${url}" -> "${processedUrl}"`);
				} else {
					console.log(`❌ Rejected URL ${index + 1}: "${url}"`);
				}
			});

			console.log(`📊 Final processed images: ${processedImages.length} out of ${imageUrls.length} URLs`);

			if (processedImages.length === 0) {
				galleryContainer.style.display = 'block';
				gallery.innerHTML = `
					<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
						<i class="fas fa-exclamation-triangle" style="font-size: 48px; opacity: 0.3; margin-bottom: 15px; color: orange;"></i>
						<p>ไม่พบรูปภาพที่ใช้งานได้</p>
						<small style="display: block; margin-top: 10px; opacity: 0.7; font-family: monospace;">
							Raw images: ${JSON.stringify(room.images)}<br>
							Parsed URLs: ${imageUrls.length}<br>
							Room: ${room.code}
						</small>
					</div>
				`;
				return;
			}

			// 🎨 สร้าง HTML สำหรับ Gallery
			galleryContainer.style.display = 'block';
			
			const galleryHTML = processedImages.map((imageData, index) => {
				const imgId = `gallery-img-${room.code}-${index}`;
				return `
				<div class="gallery-item" style="position: relative; margin-bottom: 15px;">
					<img id="${imgId}"
						 src="${imageData.processed}" 
						 alt="Room image ${index + 1}" 
						 style="width: 100%; border-radius: 8px; cursor: pointer; display: block;"
						 onclick="openImageModal && openImageModal('${imageData.processed.replace(/'/g, "\\'")}', '${room.name.replace(/'/g, "\\'")}')"
						 onerror="handleImageError && handleImageError(this, '${imageData.original.replace(/'/g, "\\'")}', ${imageData.index})"
						 onload="handleImageSuccess && handleImageSuccess(this, ${imageData.index})"
						 crossorigin="anonymous">
					<div class="image-error-fallback" style="display: none; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; color: var(--text-secondary);">
						<i class="fas fa-broken-image"></i>
						<p>ไม่สามารถโหลดรูปภาพได้</p>
						<small style="font-family: monospace; font-size: 11px; opacity: 0.7;">
							Original: ${imageData.original}<br>
							Processed: ${imageData.processed}<br>
							Index: ${imageData.index}
						</small>
					</div>
				</div>`;
			}).join('');
			
			gallery.innerHTML = galleryHTML;
			
			console.log(`✅ Gallery HTML created with ${processedImages.length} images`);
			console.log(`✅ Displayed ${processedImages.length}/${imageUrls.length} valid images in overlay gallery`);
		}

		// 🔧 แก้ไข 4: เพิ่ม isValidImageUrl function หากไม่มี
		if (typeof isValidImageUrl === 'undefined') {
			function isValidImageUrl(url) {
				if (!url || typeof url !== 'string') return false;
				
				// ตรวจสอบ HTTP/HTTPS URLs
				if (url.match(/^https?:\/\/.+\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
					return true;
				}
				
				// ตรวจสอบ Data URLs
				if (url.startsWith('data:image/')) {
					return true;
				}
				
				// ตรวจสอบ relative paths
				if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
					return true;
				}
				
				return false;
			}
			
			// ทำให้เป็น global function
			window.isValidImageUrl = isValidImageUrl;
		}

        // =================== Initialization ===================
        
			 // ======= แก้ไข: ปรับปรุงการโหลดข้อมูลเริ่มต้น - Sync เพียงครั้งเดียว =======
		async function loadInitialData() {
			const savedLang = localStorage.getItem('preferredLanguage') || 'th';
			currentLanguage = savedLang;
			updateLanguageButton();
			
			// โหลดข้อมูลโดยใช้ระบบ caching ใหม่ (เฉพาะครั้งเดียวเมื่อเข้าระบบ)
			console.log('🚀 Starting one-time data sync...');
			await loadRoomDataFromAdmin();
			
			// โหลดภาพแผนที่ (เฉพาะครั้งเดียว)
			await initializeMapImages();
			
			const savedStartPoint = localStorage.getItem('startPoint');
			if (savedStartPoint) {
				try {
					startPoint = JSON.parse(savedStartPoint);
				} catch (error) {
					console.error('Error loading start point:', error);
				}
			}
			
			// อัปเดต UI
			updateRoomMarkers();
			//updateRouteControls(false);
			updateAllTranslations();
			updateSearchPlaceholder();
			//updateGlobalVersionIndicator(currentVersion);
			loadDestination();
			updateDestinationDisplay();
			
			console.log('✅ One-time sync completed');
			showProgressiveStatus('✅ การซิงค์ข้อมูลเสร็จสิ้น', 'success');
		}

		// ======= เพิ่ม Debug Command สำหรับ Console =======
		window.debugMapImages = debugMapImages;

		
				// ======= เพิ่มฟังก์ชันจัดการ Performance =======
		function optimizePerformance() {
			// ล้าง cache เก่าที่เกิน 24 ชั่วโมง
			const keys = Object.keys(localStorage);
			const now = Date.now();
			const maxAge = 24 * 60 * 60 * 1000; // 24 hours
			
			keys.forEach(key => {
				if (key.includes('_timestamp_')) {
					const timestamp = localStorage.getItem(key);
					if (timestamp && (now - parseInt(timestamp)) > maxAge) {
						const cacheKey = key.replace('_timestamp_', '_cache_');
						localStorage.removeItem(key);
						localStorage.removeItem(cacheKey);
						console.log(`🗑️ Removed expired cache: ${cacheKey}`);
					}
				}
			});
			
			// รายงานการใช้ memory
			if (performance.memory) {
				const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
				console.log(`📊 Memory usage: ${used}MB`);
			}
		}

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // เริ่มต้น Environment detection
			Environment.init();
			
			console.log('🚀 Gallery system initialized for', Environment.getType());
			
			// ตั้งค่า global error handler สำหรับ images
			window.addEventListener('error', function(e) {
				if (e.target && e.target.tagName === 'IMG') {
					console.warn('🖼️ Global image error caught:', e.target.src);
				}
			}, true);
			
			// เพิ่ม CSS สำหรับ gallery (ถ้ายังไม่มี)
			if (!document.getElementById('gallery-styles')) {
				const style = document.createElement('style');
				style.id = 'gallery-styles';
				style.textContent = `
					#overlayRoomGallery {
						max-height: 300px;
						overflow-y: auto;
						border: 1px solid var(--border-color);
						border-radius: 8px;
						padding: 15px;
						background: var(--background-color);
						margin-top: 15px;
					}
					
					.gallery-item img {
						transition: transform 0.2s ease;
					}
					
					.gallery-item img:hover {
						transform: scale(1.02);
					}
					
					.image-error-fallback {
						border: 2px dashed #ddd;
						background: #f8f9fa;
					}
					
					/* แก้ไข lazy loading warnings */
					img[loading="eager"] {
						/* Force eager loading */
					}
				`;
				document.head.appendChild(style);
			}
			
			initializeSystem();
			
			 // โหลดและแสดงจุดหมายที่บันทึกไว้
			setTimeout(() => {
				loadDestination();
				updateDestinationDisplay();
			}, 1000);	
 
			setTimeout(() => {
                debugLog('🚀 Starting safe routing system initialization...');                
                try {
                    replaceFunctionsWithSafeVersions();
                    initializeEnhancedRouting();
                    
                    // Reset routing lock
                    routingLock = {
                        isProcessing: false,
                        lastUpdate: 0,
                        minInterval: 500,
                        maxRetries: 3,
                        currentRetries: 0
                    };                    
                     
                                    
                } catch (error) {
                    debugLog('❌ Error initializing safe routing system', error);
                }                
            }, 4000); // รอหลังจาก systems อื่นโหลดเสร็จ 				 
        });
		
 
		
		// 🔧 Export functions ให้ global scope
		window.isValidImageUrl = isValidImageUrl;
		window.ensureRouteConsistency = ensureRouteConsistency;
		window.updateOverlayImageGallery = updateOverlayImageGallery;
		window.showRoomGallery = showRoomGallery;
		window.openImageModal = openImageModal;
		window.handleImageError = handleImageError;
		window.handleImageSuccess = handleImageSuccess;
		window.Environment = Environment;
		
		

 

        // Performance monitoring
        function getMemoryUsage() {
            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                const limit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
                console.log(`Memory: ${used}MB / ${limit}MB`);
                
                if (used > limit * 0.8) {
                    console.warn('⚠️ Memory usage high, consider optimization');
                }
            }
        }
		

		// ========== Phase 2.1: Storage Key Separation + Complete Data Bridge ==========
		// 🎯 Mission: แก้ไข storage conflicts และสร้าง complete data conversion bridge
		// 🔧 Target: admin.html + index.html ใช้ storage keys แยกกันและ sync ได้

		

		// ========== 2. Safe Storage Key Functions ==========

		// ดึง storage key ที่ถูกต้องตาม environment
		function getSafeStorageKey(building, forceMode = null) {
			if (!building) building = getCurrentBuildingName();
			
			let mode;
			if (forceMode) {
				mode = forceMode;
			} else if (ADMIN_INDEX_BRIDGE.isAdminMode()) {
				mode = 'admin';
			} else if (ADMIN_INDEX_BRIDGE.isIndexMode()) {
				mode = 'index';
			} else {
				mode = 'unknown';
			}
			
			return ADMIN_INDEX_BRIDGE.getStorageKey(building, mode);
		}

		// หา building name จาก environment
		function getCurrentBuildingName() {
			// ลองหาจาก global variables
			if (typeof walkablePointsData !== 'undefined' && walkablePointsData.currentBuilding) {
				return walkablePointsData.currentBuilding;
			}
			if (typeof walkableRoutingData !== 'undefined' && walkableRoutingData.currentBuilding) {
				return walkableRoutingData.currentBuilding;
			}
			if (typeof currentBuilding !== 'undefined') {
				return currentBuilding;
			}
			
			// ลองหาจาก DOM elements
			const buildingSelect = document.getElementById('buildingSelect') || 
								  document.querySelector('[data-building]') ||
								  document.querySelector('.building-selector');
			
			if (buildingSelect && buildingSelect.value) {
				return buildingSelect.value;
			}
			
			// Default fallback
			return 'Main Building';
		}

		// ========== 3. Complete Data Format Converters ==========

		// แปลงจาก admin format เป็น index format (COMPLETE VERSION)
		function convertAdminToIndexFormat(adminData) {
			if (!adminData || typeof adminData !== 'object') {
				debugLog('❌ Invalid admin data for conversion');
				return null;
			}
			
			try {
				ADMIN_INDEX_BRIDGE.conversionCount++;
				debugLog('🔄 Converting admin data to index format...', {
					adminNodes: Object.keys(adminData.nodes || {}).length,
					adminEdges: (adminData.edges || []).length,
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				});
				
				const indexData = {
					// Core structure for index.html
					nodes: {},
					edges: [],
					settings: {
						metersPerPercent: adminData.settings?.metersPerPercent || 1.2,
						maxSearchRadius: adminData.settings?.maxConnectionDistance || 25,
						gridSize: adminData.settings?.gridSize || 5,
						autoConnect: adminData.settings?.autoConnect !== false,
						snapToGrid: adminData.settings?.snapToGrid || false
					},
					
					// Metadata
					currentBuilding: adminData.currentBuilding || adminData.building,
					lastPath: null,
					isInitialized: true,
					
					// Bridge metadata
					dataSource: 'admin',
					syncTime: new Date().toISOString(),
					originalFormat: 'admin',
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				};
				
				// แปลง nodes
				if (adminData.nodes && typeof adminData.nodes === 'object') {
					for (const nodeId in adminData.nodes) {
						const adminNode = adminData.nodes[nodeId];
						if (adminNode && typeof adminNode === 'object') {
							indexData.nodes[nodeId] = {
								id: nodeId,
								x: parseFloat(adminNode.x) || 0,
								y: parseFloat(adminNode.y) || 0,
								type: adminNode.type || 'grid',
								building: adminNode.building || indexData.currentBuilding,
								isActive: adminNode.isActive !== false,
								source: 'admin'
							};
						}
					}
				}
				
				// แปลง edges
				if (adminData.edges && Array.isArray(adminData.edges)) {
					adminData.edges.forEach((adminEdge, index) => {
						if (adminEdge && typeof adminEdge === 'object') {
							indexData.edges.push({
								from: adminEdge.from,
								to: adminEdge.to,
								weight: parseFloat(adminEdge.weight) || 0,
								bidirectional: adminEdge.bidirectional !== false,
								building: adminEdge.building || indexData.currentBuilding,
								isActive: adminEdge.isActive !== false,
								edgeId: adminEdge.edgeId || `E${index + 1}`,
								source: 'admin'
							});
						}
					});
				}
				
				debugLog('✅ Admin to index conversion completed:', {
					convertedNodes: Object.keys(indexData.nodes).length,
					convertedEdges: indexData.edges.length,
					building: indexData.currentBuilding
				});
				
				ADMIN_INDEX_BRIDGE.lastConversionError = null;
				return indexData;
				
			} catch (error) {
				debugLog('❌ Error in admin to index conversion:', error);
				ADMIN_INDEX_BRIDGE.lastConversionError = error.message;
				return null;
			}
		}

		// แปลงจาก index format เป็น admin format (COMPLETE VERSION)
		function convertIndexToAdminFormat(indexData) {
			if (!indexData || typeof indexData !== 'object') {
				debugLog('❌ Invalid index data for conversion');
				return null;
			}
			
			try {
				ADMIN_INDEX_BRIDGE.conversionCount++;
				debugLog('🔄 Converting index data to admin format...', {
					indexNodes: Object.keys(indexData.nodes || {}).length,
					indexEdges: (indexData.edges || []).length,
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				});
				
				const adminData = {
					// Core structure for admin.html
					currentBuilding: indexData.currentBuilding || indexData.building,
					building: indexData.currentBuilding || indexData.building,
					nodes: {},
					edges: [],
					settings: {
						maxConnectionDistance: indexData.settings?.maxSearchRadius || 25,
						metersPerPercent: indexData.settings?.metersPerPercent || 1.2,
						autoConnect: indexData.settings?.autoConnect !== false,
						snapToGrid: indexData.settings?.snapToGrid || false,
						gridSize: indexData.settings?.gridSize || 5
					},
					
					// Admin-specific properties
					selectedNodes: new Set(),
					isDragging: false,
					dragNode: null,
					
					// Bridge metadata
					dataSource: 'index',
					syncTime: new Date().toISOString(),
					originalFormat: 'index',
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				};
				
				// แปลง nodes
				if (indexData.nodes && typeof indexData.nodes === 'object') {
					for (const nodeId in indexData.nodes) {
						const indexNode = indexData.nodes[nodeId];
						if (indexNode && typeof indexNode === 'object') {
							adminData.nodes[nodeId] = {
								id: nodeId,
								x: parseFloat(indexNode.x) || 0,
								y: parseFloat(indexNode.y) || 0,
								type: indexNode.type || 'grid',
								building: indexNode.building || adminData.currentBuilding,
								isActive: indexNode.isActive !== false,
								source: 'index'
							};
						}
					}
				}
				
				// แปลง edges
				if (indexData.edges && Array.isArray(indexData.edges)) {
					indexData.edges.forEach((indexEdge, edgeIndex) => {
						if (indexEdge && typeof indexEdge === 'object') {
							adminData.edges.push({
								from: indexEdge.from,
								to: indexEdge.to,
								weight: parseFloat(indexEdge.weight) || 0,
								bidirectional: indexEdge.bidirectional !== false,
								building: indexEdge.building || adminData.currentBuilding,
								isActive: indexEdge.isActive !== false,
								edgeId: indexEdge.edgeId || `E${edgeIndex + 1}`,
								source: 'index'
							});
						}
					});
				}
				
				debugLog('✅ Index to admin conversion completed:', {
					convertedNodes: Object.keys(adminData.nodes).length,
					convertedEdges: adminData.edges.length,
					building: adminData.currentBuilding
				});
				
				ADMIN_INDEX_BRIDGE.lastConversionError = null;
				return adminData;
				
			} catch (error) {
				debugLog('❌ Error in index to admin conversion:', error);
				ADMIN_INDEX_BRIDGE.lastConversionError = error.message;
				return null;
			}
		}

		// ========== 4. Safe Data Sync Functions ==========

		// Sync admin data ไป index (SAFE VERSION)
		function syncAdminDataToIndex(building) {
			if (!ADMIN_INDEX_BRIDGE.isIndexMode()) {
				debugLog('⚠️ Not in index mode, sync skipped');
				return false;
			}
			
			debugLog('🔥 Syncing admin data to index...', { building });
			
			try {
				// โหลดข้อมูลจาก admin storage
				const adminKey = getSafeStorageKey(building, 'admin');
				const adminDataString = localStorage.getItem(adminKey);
				
				if (!adminDataString) {
					debugLog('ℹ️ No admin data found in storage');
					return false;
				}
				
				const adminData = JSON.parse(adminDataString);
				
				// ตรวจสอบว่าเป็นข้อมูลจาก admin หรือไม่ (ป้องกัน circular sync)
				if (adminData.dataSource === 'index') {
					debugLog('🔄 Data source is index, avoiding circular sync');
					return false;
				}
				
				// แปลงเป็น index format
				const indexData = convertAdminToIndexFormat(adminData);
				if (!indexData) {
					debugLog('❌ Failed to convert admin data to index format');
					return false;
				}
				
				// อัปเดต walkableRoutingData ถ้ามี
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					debugLog('✅ walkableRoutingData updated from admin');
				}
				
				// บันทึกใน index storage
				const indexKey = getSafeStorageKey(building, 'index');
				localStorage.setItem(indexKey, JSON.stringify(indexData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('✅ Admin data synced to index successfully', {
					adminKey,
					indexKey,
					nodes: Object.keys(indexData.nodes).length,
					edges: indexData.edges.length
				});
				
				return true;
				
			} catch (error) {
				debugLog('❌ Error syncing admin data to index:', error);
				return false;
			}
		}

		// Sync index data ไป admin (SAFE VERSION)  
		function syncIndexDataToAdmin(building) {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) {
				debugLog('⚠️ Not in admin mode, sync skipped');
				return false;
			}
			
			debugLog('🔤 Syncing index data to admin...', { building });
			
			try {
				// โหลดข้อมูลจาก index storage
				const indexKey = getSafeStorageKey(building, 'index');
				const indexDataString = localStorage.getItem(indexKey);
				
				if (!indexDataString) {
					debugLog('ℹ️ No index data found in storage');
					return false;
				}
				
				const indexData = JSON.parse(indexDataString);
				
				// ตรวจสอบว่าเป็นข้อมูลจาก index หรือไม่
				if (indexData.dataSource === 'admin') {
					debugLog('🔄 Data source is admin, avoiding circular sync');
					return false;
				}
				
				// แปลงเป็น admin format
				const adminData = convertIndexToAdminFormat(indexData);
				if (!adminData) {
					debugLog('❌ Failed to convert index data to admin format');
					return false;
				}
				
				// อัปเดต walkablePointsData ถ้ามี
				if (typeof walkablePointsData !== 'undefined') {
					Object.assign(walkablePointsData, adminData);
					
					// Render ใหม่ถ้ามีฟังก์ชัน
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
					
					debugLog('✅ walkablePointsData updated from index');
				}
				
				// บันทึกใน admin storage
				const adminKey = getSafeStorageKey(building, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(adminData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('✅ Index data synced to admin successfully', {
					indexKey,
					adminKey,
					nodes: Object.keys(adminData.nodes).length,
					edges: adminData.edges.length
				});
				
				return true;
				
			} catch (error) {
				debugLog('❌ Error syncing index data to admin:', error);
				return false;
			}
		}

		// ========== 5. Enhanced Data Loading Functions ==========

		// Load data สำหรับ admin.html (แทนที่ loadWalkableDataForBuilding เดิม)
		function loadWalkableDataForBuildingV2(building) {
			building = building || getCurrentBuildingName();
			debugLog('📂 Loading walkable data for building (v2)...', { building });
			
			// อัปเดต current building
			if (typeof walkablePointsData !== 'undefined') {
				walkablePointsData.currentBuilding = building;
			}
			
			try {
				// ลองโหลดจาก admin storage ก่อน
				const adminKey = getSafeStorageKey(building, 'admin');
				const adminDataString = localStorage.getItem(adminKey);
				
				if (adminDataString) {
					const adminData = JSON.parse(adminDataString);
					
					// อัปเดต walkablePointsData
					if (typeof walkablePointsData !== 'undefined') {
						Object.assign(walkablePointsData, adminData);
						
						// Render ใหม่
						if (typeof renderWalkablePoints === 'function') {
							renderWalkablePoints();
						}
						if (typeof updateWalkableStats === 'function') {
							updateWalkableStats();
						}
						if (typeof loadWalkableSettings === 'function') {
							loadWalkableSettings();
						}
					}
					
					debugLog('✅ Loaded admin walkable data', {
						nodes: Object.keys(adminData.nodes || {}).length,
						edges: (adminData.edges || []).length
					});
					return;
				}
				
				// ถ้าไม่มีข้อมูล admin ลองดูว่ามี index data ไหม
				const synced = syncIndexDataToAdmin(building);
				if (synced) {
					debugLog('✅ Synced index data to admin');
					return;
				}
				
				// ถ้าไม่มีข้อมูลใดๆ ให้สร้างข้อมูลเริ่มต้น
				debugLog('📋 No existing data, creating fresh admin data');
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.nodes = {};
					walkablePointsData.edges = [];
					walkablePointsData.currentBuilding = building;
					
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
				}
				
			} catch (error) {
				debugLog('❌ Error loading walkable data for building:', error);
				
				// Error fallback
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.nodes = {};
					walkablePointsData.edges = [];
					walkablePointsData.currentBuilding = building;
				}
			}
		}

		// Load data สำหรับ index.html (แทนที่ loadWalkableData เดิม)
		function loadWalkableDataWithAdminSyncV2(building) {
			building = building || getCurrentBuildingName();
			debugLog('📂 Loading walkable data with admin sync (v2)...', { building });
			
			// อัปเดต current building
			if (typeof walkableRoutingData !== 'undefined') {
				walkableRoutingData.currentBuilding = building;
			}
			
			try {
				// ลองโหลดจาก admin ก่อน (admin has priority)
				const adminSynced = syncAdminDataToIndex(building);
				if (adminSynced) {
					debugLog('✅ Loaded admin-created walkable data');
					return;
				}
				
				// ถ้าไม่มีข้อมูล admin ลองโหลดจาก index cache
				const indexKey = getSafeStorageKey(building, 'index');
				const indexDataString = localStorage.getItem(indexKey);
				
				if (indexDataString) {
					const indexData = JSON.parse(indexDataString);
					
					// อัปเดต walkableRoutingData
					if (typeof walkableRoutingData !== 'undefined') {
						Object.assign(walkableRoutingData, indexData);
					}
					
					debugLog('📋 Loaded cached index walkable data', {
						nodes: Object.keys(indexData.nodes || {}).length,
						edges: (indexData.edges || []).length
					});
					return;
				}
				
				// สุดท้ายถ้าไม่มีข้อมูลใดๆ ให้สร้าง fixed grid
				debugLog('🗏️ No existing data, creating fixed grid');
				if (typeof createFixedWalkableGrid === 'function') {
					createFixedWalkableGrid();
				} else if (typeof walkableRoutingData !== 'undefined') {
					// สร้างข้อมูลเริ่มต้นถ้าไม่มีฟังก์ชัน
					walkableRoutingData.nodes = {};
					walkableRoutingData.edges = [];
					walkableRoutingData.isInitialized = true;
				}
				
			} catch (error) {
				debugLog('❌ Error loading walkable data with admin sync:', error);
				
				// Error fallback
				if (typeof walkableRoutingData !== 'undefined') {
					walkableRoutingData.nodes = {};
					walkableRoutingData.edges = [];
					walkableRoutingData.isInitialized = false;
				}
			}
		}

		// ========== 6. Enhanced Save Functions ==========

		// Save data สำหรับ admin.html (แทนที่ saveWalkableData เดิม)
		function saveWalkableDataV2() {
			const building = getCurrentBuildingName();
			debugLog('💾 Saving walkable data (v2)...', { building });
			
			try {
				if (typeof walkablePointsData === 'undefined') {
					throw new Error('walkablePointsData not found');
				}
				
				// เพิ่ม metadata
				const dataToSave = {
					...walkablePointsData,
					building: building,
					currentBuilding: building,
					dataSource: 'admin',
					syncTime: new Date().toISOString(),
					timestamp: new Date().toISOString()
				};
				
				// บันทึกใน admin storage
				const adminKey = getSafeStorageKey(building, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(dataToSave));
				
				debugLog('✅ Admin data saved successfully', {
					adminKey,
					nodes: Object.keys(dataToSave.nodes || {}).length,
					edges: (dataToSave.edges || []).length
				});
				
				// Auto-sync to index ถ้าเปิดใช้งาน
				if (ADMIN_INDEX_BRIDGE.autoSyncOnChange) {
					const indexData = convertAdminToIndexFormat(dataToSave);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						debugLog('🔄 Auto-synced to index format');
					}
				}
				
				// แสดง notification ถ้ามีฟังก์ชัน
				if (typeof showNotification === 'function') {
					showNotification('💾 บันทึกข้อมูลจุดเดินแล้ว', 'success');
				}
				
			} catch (error) {
				debugLog('❌ Error saving walkable data:', error);
				
				if (typeof showNotification === 'function') {
					showNotification('❌ เกิดข้อผิดพลาดในการบันทึก', 'error');
				}
			}
		}

		// Save data สำหรับ index.html
		function saveWalkableDataV2ForIndex() {
			const building = getCurrentBuildingName();
			debugLog('💾 Saving walkable data for index (v2)...', { building });
			
			try {
				if (typeof walkableRoutingData === 'undefined') {
					throw new Error('walkableRoutingData not found');
				}
				
				// เพิ่ม metadata
				const dataToSave = {
					...walkableRoutingData,
					currentBuilding: building,
					dataSource: 'index',
					syncTime: new Date().toISOString()
				};
				
				// บันทึกใน index storage
				const indexKey = getSafeStorageKey(building, 'index');
				localStorage.setItem(indexKey, JSON.stringify(dataToSave));
				
				debugLog('✅ Index data saved successfully', {
					indexKey,
					nodes: Object.keys(dataToSave.nodes || {}).length,
					edges: (dataToSave.edges || []).length
				});
				
			} catch (error) {
				debugLog('❌ Error saving index walkable data:', error);
			}
		}

		// ========== 7. Debug and Status Functions ==========

		// แสดงสถานะ bridge system
		function debugBridgeStatus() {
			const building = getCurrentBuildingName();
			
			console.group('🔍 Bridge System Status');
			console.log('Environment:', {
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode(),
				building: building
			});
			
			console.log('Storage Keys:', {
				admin: getSafeStorageKey(building, 'admin'),
				index: getSafeStorageKey(building, 'index')
			});
			
			// ตรวจสอบข้อมูลใน localStorage
			const adminKey = getSafeStorageKey(building, 'admin');
			const indexKey = getSafeStorageKey(building, 'index');
			
			const adminData = localStorage.getItem(adminKey);
			const indexData = localStorage.getItem(indexKey);
			
			console.log('Storage Status:', {
				adminData: adminData ? 'EXISTS' : 'NOT FOUND',
				indexData: indexData ? 'EXISTS' : 'NOT FOUND'
			});
			
			if (adminData) {
				try {
					const parsed = JSON.parse(adminData);
					console.log('Admin Data:', {
						nodes: Object.keys(parsed.nodes || {}).length,
						edges: (parsed.edges || []).length,
						source: parsed.dataSource,
						syncTime: parsed.syncTime
					});
				} catch (e) {
					console.warn('⚠️ Admin data parsing error:', e);
				}
			}
			
			if (indexData) {
				try {
					const parsed = JSON.parse(indexData);
					console.log('Index Data:', {
						nodes: Object.keys(parsed.nodes || {}).length,
						edges: (parsed.edges || []).length,
						source: parsed.dataSource,
						syncTime: parsed.syncTime
					});
				} catch (e) {
					console.warn('⚠️ Index data parsing error:', e);
				}
			}
			
			console.log('Bridge Status:', {
				lastSync: ADMIN_INDEX_BRIDGE.lastSyncTime,
				conversionCount: ADMIN_INDEX_BRIDGE.conversionCount,
				lastError: ADMIN_INDEX_BRIDGE.lastConversionError
			});
			
			console.groupEnd();
		}

		// ทดสอบการแปลงข้อมูล
		function testDataConversion() {
			const building = getCurrentBuildingName();
			console.group('🧪 Testing Data Conversion');
			
			// สร้างข้อมูลทดสอบ
			const testAdminData = {
				currentBuilding: building,
				nodes: {
					'test1': { id: 'test1', x: 10, y: 20, type: 'center' },
					'test2': { id: 'test2', x: 30, y: 40, type: 'grid' }
				},
				edges: [
					{ from: 'test1', to: 'test2', weight: 25.5, bidirectional: true }
				],
				settings: { maxConnectionDistance: 30, metersPerPercent: 1.5 }
			};
			
			// ทดสอบ admin → index
			console.log('Testing admin → index conversion...');
			const indexResult = convertAdminToIndexFormat(testAdminData);
			console.log('Result:', indexResult);
			
			// ทดสอบ index → admin
			if (indexResult) {
				console.log('Testing index → admin conversion...');
				const adminResult = convertIndexToAdminFormat(indexResult);
				console.log('Result:', adminResult);
			}
			
			console.groupEnd();
		}

		// ล้างข้อมูลทั้งหมด (สำหรับ debug)
		function clearAllWalkableData(building) {
			building = building || getCurrentBuildingName();
			
			const adminKey = getSafeStorageKey(building, 'admin');
			const indexKey = getSafeStorageKey(building, 'index');
			
			localStorage.removeItem(adminKey);
			localStorage.removeItem(indexKey);
			
			// ล้าง old format data ด้วย (migration)
			const oldKey = `walkableData_${building}`;
			localStorage.removeItem(oldKey);
			
			console.log('🗑️ Cleared all walkable data for building:', building);
			debugBridgeStatus();
		}

		// ========== 8. Initialization and Integration ==========

		// เรียกใช้เมื่อ DOM ready
		function initializeBridgeSystem() {
			debugLog('🚀 Initializing Bridge System...');
			
			// ตรวจสอบ environment
			if (!ADMIN_INDEX_BRIDGE.isAdminMode() && !ADMIN_INDEX_BRIDGE.isIndexMode()) {
				debugLog('⚠️ Unknown environment, bridge system inactive');
				return;
			}
			
			// เพิ่ม debug commands ใน window
			if (ADMIN_INDEX_BRIDGE.debugMode) {
				window.debugBridgeStatus = debugBridgeStatus;
				window.testDataConversion = testDataConversion;
				window.clearAllWalkableData = clearAllWalkableData;
				window.ADMIN_INDEX_BRIDGE = ADMIN_INDEX_BRIDGE;
			}
			
			debugLog('✅ Bridge System initialized successfully');
			debugLog('🔧 Available debug commands: debugBridgeStatus(), testDataConversion(), clearAllWalkableData()');
		}

		// Auto-initialize เมื่อ script load
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initializeBridgeSystem);
		} else {
			initializeBridgeSystem();
		}

		// ========== 9. Helper Functions ==========

		function debugLog(message, data = null) {
			if (!ADMIN_INDEX_BRIDGE.debugMode) return;
			
			const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
			const prefix = `[${timestamp}] Bridge:`;
			
			if (data) {
				console.log(prefix, message, data);
			} else {
				console.log(prefix, message);
			}
		}

		// Export functions for global use
		window.PHASE_2_1_FUNCTIONS = {
			// Storage
			getSafeStorageKey,
			getCurrentBuildingName,
			
			// Conversion
			convertAdminToIndexFormat,
			convertIndexToAdminFormat,
			
			// Sync
			syncAdminDataToIndex,
			syncIndexDataToAdmin,
			
			// Loading
			loadWalkableDataForBuildingV2,
			loadWalkableDataWithAdminSyncV2,
			
			// Saving
			saveWalkableDataV2,
			saveWalkableDataV2ForIndex,
			
			// Debug
			debugBridgeStatus,
			testDataConversion,
			clearAllWalkableData
		};
		 
		// แทนที่ฟังก์ชัน loadWalkableData เดิม
		window.loadWalkableData = loadWalkableDataWithAdminSyncV2;

		// เพิ่มการ save index data
		window.saveWalkableDataForIndex = saveWalkableDataV2ForIndex;		 
		// ========== End Phase 2.1: Storage Key Separation + Complete Data Bridge ==========
	

        // ******************เรียกใช้การปรับปรุงประสิทธิภาพทุก 5 นาที *********************
		setInterval(optimizePerformance, 5 * 60 * 1000);
				
		// ***************** Start: initializeSystem ******************************
		async function initializeSystem() {
			try {
			 				
				clearDestination()
				showLoadingOverlay()
				await connectToGoogleSheets();
		 				
				// โหลดข้อมูลเริ่มต้น		
				await loadInitialData();
				
				// ตั้งค่า Event Handlers
				//setupMapEvents();
				setupWindowEvents();
				
				// Initialize map controls
				setMapLayout('floorplan');
				
				 // 🔧 เพิ่มตรงนี้
				ensureRouteAnimationCSS();
		 
				hideLoadingOverlay();
				
				// แสดงข้อความต้อนรับ
				setTimeout(() => {
					const welcomeMessage = currentLanguage === 'th' 
						? '🎉 ยินดีต้อนรับสู่ระบบแผนที่โรงเรียนอัจฉริยะ!' 
						: '🎉 Welcome to Smart School Map System!';
					showNotification(welcomeMessage, 'success');
				}, 1000);
				
				 
	
			} catch (error) {
				console.error('System initialization error:', error);
				const errorMessage = currentLanguage === 'th' 
					? '❌ ไม่สามารถเริ่มต้นระบบได้' 
					: '❌ System initialization failed';
				showProgressiveStatus(errorMessage, 'error');
				
				// แม้เกิดข้อผิดพลาดก็ยังให้ระบบทำงานได้ด้วยข้อมูลจำลอง
				try {
					await loadFallbackData();
					setupMapEvents();
					setupWindowEvents();
					showProgressiveStatus('⚠️ ใช้ข้อมูลจำลอง', 'warning');
				} catch (fallbackError) {
					console.error('Fallback initialization failed:', fallbackError);
					showProgressiveStatus('❌ ระบบไม่สามารถทำงานได้', 'error');
				}
			}
		}	
		
// ฟังก์ชันแสดงข้อความ landscape ใน globalVersionIndicator
function showLandscapeMessage() {
    const indicator = document.getElementById('globalVersionIndicator');
    if (!indicator) return;
    
    // เก็บ content เดิมไว้
    const originalContent = indicator.innerHTML;
    const originalClass = indicator.className;
    const originalStyle = indicator.style.cssText;
    
    // แสดงข้อความแนะนำ
    indicator.innerHTML = 'หมุนแนวตั้งกลับสู่เมนู';
    indicator.className = 'status-indicator status-error';
    indicator.style.cssText = `
        position: absolute !important;
        top: 5px !important;
        right: 10px !important;
        z-index: 9999 !important;
        font-size: 10px !important;
        padding: 4px 8px !important;
        background: rgba(220, 53, 69, 0.9) !important;
        color: white !important;
        border-radius: 15px !important;
        animation: landscapePulse 1.5s ease-in-out infinite !important;
        cursor: pointer !important;
        max-width: 180px !important;
        text-align: center !important;
        line-height: 1.2 !important;
    `;
    
    // เพิ่ม animation CSS ถ้ายังไม่มี
    if (!document.getElementById('landscape-animation')) {
        const style = document.createElement('style');
        style.id = 'landscape-animation';
        style.textContent = `
            @keyframes landscapePulse {
                0%, 100% { 
                    opacity: 0.8;
                    transform: scale(1);
                }
                50% { 
                    opacity: 1;
                    transform: scale(1.05);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Auto hide หลัง 4 วินาที
    setTimeout(() => {
        if (indicator) {
            indicator.innerHTML = originalContent;
            indicator.className = originalClass;
            indicator.style.cssText = originalStyle;
        }
    }, 4000);
}

// ฟังก์ชันซ่อนข้อความ landscape
function hideLandscapeMessage() {
    const indicator = document.getElementById('globalVersionIndicator');
    if (!indicator) return;
    
    // รีเซ็ตกลับเป็นปกติทันที
    indicator.innerHTML = '';
    indicator.className = 'status-indicator status-connected';
    indicator.style.cssText = `
        position: absolute;
        top: 2px;
        right: 10px;
        z-index: 200;
        font-size: 8px;
        padding: 1px 6px;
        border-radius: 8px;
    `;
}

// ตรวจสอบ orientation และ page
function checkLandscapeConditions() {
    const isLandscape = window.matchMedia('(orientation: landscape)').matches;
    const isMaxHeight500 = window.matchMedia('(max-height: 500px)').matches;
    const isMapPage = document.body.classList.contains('map-page') || 
                     document.body.getAttribute('data-current-page') === 'map';
    
    return isLandscape && isMaxHeight500 && isMapPage;
}

// Event listeners สำหรับ orientation change
function setupLandscapeMessageListener() {
    // ตรวจสอบครั้งแรก
    if (checkLandscapeConditions()) {
        setTimeout(showLandscapeMessage, 500); // หน่วงเล็กน้อยให้ UI settle
    }
    
    // ฟัง orientation changes
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (checkLandscapeConditions()) {
                showLandscapeMessage();
            } else {
                hideLandscapeMessage();
            }
        }, 300); // หน่วงให้ orientation change เสร็จก่อน
    });
    
    // ฟัง resize events (backup)
    window.addEventListener('resize', () => {
        setTimeout(() => {
            if (checkLandscapeConditions()) {
                showLandscapeMessage();
            } else {
                hideLandscapeMessage();
            }
        }, 100);
    });
    
    // ฟัง page changes
    const originalShowPage = window.showPage;
    if (originalShowPage) {
        window.showPage = function(pageId) {
            const result = originalShowPage.apply(this, arguments);
            
            setTimeout(() => {
                if (checkLandscapeConditions()) {
                    showLandscapeMessage();
                } else {
                    hideLandscapeMessage();
                }
            }, 100);
            
            return result;
        };
    }
}

// CSS สำหรับซ่อน header-top และ bottom-navigation ใน landscape
function addLandscapeCSS() {
    if (document.getElementById('landscape-css')) return;
    
    const style = document.createElement('style');
    style.id = 'landscape-css';
    style.textContent = `
        /* ========== Mobile Landscape: ซ่อน UI elements เฉพาะในหน้าแผนที่ ========== */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            /* ซ่อน header-top เฉพาะเมื่ออยู่ในหน้าแผนที่ */
            body.map-page .header-top,
            body[data-current-page="map"] .header-top {
                display: none !important;
				
			/* จำกัดขนาดแผนที่ในโหมด landscape */
			body.map-page .map-area,
			body[data-current-page="map"] .map-area {
				max-height: calc(100vh - 20px) !important;
				max-width: calc(100vw - 20px) !important;
				overflow: hidden !important;
				margin: 10px auto !important;
				box-sizing: border-box !important;
			}
			
			/* จำกัดขนาดรูปแผนที่ */
			body.map-page .map-image,
			body[data-current-page="map"] .map-image {
				max-height: calc(100vh - 40px) !important;
				max-width: calc(100vw - 40px) !important;
				width: auto !important;
				height: auto !important;
				object-fit: contain !important;
				object-position: center !important;
			}
			
			/* ปรับ map container */
			body.map-page .map-container,
			body[data-current-page="map"] .map-container {
				max-height: 100vh !important;
				overflow: hidden !important;
			}
            }
            
            /* ซ่อน bottom navigation เฉพาะเมื่ออยู่ในหน้าแผนที่ */
            body.map-page .bottom-navigation,
            body[data-current-page="map"] .bottom-navigation {
                display: none !important;
            }
            
            /* ปรับ body padding เฉพาะเมื่ออยู่ในหน้าแผนที่ */
            body.map-page,
            body[data-current-page="map"] {
                padding-bottom: 0 !important;
            }
            
            /* ลด header size เฉพาะเมื่ออยู่ในหน้าแผนที่ */
            body.map-page .header,
            body[data-current-page="map"] .header {
                padding: 5px 20px !important;
                margin-bottom: 5px !important;
            }
        }
        
        /* ========== Portrait Reset ========== */
        @media screen and (orientation: portrait) {
            .header-top {
                display: flex !important;
            }
            
            .bottom-navigation {
                display: flex !important;
            }
            
            body {
                padding-bottom: var(--content-padding-bottom) !important;
            }
            
            .header {
                padding: 15px 20px !important;
                margin-bottom: 15px !important;
            }
        }
    `;
    document.head.appendChild(style);
}

// เรียกใช้ทั้งหมด
function initializeLandscapeMessage() {
    console.log('🔄 Initializing landscape message system...');
    
    addLandscapeCSS();
    setupLandscapeMessageListener();
    
    console.log('✅ Landscape message system initialized');
}

// Auto initialize
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeLandscapeMessage);
} else {
    initializeLandscapeMessage();
}		
		
		
		// *****************  End: initializeSystem ******************************
        console.log('🎉 ระบบแผนที่โรงเรียนอัจฉริยะ Version1.3 Enhanced: Dikstra Admin-Index Integrtaion Bridge LATEST UPDATE!');
     
    </script>
</body>
</html>