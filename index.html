<!DOCTYPE html>   
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="loading" content="eager">
	<meta name="referrer" content="no-referrer-when-downgrade">
	<meta http-equiv="Content-Security-Policy" content="img-src 'self' data: https: http:;">

    <title>‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞ Version1.3 - User Interface</title>
    
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
	<style id="gallery-enhanced-styles">
	
	/* =================== Loading Overlay =================== */
		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0,0,0,0.8);
			z-index: 9999;
			display: none;
			align-items: center;
			justify-content: center;
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		.loading-content {
			background: var(--card-background);
			border-radius: var(--border-radius);
			padding: 40px;
			text-align: center;
			max-width: 400px;
			margin: 20px;
			box-shadow: 0 25px 50px rgba(0,0,0,0.3);
		}

		.loading-spinner {
			width: 50px;
			height: 50px;
			border: 4px solid #f3f3f3;
			border-top: 4px solid var(--primary-color);
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin: 0 auto 20px;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}


    /* Gallery Container */
    #overlayRoomGallery {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--border-color, #ddd);
        border-radius: 8px;
        padding: 15px;
        background: var(--background-color, #fff);
        margin-top: 15px;
        display: none; /* ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ã‡πà‡∏≠‡∏ô‡πÑ‡∏ß‡πâ */
    }
    
    /* Gallery Items */
    .gallery-item {
        position: relative;
        margin-bottom: 15px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .gallery-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    }
    
    .gallery-item:last-child {
        margin-bottom: 0;
    }
    
    /* Gallery Images */
    .gallery-item img {
        width: 100%;
        height: auto;
        max-height: 300px;
        object-fit: cover;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s ease;
        display: block;
        background: #f5f5f5;
    }
    
    .gallery-item img:hover {
        transform: scale(1.02);
    }
    
    /* Loading state */
    .gallery-item img[src=""] {
        background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
        background-size: 200% 100%;
        animation: loading 2s infinite;
        min-height: 200px;
    }
    
    @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    
    /* Error Fallback */
    .image-error-fallback {
        display: none;
        text-align: center;
        padding: 40px 20px;
        background: #f8f9fa;
        border: 2px dashed #dee2e6;
        border-radius: 8px;
        color: #6c757d;
        font-size: 14px;
    }
    
    .image-error-fallback i {
        font-size: 48px;
        color: #dc3545;
        margin-bottom: 15px;
        opacity: 0.7;
    }
    
    /* Debug Info */
    .gallery-debug {
        font-family: 'Courier New', monospace;
        font-size: 11px;
        opacity: 0.7;
        margin-top: 10px;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
        word-break: break-all;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
        #overlayRoomGallery {
            max-height: 300px;
            padding: 10px;
        }
        
        .gallery-item img {
            max-height: 200px;
        }
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
        #overlayRoomGallery {
            background: var(--dark-background, #2d3748);
            border-color: var(--dark-border, #4a5568);
        }
        
        .image-error-fallback {
            background: #4a5568;
            border-color: #718096;
            color: #e2e8f0;
        }
        
        .gallery-debug {
            background: #4a5568;
            color: #e2e8f0;
        }
    }
</style>
    <style>
        /* =================== CSS Variables =================== */
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            
            --background-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --card-background: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #e0e6ff;
            
            --border-radius: 15px;
            --box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
            
            --bottom-nav-height: 70px;
            --content-padding-bottom: 85px;
        }

        /* =================== Base Styles =================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background-gradient);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
            transition: var(--transition);
            padding-bottom: var(--content-padding-bottom);
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
        }

        /* =================== Header =================== */
        .header {
			position: relative; /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ position absolute ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ */
            background: var(--card-background);
            padding: 15px 20px;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 15px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
		.header .status-indicator {
			position: absolute;
			top: 2px;                   /* ‡∏•‡∏î‡∏à‡∏≤‡∏Å 5px */
			right: 10px;               /* ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å center ‡πÄ‡∏õ‡πá‡∏ô right */
			z-index: 200;
			font-size: 8px;            /* ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á‡∏≠‡∏µ‡∏Å */
			padding: 1px 6px;          /* ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á‡∏≠‡∏µ‡∏Å */
			border-radius: 8px;
		}
		
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .school-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
        }

        .header-title {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            color: var(--text-primary);
            margin: 0;
            font-size: 1.4em;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-top: 5px;
        }

        .header-btn {
            background: var(--card-background);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 8px 12px;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            color: var(--primary-color);
            font-size: 12px;
        }

        .header-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .language-btn {
            background: linear-gradient(135deg, var(--info-color), var(--primary-color));
            color: white;
            border: none;
        }

        /* =================== Bottom Navigation =================== */
        .bottom-navigation {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--bottom-nav-height);
            background: var(--card-background);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
        }

        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            padding: 8px 4px;
            position: relative;
            color: var(--text-secondary);
        }

        .nav-item.active {
            color: var(--primary-color);
        }

        .nav-item:hover {
            color: var(--primary-color);
            transform: translateY(-2px);
        }

        .nav-item i {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .nav-item span {
            font-size: 10px;
            font-weight: 600;
        }

        .nav-item.active::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: var(--primary-color);
            border-radius: 0 0 10px 10px;
        }
		/* =================== Status Indicators =================== */
		/* ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Version Indicator ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á ======= */
			.status-indicator {
				padding: 2px 8px;           /* ‡∏•‡∏î‡∏à‡∏≤‡∏Å 4px 12px */
				border-radius: 12px;        /* ‡∏•‡∏î‡∏à‡∏≤‡∏Å 20px */
				font-size: 9px;             /* ‡∏•‡∏î‡∏à‡∏≤‡∏Å 11px */
				font-weight: 500;           /* ‡∏•‡∏î‡∏à‡∏≤‡∏Å 600 */
				text-transform: uppercase;
				opacity: 0.8;               /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÉ‡∏™ */
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
			}

		.status-active {
			background: rgba(40, 167, 69, 0.1);
			color: var(--accent-color);
		}

		.status-inactive {
			background: rgba(108, 117, 125, 0.1);
			color: #6c757d;
		}

		.status-connected {
			background: rgba(23, 162, 184, 0.1);
			color: var(--info-color);
		}

		.status-error {
			background: rgba(220, 53, 69, 0.1);
			color: var(--danger-color);
		}

		/* =================== Loading Overlay =================== */
		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0,0,0,0.8);
			z-index: 9999;
			display: none;
			align-items: center;
			justify-content: center;
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		.loading-content {
			background: var(--card-background);
			border-radius: var(--border-radius);
			padding: 40px;
			text-align: center;
			max-width: 400px;
			margin: 20px;
			box-shadow: 0 25px 50px rgba(0,0,0,0.3);
		}

		.loading-spinner {
			width: 50px;
			height: 50px;
			border: 4px solid #f3f3f3;
			border-top: 4px solid var(--primary-color);
			border-radius: 50%;
			animation: spin 1s linear infinite;
			margin: 0 auto 20px;
		}

		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}

        /* =================== Page Styles =================== */
        .page {
            display: none;
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            margin-bottom: 15px;
            min-height: calc(100vh - 200px);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .page.active {
            display: block;
            animation: fadeInUp 0.4s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* =================== Search Styles =================== */
        .search-container {
            background: linear-gradient(135deg, #f8f9ff, #e6f3ff);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .search-box {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .search-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(255,255,255,0.9);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
            background: white;
        }

        .search-btn {
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: var(--transition);
            white-space: nowrap;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .quick-categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .category-card {
            background: var(--card-background);
            padding: 20px;
            border-radius: var(--border-radius);
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid var(--border-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--box-shadow);
            border-color: var(--primary-color);
        }

        .category-card i {
            font-size: 32px;
            color: var(--primary-color);
            margin-bottom: 12px;
        }

        .category-card h4 {
            color: var(--primary-color);
            margin-bottom: 8px;
            font-size: 16px;
        }

        .category-card p {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* =================== Map Styles =================== */
        .map-container {
            position: relative;
            margin-top: 20px;
			width: 100%;
			max-width: 100%;  /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏•‡πâ‡∏ô */
        }

        /* Map controls with toggle functionality */
        .map-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            position: relative;
        }
		
		/* ========== Fullscreen mode enhancements ========== */
			
		.header {
			transition: transform 0.3s ease, opacity 0.3s ease;
		}

		body.fullscreen-active .header {
			height: 8px !important;
			padding: 1px !important;
			min-height: 8px !important;
			overflow: hidden !important;
			opacity: 0.3 !important;
		}
		
		body.fullscreen-active .container > *:not(.map-section) {
			display: none !important;
		}

		body.fullscreen-active .map-section > *:not(.map-area):not(.map-controls) {
			display: none !important;
		}

		.bottom-navigation {
			transition: transform 0.3s ease, opacity 0.3s ease;
		}

		body.fullscreen-active .bottom-navigation {
			height: 8px !important;
			padding: 1px !important;
			min-height: 8px !important;
			overflow: hidden !important;
			opacity: 0.3 !important;
		}
 
		body.fullscreen-active .map-container {
			position: fixed !important;
			top: 0 !important;
			left: 0 !important;
			width: 100vw !important;
			height: 100vh !important;
			z-index: 10000 !important;
			background: #f5f5f5 !important;
		}

		body.fullscreen-active .map-area {
			width: 100% !important;
			height: 100% !important;
			display: flex !important;
			align-items: center !important;
			justify-content: center !important;
		}

		body.fullscreen-active .map-image {
			max-width: 95% !important;
			max-height: 95% !important;
			object-fit: contain !important;
			object-position: center !important;
		}

		/* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö landscape fullscreen */
		@media screen and (orientation: landscape) and (max-height: 500px) {
			body.fullscreen-active .map-image {
				max-width: 98% !important;
				max-height: 98% !important;
			}
}

		body.fullscreen-active {
			padding-bottom: 8px !important;
			padding-top: 8px !important;
			background: #f5f5f5 !important;
			overflow: hidden !important;
		}
		
		body.fullscreen-active .container > *:not(.map-section) {
			display: none !important;
		}

		body.fullscreen-active .map-section > *:not(.map-area):not(.map-controls) {
			display: none !important;
		}

		body.fullscreen-active .map-area.fullscreen {
			display: flex !important;
			visibility: visible !important;
		}

		body.fullscreen-active .map-area.fullscreen .map-image {
			display: block !important;
			visibility: visible !important;
		}
                           
		body.fullscreen-active .route-path {
			position: absolute !important;
			top: 0 !important;
			left: 0 !important;
			width: 100% !important;
			height: 100% !important;
			pointer-events: none !important;
		}
		/* ========== end of Fullscreen mode enhancements ========== */
		.map-controls.fullscreen-controls {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 2000;
			background: rgba(255,255,255,0.95);
			padding: 8px;
			border-radius: var(--border-radius);
			box-shadow: var(--box-shadow);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}
		
		.map-controls.fullscreen-controls {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 2000;
			background: rgba(255,255,255,0.95);
			padding: 8px;
			border-radius: var(--border-radius);
			box-shadow: var(--box-shadow);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		.map-controls.fullscreen-controls .map-control-btn {
			display: block;
			margin-bottom: 5px;
		}

		.map-controls.fullscreen-controls .map-control-btn:last-child {
			margin-bottom: 0;
		}
		
        .map-controls.hidden .map-control-btn:not(.toggle-btn) {
            display: none;
        }
		.show-controls-btn {
			position: fixed;
			top: 20px;
			right: 20px;
			padding: 10px 15px;
			background: var(--warning-color);
			color: var(--text-primary);
			border: 2px solid var(--warning-color);
			border-radius: var(--border-radius);
			cursor: pointer;
			font-size: 12px;
			font-weight: 600;
			z-index: 1001;
			box-shadow: var(--box-shadow);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
			transition: var(--transition);
			display: none;
		}

		.show-controls-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 8px 20px rgba(0,0,0,0.2);
		}

        .map-control-btn {
            padding: 10px 15px;
            background: rgba(255,255,255,0.95);
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .map-control-btn.active {
            background: var(--primary-color);
            color: white;
        }

        .map-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .toggle-btn {
            background: var(--warning-color);
            color: var(--dark-color);
            border-color: var(--warning-color);
        }

        /* Room selection overlay for choosing action */
         .room-action-overlay {
            position: absolute;
            background: var(--card-background);
            border: 8px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: var(--box-shadow);
            z-index: 200;
            display: none;
            min-width: 200px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
			top: 50%;         /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà */
			left: 50%;        /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà */
			transform: translate(-50%, -50%); /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà */
        }
 
        .room-action-header {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 14px;
        }

        .room-action-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: var(--card-background);
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .room-action-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-1px);
        }

        .room-action-btn:last-child {
            margin-bottom: 0;
        }

      		
		.map-area {
			position: relative;
			width: 100%;
			min-height: 400px;  /* ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö desktop */
			background: #f5f5f5;
			border-radius: var(--border-radius);
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
		}


        .map-image {
			width: 100%;
			height: 100%;
			object-fit: contain;  /* ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô + ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏£‡∏π‡∏õ */
			object-position: center;
			display: block;
			border-radius: var(--border-radius);
		}


        .map-image:hover {
            filter: brightness(1.05);
        }

        /* Route Controls - moved outside map */
        .route-controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .route-control-btn {
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .route-control-btn:hover {
            transform: translateY(-2px);
        }

        .route-control-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .clear-route-btn {
            background: var(--danger-color);
        }

        /* Room Markers */
        .room-marker {
            position: absolute;
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            transition: var(--transition);
            border: 3px solid white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 30;
            transform: translate(-50%, -50%);
        }

        .room-marker:hover {
            transform: translate(-50%, -50%) scale(1.3);
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .room-marker.highlighted {
            background: var(--danger-color);
            animation: pulse 2s infinite;
            transform: translate(-50%, -50%) scale(1.3);
        }

        .start-point-marker {
            background: var(--accent-color);
            width: 40px;
            height: 40px;
            font-size: 18px;
            animation: startPointPulse 3s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        @keyframes startPointPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                box-shadow: 0 0 0 15px rgba(40, 167, 69, 0);
            }
        }
		
		@keyframes pulse {
		0% {
			transform: scale(1);
			box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
		}
		70% {
			transform: scale(1.05);
			box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
		}
		100% {
			transform: scale(1);
			box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
		}
	}

      /* ========== 2. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Route Path Style ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ ========== */
	.route-path {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		z-index: 15;
		overflow: visible;
	}

	/* ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ */
	.route-line {
		stroke: #4285f4 !important;
		stroke-width: 2.5 !important; /* ‡∏¢‡πà‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡∏•‡∏á */
		fill: none !important;
		stroke-linecap: round !important;
		stroke-linejoin: round !important;
		opacity: 0.8 !important;
	}

	/* ‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏£‡∏≠‡∏ö‡∏Ç‡∏≤‡∏ß (‡πÑ‡∏°‡πà‡∏°‡∏µ glow) */
	.route-line-border {
		stroke: white !important;
		stroke-width: 4 !important; /* ‡∏¢‡πà‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡∏•‡∏á */
		fill: none !important;
		stroke-linecap: round !important;
		stroke-linejoin: round !important;
		opacity: 0.9 !important;
	}
	
	/* Animation ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ */
	@keyframes route-flow {
		0% { stroke-dashoffset: 0; }
		100% { stroke-dashoffset: -15; }
	}

	.route-line-animated {
		stroke: #4285f4 !important;
		stroke-width: 2.5 !important;
		fill: none !important;
		stroke-linecap: round !important;
		stroke-linejoin: round !important;
		stroke-dasharray: 8 4 !important;
		animation: route-flow 2s linear infinite !important;
	}

	/* ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß) - ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ */
	.route-start-marker {
		fill: #34a853 !important;
		stroke: white !important;
		stroke-width: 1.5 !important;
		r: 4 !important;
	}

	/* ‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á (‡πÅ‡∏î‡∏á) - ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ */
	.route-end-marker {
		fill: #ea4335 !important;
		stroke: white !important;
		stroke-width: 1.5 !important;
		r: 4 !important;
	}

	/* Waypoints (‡∏à‡∏∏‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏≤‡∏á) - ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ */
	.route-waypoint {
		fill: #fbbc04 !important;
		stroke: white !important;
		stroke-width: 1 !important;
		r: 3 !important;
	}
	
	
	 /* ========== Mobile Landscape: ‡∏ã‡πà‡∏≠‡∏ô header-top ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ========== */ 
@media screen and (orientation: landscape) and (max-height: 500px) {
    /* ‡∏ã‡πà‡∏≠‡∏ô header-top ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
    body.map-page .header-top,
    body[data-current-page="map"] .header-top {
        display: none !important;
    }
    
    /* ‡∏ã‡πà‡∏≠‡∏ô bottom navigation ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
    body.map-page .bottom-navigation,
    body[data-current-page="map"] .bottom-navigation {
        display: none !important;
    }
    
    /* ‡∏õ‡∏£‡∏±‡∏ö body padding ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
    body.map-page,
    body[data-current-page="map"] {
        padding-bottom: 0 !important;
    }
    
    /* ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
    body.map-page .header::after,
    body[data-current-page="map"] .header::after {
        content: "‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡πÄ‡∏°‡∏ô‡∏π‡∏õ‡∏Å‡∏ï‡∏¥‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á" !important;
        display: block !important;
        color: white !important;
        font-size: 11px !important;
        text-align: center !important;
        font-weight: 500 !important;
        padding: 8px 0 !important;
        background: none !important;
    }
}

/* ========== Mobile Portrait: ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ ========== */
@media screen and (orientation: portrait) {
    /* ‡πÅ‡∏™‡∏î‡∏á header-top ‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    .header-top {
        display: flex !important;
    }
    
    /* ‡∏ã‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    .header::after {
        display: none !important;
    }
    
    /* ‡πÅ‡∏™‡∏î‡∏á bottom navigation ‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    .bottom-navigation {
        display: flex !important;
    }
    
    /* ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï body padding ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    body {
        padding-bottom: var(--content-padding-bottom) !important;
    }
}
/* ========== Mobile Portrait: ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ ========== */
@media screen and (orientation: portrait) and (max-width: 768px) {
    /* ‡πÅ‡∏™‡∏î‡∏á header-top ‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    .header-top {
        display: flex !important;
    }
    
    /* ‡∏ã‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    .header::after {
        display: none !important;
    }
    
    /* ‡πÅ‡∏™‡∏î‡∏á bottom navigation ‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    .bottom-navigation {
        display: flex !important;
    }
    
    /* ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï body padding ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ */
    body {
        padding-bottom: var(--content-padding-bottom) !important;
    }
}
		
		/* ‡∏õ‡∏£‡∏±‡∏ö toolbar ‡πÉ‡∏ô landscape */
		body.map-page .map-toolbar,
		body[data-current-page="map"] .map-toolbar {
			position: absolute;
			top: 10px;
			right: 10px;
			z-index: 100;
			background: rgba(255,255,255,0.9);
			border-radius: 8px;
			padding: 5px;
		}
	}

	/* Mobile responsive - ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° */
	@media (max-width: 768px) {
		.route-line,
		.route-line-animated {
			stroke-width: 2 !important; /* ‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡πÉ‡∏ô mobile */
		}
		
		.route-line-border {
			stroke-width: 3.5 !important;
		}
		
		.route-start-marker,
		.route-end-marker {
			r: 3.5 !important;
			stroke-width: 1 !important;
		}
		
		.route-waypoint {
			r: 2.5 !important;
			stroke-width: 0.8 !important;
		}
	}

		@media (max-width: 480px) {
			.route-line,
			.route-line-animated {
				stroke-width: 1.8 !important; /* ‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î‡πÉ‡∏ô mobile ‡πÄ‡∏•‡πá‡∏Å */
			}
			
			.route-line-border {
				stroke-width: 3 !important;
			}
			
			.route-start-marker,
			.route-end-marker {
				r: 3 !important;
				stroke-width: 1 !important;
			}
			
			.route-waypoint {
				r: 2 !important;
				stroke-width: 0.5 !important;
			}
		}

/*      
	  .waypoint-marker {
            fill: var(--warning-color);
            stroke: white;
            stroke-width: 3;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            animation: waypoint-pulse 2s ease-in-out infinite;
        }
*/
        @keyframes dash {
            to {
                stroke-dashoffset: -25;
            }
        }

        @keyframes waypoint-pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.3);
                opacity: 1;
            }
        }

        /* FIX 5: Building Filter */
        .building-filter {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .building-filter h4 {
            margin-bottom: 10px;
            color: var(--primary-color);
            font-size: 14px;
        }

        .building-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .building-btn {
            padding: 8px 12px;
            background: var(--card-background);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .building-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .building-btn:hover {
            border-color: var(--primary-color);
            transform: translateY(-1px);
        }

        /* =================== Room Info Overlay =================== */
        .room-info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1500;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .room-info-content {
            background: var(--card-background);
            border-radius: var(--border-radius);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .room-info-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 25px;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            position: relative;
        }

        .room-info-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .room-info-close:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .room-info-body {
            padding: 25px;
        }

        .navigation-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .nav-control-btn {
            flex: 1;
            padding: 15px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: var(--transition);
            text-align: center;
        }

        .nav-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .nav-control-btn:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
        }

        .voice-btn {
            background: var(--accent-color);
        }

        .voice-btn.speaking {
            background: var(--danger-color);
            animation: voice-pulse 1s infinite;
        }

        @keyframes voice-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Compact Info */
        .compact-info {
			display: flex;
			gap: 10px;
			margin-bottom: 15px;
			flex-wrap: wrap;
			justify-content: space-between;
		}

		.info-item {
			background: rgba(255,255,255,0.8);
			padding: 8px 12px;
			border-radius: 8px;
			text-align: center;
			border-left: 3px solid var(--primary-color);
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
			flex: 1;
			min-width: 0;
		}

        .info-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Route Steps */
        .route-steps {
            background: var(--card-background);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-top: 15px;
        }

        .route-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .route-step:last-child {
            border-bottom: none;
        }

        .step-number {
            background: var(--primary-color);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
            font-size: 14px;
        }

        .step-distance {
            background: rgba(102, 126, 234, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            color: var(--primary-color);
            font-weight: 600;
        }

        .step-voice-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Search Results */
        .live-results {
            margin-top: 15px;
        }

        .search-result-item {
            background: var(--card-background);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: var(--border-radius);
            cursor: pointer;
            border-left: 4px solid var(--primary-color);
            transition: var(--transition);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid var(--border-color);
        }

        .search-result-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--box-shadow);
            border-color: var(--primary-color);
        }

        .search-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .search-result-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 16px;
        }

        .search-result-code {
            background: var(--primary-color);
            color: white;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
        }

        .search-result-info {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* =================== Notification =================== */
        .notification {
            position: fixed;
            top: 90px;
            right: 20px;
            padding: 15px 25px;
            background: var(--accent-color);
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            opacity: 0;
            transform: translateX(350px);
            transition: var(--transition);
            z-index: 3000;
            max-width: 320px;
            font-size: 14px;
            font-weight: 500;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.error { background: var(--danger-color); }
        .notification.warning { background: var(--warning-color); color: #333; }
        .notification.info { background: var(--info-color); }

        /* =================== Hidden Elements =================== */
        .hidden {
            display: none !important;
        }

        /* =================== Responsive Design =================== */
        @media (min-width: 768px) {
            .container {
                max-width: 1200px;
                padding: 25px;
            }
            
            .quick-categories {
                grid-template-columns: repeat(4, 1fr);
            }

            .bottom-navigation {
                justify-content: center;
                gap: 40px;
                max-width: 600px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: var(--border-radius) var(--border-radius) 0 0;
            }

            .nav-item {
                flex: none;
                min-width: 80px;
            }
        }
		
		@media (max-width: 480px) {
			.compact-info { gap: 5px; }
			.info-item { padding: 6px 8px; flex: 1; min-width: 0; }
			.info-label { font-size: 9px; margin-bottom: 1px; }
			.info-value { font-size: 11px; }
		}
		
		/* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç responsive ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mobile */
		@media (max-width: 768px) {
			.header .status-indicator {
				top: 1px;
				right: 5px;
				font-size: 7px;
				padding: 1px 4px;
			}
			
			.map-area {
			min-height: 250px;  /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÉ‡∏ô mobile */
			}
			
			.map-image {
				object-fit: contain;  /* ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mobile */
				max-height: 100%;
				max-width: 100%;
			}
		}
		
		@media (max-width: 480px) {
		.map-area {
			min-height: 200px;  /* ‡∏•‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mobile ‡πÄ‡∏•‡πá‡∏Å */
		}
		
		/* ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö About Page ‡∏ó‡∏µ‡πà responsive */
		@media (max-width: 768px) {
			#about-page h1 {
				font-size: 1.5em !important;
			}
			
			#about-page .page h2 {
				font-size: 1.3em !important;
			}
			
			#about-page [style*="font-size: 64px"] {
				font-size: 48px !important;
			}
			
			#about-page [style*="font-size: 48px"] {
				font-size: 36px !important;
			}
			
			#about-page [style*="padding: 30px"] {
				padding: 20px !important;
			}
			
			#about-page [style*="padding: 25px"] {
				padding: 20px !important;
			}
			
			#about-page [style*="width: 60px; height: 60px"] {
				width: 50px !important;
				height: 50px !important;
				font-size: 20px !important;
			}
		}

		@media (max-width: 480px) {
			#about-page [style*="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr))"] {
				grid-template-columns: 1fr !important;
			}
			
			#about-page [style*="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr))"] {
				grid-template-columns: 1fr !important;
			}
			
			#about-page [style*="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))"] {
				grid-template-columns: repeat(2, 1fr) !important;
			}
			
			#about-page [style*="padding: 20px"] {
				padding: 15px !important;
			}
		}
    </style>
	
		<!-- ‡πÄ‡∏û‡∏¥‡πà‡∏° Script ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Enhanced Image Loading -->
	<script>
	// üîß Enhanced Image Loading with CORS handling
	document.addEventListener('DOMContentLoaded', function() {
		// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ global image error handler
		window.addEventListener('error', function(e) {
			if (e.target && e.target.tagName === 'IMG') {
				console.warn('üñºÔ∏è Global image error:', e.target.src);
				
				// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ CORS
				if (e.target.hasAttribute('crossorigin')) {
					console.log('üîÑ Retrying without CORS...');
					e.target.removeAttribute('crossorigin');
					e.target.src = e.target.src + '?retry=' + Date.now();
				}
			}
		}, true);
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° observer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö dynamic images
		if (window.MutationObserver) {
			const observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(mutation) {
					mutation.addedNodes.forEach(function(node) {
						if (node.nodeType === 1 && node.tagName === 'IMG') {
							console.log('üîç New image detected:', node.src);
						}
					});
				});
			});
			
			observer.observe(document.body, {
				childList: true,
				subtree: true
			});
		}
	});

	// üîß Force reload images function
	window.forceReloadGalleryImages = function() {
		const galleryImages = document.querySelectorAll('#roomGalleryImages img');
		console.log('üîÑ Force reloading', galleryImages.length, 'gallery images');
		
		galleryImages.forEach((img, index) => {
			const originalSrc = img.src;
			img.src = '';
			setTimeout(() => {
				img.src = originalSrc + '?reload=' + Date.now();
				console.log(`üîÑ Reloaded image ${index + 1}:`, img.src);
			}, index * 100); // Stagger loading
		});
	};
	// ========== 1. Enhanced ADMIN_INDEX_BRIDGE ==========

		const ADMIN_INDEX_BRIDGE = {
			// Environment detection
			isAdminMode: () => window.location.pathname.includes('admin.html'),
			isIndexMode: () => window.location.pathname.includes('index.html'),
			
			// Data format identification
			adminFormat: 'walkablePointsData',
			indexFormat: 'walkableRoutingData',
			
			// Sync configuration
			syncEnabled: true,
			autoSyncOnChange: true,
			adminHasPriority: true,  // Admin data ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤
			lastSyncTime: null,
			
			// Storage key management (üö® FIXED: ‡πÅ‡∏¢‡∏Å keys ‡πÅ‡∏•‡πâ‡∏ß!)
			getStorageKey: (building, mode) => {
				if (!building) building = 'Main Building';
				return `walkableData_${building.replace(/\s+/g, '')}_${mode}`;
			},
			
			// Compatibility settings
			preserveFixedGrid: false,  // ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏ä‡πâ fixed grid ‡∏ñ‡πâ‡∏≤ admin ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
			allowDynamicNodes: true,   // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ admin ‡πÄ‡∏û‡∏¥‡πà‡∏° nodes ‡πÑ‡∏î‡πâ
			maxDataAge: 24 * 60 * 60 * 1000, // 24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á (milliseconds)
			
			// Status tracking
			lastConversionError: null,
			conversionCount: 0,
			debugMode: true
		};
	
	// üéØ Waypoint Navigation Enhancement
	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á

	// ========== 1. Waypoint System Configuration ==========

	const WAYPOINT_SYSTEM = {
		enabled: true,                    // ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á waypoints
		showWaypoints: true,             // ‡πÅ‡∏™‡∏î‡∏á waypoints ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
		waypointInterval: 15,            // ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á waypoints (‡πÄ‡∏°‡∏ï‡∏£)
		minWaypoints: 2,                 // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô waypoints ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
		maxWaypoints: 8,                 // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô waypoints ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
		waypointSize: 0.8,               // ‡∏Ç‡∏ô‡∏≤‡∏î waypoint marker
		animationEnabled: true,          // ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î animation
		showLabels: false,               // ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç waypoint ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
		autoHide: false                  // ‡∏ã‡πà‡∏≠‡∏ô waypoints ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡∏∂‡πà‡∏á
	};

	// Waypoint visual styles
	const WAYPOINT_STYLES = {
		fill: '#fbbf24',                 // ‡∏™‡∏µ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á‡∏ó‡∏≠‡∏á
		stroke: '#ffffff',               // ‡∏Ç‡∏≠‡∏ö‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
		strokeWidth: '0.2',
		opacity: '0.9',
		pulseColor: '#f59e0b',          // ‡∏™‡∏µ‡πÄ‡∏£‡∏∑‡∏≠‡∏á‡πÅ‡∏™‡∏á
		labelColor: '#1f2937',          // ‡∏™‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
		labelSize: '6px'
	};
	
	// ========== Phase 2.3: Index Google Sheets Integration ==========
	// üéØ Mission: ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° index.html ‡∏Å‡∏±‡∏ö Google Sheets ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö routing system
	// üîß Target: Smart caching + Background loading + Error resilience + Performance optimization

	// ========== 1. Index Sheets Configuration ==========

	// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô sheetsConfig object (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç existing sheetsConfig ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ)
	const INDEX_SHEETS_CONFIG = {
		// ‡πÉ‡∏ä‡πâ sheetsConfig ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏£‡∏∑‡∏≠ fallback
		url: (typeof sheetsConfig !== 'undefined' && sheetsConfig.url) ? sheetsConfig.url : '',
		connected: (typeof sheetsConfig !== 'undefined') ? sheetsConfig.connected : false,
		
		// Index-specific settings
		indexEnabled: true,
		backgroundSync: true,
		cacheTimeout: 300000,  // 5 minutes
		loadTimeout: 8000,     // 8 seconds
		retryAttempts: 3,
		
		// Performance settings
		enableSmartCache: true,
		preloadOnInit: true,
		offlineMode: false,
		
		// Index sync status
		indexSyncStatus: 'idle', // idle, loading, success, error, offline
		lastIndexSync: null,
		indexSyncErrors: [],
		
		// Cache metadata
		cacheStatus: 'empty', // empty, loading, fresh, stale, error
		cacheTimestamp: null,
		cacheBuilding: null
	};

	// ========== 2. Core Index Sheets Functions ==========

	// ‡πÇ‡∏´‡∏•‡∏î walkable data ‡∏à‡∏≤‡∏Å Google Sheets ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index.html
	async function loadWalkableDataFromSheetsForIndex(building) {
		building = building || getCurrentBuildingName();
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö sheets connection
		if (!INDEX_SHEETS_CONFIG.url || !INDEX_SHEETS_CONFIG.connected) {
			debugLogIndex('‚ö†Ô∏è Sheets not configured, using offline mode');
			INDEX_SHEETS_CONFIG.offlineMode = true;
			return await loadWalkableDataWithCacheFallback(building);
		}
		
		INDEX_SHEETS_CONFIG.indexSyncStatus = 'loading';
		updateIndexSyncStatus();
		
		try {
			debugLogIndex(`üì• Loading walkable data from sheets for routing: ${building}`);
			
			const params = new URLSearchParams();
			params.append('action', 'getWalkableData');
			params.append('building', building);
			
			const response = await Promise.race([
				fetch(INDEX_SHEETS_CONFIG.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				}),
				new Promise((_, reject) => 
					setTimeout(() => reject(new Error('Timeout')), INDEX_SHEETS_CONFIG.loadTimeout)
				)
			]);
			
			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}
			
			const result = await response.json();
			
			if (result.success && result.data) {
				// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô index format ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
				let indexData = result.data;
				if (indexData.dataSource !== 'index') {
					indexData = convertAdminToIndexFormat(indexData) || indexData;
				}
				
				// ‡πÄ‡∏û‡∏¥‡πà‡∏° index metadata
				indexData.dataSource = 'sheets';
				indexData.syncTime = new Date().toISOString();
				indexData.loadedVia = 'sheets';
				indexData.currentBuilding = building;
				
				// Cache data ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö offline use
				await cacheWalkableDataForOffline(indexData, building);
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkableRoutingData
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					
					// Trigger route recalculation ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ current route
					if (typeof recalculateCurrentRoute === 'function') {
						recalculateCurrentRoute();
					}
				}
				
				INDEX_SHEETS_CONFIG.indexSyncStatus = 'success';
				INDEX_SHEETS_CONFIG.lastIndexSync = new Date().toISOString();
				
				debugLogIndex('‚úÖ Loaded walkable data from sheets for routing:', {
					nodes: Object.keys(indexData.nodes || {}).length,
					edges: (indexData.edges || []).length,
					building: building
				});
				
				updateIndexSyncStatus();
				showIndexNotification('üì• ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô‡∏à‡∏≤‡∏Å Google Sheets ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
				
				return indexData;
				
			} else {
				throw new Error(result.error || 'Invalid response format');
			}
			
		} catch (error) {
			INDEX_SHEETS_CONFIG.indexSyncStatus = 'error';
			INDEX_SHEETS_CONFIG.indexSyncErrors.push({
				timestamp: new Date().toISOString(),
				operation: 'loadFromSheets',
				error: error.message,
				building: building
			});
			
			debugLogIndex('‚ùå Failed to load from sheets:', error);
			updateIndexSyncStatus();
			
			// Fallback to cached data
			debugLogIndex('üîÑ Falling back to cached data...');
			return await loadWalkableDataWithCacheFallback(building);
		}
	}

	// Cache walkable data ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö offline mode
	async function cacheWalkableDataForOffline(data, building) {
		if (!data || !INDEX_SHEETS_CONFIG.enableSmartCache) return false;
		
		try {
			building = building || data.currentBuilding || getCurrentBuildingName();
			
			const cacheData = {
				...data,
				cacheTimestamp: new Date().toISOString(),
				cacheBuilding: building,
				cacheSource: 'sheets',
				cacheVersion: '1.3'
			};
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô localStorage ‡∏î‡πâ‡∏ß‡∏¢ index key format
			const indexKey = getSafeStorageKey(building, 'index');
			const cacheKey = `${indexKey}_cache`;
			
			localStorage.setItem(cacheKey, JSON.stringify(cacheData));
			localStorage.setItem(indexKey, JSON.stringify(cacheData));
			
			INDEX_SHEETS_CONFIG.cacheStatus = 'fresh';
			INDEX_SHEETS_CONFIG.cacheTimestamp = new Date().toISOString();
			INDEX_SHEETS_CONFIG.cacheBuilding = building;
			
			debugLogIndex('üíæ Cached walkable data for offline use:', {
				building: building,
				nodes: Object.keys(data.nodes || {}).length,
				cacheKey: cacheKey
			});
			
			return true;
			
		} catch (error) {
			debugLogIndex('‚ùå Failed to cache data:', error);
			INDEX_SHEETS_CONFIG.cacheStatus = 'error';
			return false;
		}
	}

	// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏° cache fallback
	async function loadWalkableDataWithCacheFallback(building) {
		building = building || getCurrentBuildingName();
		
		try {
			// ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ cache ‡∏Å‡πà‡∏≠‡∏ô
			const indexKey = getSafeStorageKey(building, 'index');
			const cacheKey = `${indexKey}_cache`;
			
			// ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î: Recent cache ‚Üí Index storage ‚Üí Admin sync ‚Üí Fixed grid
			
			// 1. ‡∏•‡∏≠‡∏á recent cache ‡∏Å‡πà‡∏≠‡∏ô
			const cachedDataString = localStorage.getItem(cacheKey);
			if (cachedDataString) {
				const cachedData = JSON.parse(cachedDataString);
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ cache ‡∏¢‡∏±‡∏á‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
				const cacheAge = Date.now() - new Date(cachedData.cacheTimestamp || 0).getTime();
				const isCacheFresh = cacheAge < INDEX_SHEETS_CONFIG.cacheTimeout;
				
				if (isCacheFresh || INDEX_SHEETS_CONFIG.offlineMode) {
					// Cache ‡∏¢‡∏±‡∏á‡πÉ‡∏´‡∏°‡πà ‡∏´‡∏£‡∏∑‡∏≠ offline mode
					if (typeof walkableRoutingData !== 'undefined') {
						Object.assign(walkableRoutingData, cachedData);
					}
					
					INDEX_SHEETS_CONFIG.cacheStatus = isCacheFresh ? 'fresh' : 'stale';
					debugLogIndex(`‚úÖ Loaded from ${isCacheFresh ? 'fresh' : 'stale'} cache`, {
						building: building,
						age: Math.round(cacheAge / 1000) + 's'
					});
					
					return cachedData;
				}
			}
			
			// 2. ‡∏•‡∏≠‡∏á index storage
			const indexDataString = localStorage.getItem(indexKey);
			if (indexDataString) {
				const indexData = JSON.parse(indexDataString);
				
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
				}
				
				debugLogIndex('üìÅ Loaded from index storage');
				return indexData;
			}
			
			// 3. ‡∏•‡∏≠‡∏á sync ‡∏à‡∏≤‡∏Å admin data
			const adminSynced = syncAdminDataToIndex(building);
			if (adminSynced && typeof walkableRoutingData !== 'undefined' && walkableRoutingData.nodes) {
				debugLogIndex('üîÑ Loaded via admin sync');
				return walkableRoutingData;
			}
			
			// 4. ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ‡∏™‡∏£‡πâ‡∏≤‡∏á fixed grid
			debugLogIndex('üóÇÔ∏è No cached data, creating fixed grid fallback');
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
				return walkableRoutingData;
			}
			
			return null;
			
		} catch (error) {
			debugLogIndex('‚ùå Error in cache fallback:', error);
			INDEX_SHEETS_CONFIG.cacheStatus = 'error';
			return null;
		}
	}

	// ========== 3. Enhanced Loading with Background Sync ==========

	// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• walkable ‡∏û‡∏£‡πâ‡∏≠‡∏° sheets sync (‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà function ‡πÄ‡∏î‡∏¥‡∏°)
	async function loadWalkableDataWithSheetsSync(building) {
		building = building || getCurrentBuildingName();
		
		debugLogIndex('üöÄ Loading walkable data with sheets sync...', { building });
		
		// ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î background sync ‡πÉ‡∏´‡πâ‡πÇ‡∏´‡∏•‡∏î cache ‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß sync ‡πÉ‡∏ô background
		if (INDEX_SHEETS_CONFIG.backgroundSync && INDEX_SHEETS_CONFIG.connected) {
			// ‡πÇ‡∏´‡∏•‡∏î cache ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ UI responsive
			const cachedData = await loadWalkableDataWithCacheFallback(building);
			
			if (cachedData) {
				// ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• cache ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡πà‡∏≠‡∏ô
				debugLogIndex('‚ö° Using cached data for immediate display');
				
				// Background sync (‡πÑ‡∏°‡πà block UI)
				setTimeout(async () => {
					try {
						const freshData = await loadWalkableDataFromSheetsForIndex(building);
						if (freshData && JSON.stringify(freshData.nodes) !== JSON.stringify(cachedData.nodes)) {
							debugLogIndex('üîÑ Background sync updated data');
							showIndexNotification('üÜï ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï', 'info');
						}
					} catch (error) {
						debugLogIndex('‚ö†Ô∏è Background sync failed, using cached data');
					}
				}, 100);
				
				return cachedData;
			}
		}
		
		// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ cache ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î background sync ‡πÉ‡∏´‡πâ‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏£‡∏á‡∏à‡∏≤‡∏Å sheets
		return await loadWalkableDataFromSheetsForIndex(building);
	}

	// ========== 4. Validation and Error Handling ==========

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á walkable data ‡∏à‡∏≤‡∏Å sheets
	async function validateWalkableDataFromSheets(data) {
		if (!data || typeof data !== 'object') {
			return { valid: false, errors: ['Invalid data structure'] };
		}
		
		const errors = [];
		const warnings = [];
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö nodes
		if (!data.nodes || typeof data.nodes !== 'object') {
			errors.push('Missing or invalid nodes object');
		} else {
			const nodeCount = Object.keys(data.nodes).length;
			if (nodeCount === 0) {
				warnings.push('No nodes found');
			} else if (nodeCount < 2) {
				warnings.push('Too few nodes for routing');
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö node structure
			for (const nodeId in data.nodes) {
				const node = data.nodes[nodeId];
				if (typeof node.x !== 'number' || typeof node.y !== 'number') {
					errors.push(`Node ${nodeId} has invalid coordinates`);
				}
			}
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö edges
		if (!Array.isArray(data.edges)) {
			errors.push('Missing or invalid edges array');
		} else if (data.edges.length === 0) {
			warnings.push('No edges found - routing may not work');
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö settings
		if (data.settings && typeof data.settings === 'object') {
			if (data.settings.metersPerPercent && data.settings.metersPerPercent <= 0) {
				errors.push('Invalid metersPerPercent setting');
			}
		}
		
		const result = {
			valid: errors.length === 0,
			errors: errors,
			warnings: warnings,
			nodeCount: Object.keys(data.nodes || {}).length,
			edgeCount: (data.edges || []).length
		};
		
		debugLogIndex('üîç Data validation result:', result);
		return result;
	}

	// Fallback ‡πÑ‡∏õ localStorage ‡πÄ‡∏°‡∏∑‡πà‡∏≠ sheets unavailable
	function fallbackToLocalStorageIfSheetsUnavailable() {
		if (INDEX_SHEETS_CONFIG.connected) return false;
		
		debugLogIndex('üì± Sheets unavailable, enabling offline mode');
		INDEX_SHEETS_CONFIG.offlineMode = true;
		INDEX_SHEETS_CONFIG.indexSyncStatus = 'offline';
		
		const building = getCurrentBuildingName();
		const data = loadWalkableDataWithCacheFallback(building);
		
		if (data) {
			showIndexNotification('üì± ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå', 'info');
			return true;
		}
		
		showIndexNotification('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô', 'warning');
		return false;
	}

	// ========== 5. Performance Optimization ==========

	// ‡πÄ‡∏£‡πà‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì route
	function optimizeRouteCalculationPerformance() {
		// ‡πÉ‡∏ä‡πâ Web Workers ‡∏ñ‡πâ‡∏≤‡πÑ‡∏î‡πâ (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ setTimeout)
		if (typeof Worker !== 'undefined' && typeof calculateShortestPath === 'function') {
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï calculateShortestPath ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
			const originalCalculate = window.calculateShortestPath;
			
			window.calculateShortestPath = function(startId, endId) {
				const startTime = performance.now();
				
				try {
					const result = originalCalculate.call(this, startId, endId);
					
					const endTime = performance.now();
					const duration = endTime - startTime;
					
					// Track performance
					if (duration > 500) {
						debugLogIndex(`‚ö†Ô∏è Slow route calculation: ${duration.toFixed(2)}ms`);
					} else {
						debugLogIndex(`‚ö° Route calculated in: ${duration.toFixed(2)}ms`);
					}
					
					return result;
					
				} catch (error) {
					debugLogIndex('‚ùå Route calculation error:', error);
					return null;
				}
			};
		}
	}

	// ========== 6. UI Integration ‡πÅ‡∏•‡∏∞ Status Indicators ==========

	// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï sync status UI
	function updateIndexSyncStatus() {
		// ‡∏´‡∏≤ sync status elements ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
		let statusElement = document.getElementById('indexSyncStatus');
		if (!statusElement) {
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á status indicator ‡πÉ‡∏´‡∏°‡πà
			statusElement = document.createElement('div');
			statusElement.id = 'indexSyncStatus';
			statusElement.style.cssText = `
				position: fixed; top: 10px; right: 10px; 
				padding: 8px 12px; border-radius: 6px; 
				font-size: 12px; z-index: 1000;
				transition: all 0.3s ease;
			`;
			document.body.appendChild(statusElement);
		}
		
		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï status indicator
		const status = INDEX_SHEETS_CONFIG.indexSyncStatus;
		const lastSync = INDEX_SHEETS_CONFIG.lastIndexSync;
		
		let text, bgColor, textColor;
		
		switch (status) {
			case 'loading':
				text = 'üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...';
				bgColor = '#3498db';
				textColor = 'white';
				break;
			case 'success':
				const timeAgo = lastSync ? Math.round((Date.now() - new Date(lastSync).getTime()) / 1000) : 0;
				text = `‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ${timeAgo}s`;
				bgColor = '#2ecc71';
				textColor = 'white';
				break;
			case 'error':
				text = '‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î';
				bgColor = '#e74c3c';
				textColor = 'white';
				break;
			case 'offline':
				text = 'üì± ‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå';
				bgColor = '#f39c12';
				textColor = 'white';
				break;
			default:
				text = '‚è∏Ô∏è ‡∏£‡∏≠';
				bgColor = '#95a5a6';
				textColor = 'white';
		}
		
		statusElement.textContent = text;
		statusElement.style.backgroundColor = bgColor;
		statusElement.style.color = textColor;
		
		// ‡∏ã‡πà‡∏≠‡∏ô status ‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏ñ‡πâ‡∏≤ success
		if (status === 'success') {
			setTimeout(() => {
				statusElement.style.opacity = '0.3';
			}, 5000);
		} else {
			statusElement.style.opacity = '1';
		}
	}

	// ‡πÅ‡∏™‡∏î‡∏á notification ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index operations
	function showIndexNotification(message, type = 'info') {
		// ‡πÉ‡∏ä‡πâ existing notification system ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
		if (typeof showNotification === 'function') {
			showNotification(message, type);
		} else if (typeof showProgressiveStatus === 'function') {
			showProgressiveStatus(message, type);
		} else {
			// Fallback notification
			console.log(`[Index] ${message}`);
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á simple toast notification
			const toast = document.createElement('div');
			toast.textContent = message;
			toast.style.cssText = `
				position: fixed; bottom: 20px; left: 20px;
				background: ${type === 'success' ? '#2ecc71' : type === 'error' ? '#e74c3c' : '#3498db'};
				color: white; padding: 12px 20px; border-radius: 6px;
				z-index: 1001; animation: slideIn 0.3s ease;
			`;
			
			document.body.appendChild(toast);
			setTimeout(() => {
				toast.style.animation = 'slideOut 0.3s ease';
				setTimeout(() => toast.remove(), 300);
			}, 3000);
		}
	}

	// ========== 7. Enhanced Integration Functions ==========

	// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà loadWalkableData ‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö sheets
	async function loadWalkableDataWithSheetsIntegration() {
		const building = getCurrentBuildingName();
		debugLogIndex('üéØ Loading walkable data with sheets integration...', { building });
		
		// ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ sheets ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å sheets ‡∏Å‡πà‡∏≠‡∏ô
		if (INDEX_SHEETS_CONFIG.indexEnabled && INDEX_SHEETS_CONFIG.connected) {
			const sheetsData = await loadWalkableDataWithSheetsSync(building);
			if (sheetsData) {
				return sheetsData;
			}
		}
		
		// Fallback ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ Phase 2.1 functions
		if (typeof loadWalkableDataWithAdminSyncV2 === 'function') {
			return loadWalkableDataWithAdminSyncV2(building);
		}
		
		// ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ fallback ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ cache
		return await loadWalkableDataWithCacheFallback(building);
	}

	// ========== 8. Connection Management ==========

	// ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏õ Google Sheets (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index.html)
	async function connectToGoogleSheetsForIndex() {
		debugLogIndex('üîó Connecting to Google Sheets for index...');
		
		// ‡πÉ‡∏ä‡πâ existing sheetsConfig ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
		if (typeof sheetsConfig !== 'undefined' && sheetsConfig.url) {
			INDEX_SHEETS_CONFIG.url = sheetsConfig.url;
			INDEX_SHEETS_CONFIG.connected = sheetsConfig.connected;
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö connection
		if (INDEX_SHEETS_CONFIG.url && INDEX_SHEETS_CONFIG.connected) {
			debugLogIndex('‚úÖ Using existing sheets connection');
			return true;
		}
		
		// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ connection ‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î offline
		debugLogIndex('üì± No sheets connection, enabling offline mode');
		INDEX_SHEETS_CONFIG.connected = false;
		INDEX_SHEETS_CONFIG.offlineMode = true;
		
		return false;
	}

	// Monitor connection status
	function monitorIndexSheetsConnection() {
		setInterval(async () => {
			if (INDEX_SHEETS_CONFIG.url && !INDEX_SHEETS_CONFIG.offlineMode) {
				try {
					// Simple ping test
					const response = await fetch(INDEX_SHEETS_CONFIG.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: 'action=ping'
					});
					
					const wasConnected = INDEX_SHEETS_CONFIG.connected;
					INDEX_SHEETS_CONFIG.connected = response.ok;
					
					// ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠ connection ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
					if (!wasConnected && INDEX_SHEETS_CONFIG.connected) {
						showIndexNotification('‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Google Sheets ‡πÅ‡∏•‡πâ‡∏ß', 'success');
						INDEX_SHEETS_CONFIG.offlineMode = false;
					} else if (wasConnected && !INDEX_SHEETS_CONFIG.connected) {
						showIndexNotification('üì± ‡∏Ç‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå', 'warning');
						INDEX_SHEETS_CONFIG.offlineMode = true;
					}
					
				} catch (error) {
					INDEX_SHEETS_CONFIG.connected = false;
					INDEX_SHEETS_CONFIG.offlineMode = true;
				}
			}
		}, 30000); // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
	}

	// ========== 9. Initialization ‡πÅ‡∏•‡∏∞ Integration ==========

	// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Index Sheets System
	async function initializeIndexSheetsSystem() {
		debugLogIndex('üöÄ Initializing Index Sheets System...');
		
		try {
			// ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Google Sheets
			await connectToGoogleSheetsForIndex();
			
			// ‡πÄ‡∏£‡∏¥‡πà‡∏° connection monitoring
			monitorIndexSheetsConnection();
			
			// Optimize route calculation
			optimizeRouteCalculationPerformance();
			
			// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
			if (INDEX_SHEETS_CONFIG.preloadOnInit) {
				const building = getCurrentBuildingName();
				await loadWalkableDataWithSheetsIntegration();
			}
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° debug commands
			if (ADMIN_INDEX_BRIDGE && ADMIN_INDEX_BRIDGE.debugMode) {
				window.loadWalkableDataFromSheetsForIndex = loadWalkableDataFromSheetsForIndex;
				window.INDEX_SHEETS_CONFIG = INDEX_SHEETS_CONFIG;
				window.cacheWalkableDataForOffline = cacheWalkableDataForOffline;
				window.validateWalkableDataFromSheets = validateWalkableDataFromSheets;
			}
			
			debugLogIndex('‚úÖ Index Sheets System initialized successfully');
			
		} catch (error) {
			debugLogIndex('‚ùå Failed to initialize Index Sheets System:', error);
			// Fallback to offline mode
			INDEX_SHEETS_CONFIG.offlineMode = true;
			fallbackToLocalStorageIfSheetsUnavailable();
		}
	}

	// Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug
	function debugLogIndex(message, data = null) {
		if (ADMIN_INDEX_BRIDGE && ADMIN_INDEX_BRIDGE.debugMode) {
			const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
			const prefix = `[${timestamp}] IndexSheets:`;
			
			if (data) {
				console.log(prefix, message, data);
			} else {
				console.log(prefix, message);
			}
		}
	}

	// ========== 10. Function Replacements ‡πÅ‡∏•‡∏∞ Integration ==========

	// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà functions ‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö sheets
	if (typeof window !== 'undefined') {
		// Backup original functions
		window.originalLoadWalkableData = window.loadWalkableData;
		window.originalLoadInitialData = window.loadInitialData;
		
		// Replace with enhanced versions
		window.loadWalkableData = loadWalkableDataWithSheetsIntegration;
		
		// Add new functions
		window.loadWalkableDataFromSheetsForIndex = loadWalkableDataFromSheetsForIndex;
		window.INDEX_SHEETS_CONFIG = INDEX_SHEETS_CONFIG;
		window.initializeIndexSheetsSystem = initializeIndexSheetsSystem;
	}

	// Auto-initialize ‡πÄ‡∏°‡∏∑‡πà‡∏≠ DOM ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initializeIndexSheetsSystem);
	} else {
		// DOM ready ‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ init ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
		setTimeout(initializeIndexSheetsSystem, 100);
	}

	// ========== End Phase 2.3: Index Google Sheets Integration ==========
	
	// ========== Phase 2.4: Cross-System Sync + Production Polish ==========
	// üéØ Mission: Advanced sync mechanisms + Production-ready polish + Testing framework
	// üîß Target: Real-time sync + Conflict resolution + Health monitoring + Comprehensive testing

	// ========== 1. Advanced Cross-System Sync Manager ==========

	const CROSS_SYSTEM_SYNC = {
		// Sync configuration
		enabled: true,
		realTimeSync: true,
		conflictResolution: 'timestamp', // timestamp, user-prompt, admin-priority
		syncInterval: 5000, // 5 seconds
		
		// Sync state tracking
		syncInProgress: false,
		lastSyncTime: null,
		syncQueue: [],
		conflictQueue: [],
		
		// Health monitoring
		syncHealth: 'healthy', // healthy, degraded, offline, error
		syncSuccessRate: 100,
		totalSyncAttempts: 0,
		successfulSyncs: 0,
		failedSyncs: 0,
		
		// Performance tracking
		avgSyncTime: 0,
		syncTimes: [],
		maxSyncTime: 0,
		
		// Error tracking
		syncErrors: [],
		maxErrors: 50
	};

	// ========== 2. Real-time Sync Flow Implementation ==========

	// Main sync orchestrator: Admin ‚Üí Sheets ‚Üí Index
	async function orchestrateCrossSystemSync(building, sourceData, sourceType) {
		if (CROSS_SYSTEM_SYNC.syncInProgress) {
			debugLogSync('‚è∏Ô∏è Sync already in progress, queuing...');
			CROSS_SYSTEM_SYNC.syncQueue.push({ building, sourceData, sourceType, timestamp: Date.now() });
			return;
		}
		
		CROSS_SYSTEM_SYNC.syncInProgress = true;
		CROSS_SYSTEM_SYNC.totalSyncAttempts++;
		const syncStartTime = performance.now();
		
		try {
			debugLogSync(`üîÑ Starting cross-system sync from ${sourceType}...`, { building });
			
			let success = true;
			const syncResults = {
				admin: false,
				sheets: false,
				index: false,
				conflicts: []
			};
			
			// Phase 1: Sync to Google Sheets (if enabled and connected)
			if (INDEX_SHEETS_CONFIG.connected && sourceType !== 'sheets') {
				try {
					const sheetsResult = await syncToGoogleSheets(sourceData, building, sourceType);
					syncResults.sheets = sheetsResult.success;
					
					if (!sheetsResult.success) {
						debugLogSync('‚ö†Ô∏è Sheets sync failed:', sheetsResult.error);
					}
				} catch (error) {
					debugLogSync('‚ùå Sheets sync error:', error);
					syncResults.sheets = false;
				}
			}
			
			// Phase 2: Sync to other formats
			if (sourceType === 'admin') {
				// Admin ‚Üí Index format conversion ‡πÅ‡∏•‡∏∞ sync
				try {
					const indexData = convertAdminToIndexFormat(sourceData);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						syncResults.index = true;
						
						// Trigger index refresh ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô index.html
						if (ADMIN_INDEX_BRIDGE.isIndexMode() && typeof walkableRoutingData !== 'undefined') {
							Object.assign(walkableRoutingData, indexData);
							if (typeof recalculateCurrentRoute === 'function') {
								recalculateCurrentRoute();
							}
						}
					}
				} catch (error) {
					debugLogSync('‚ùå Admin‚ÜíIndex sync error:', error);
					syncResults.index = false;
					success = false;
				}
				
			} else if (sourceType === 'index') {
				// Index ‚Üí Admin format conversion ‡πÅ‡∏•‡∏∞ sync
				try {
					const adminData = convertIndexToAdminFormat(sourceData);
					if (adminData) {
						const adminKey = getSafeStorageKey(building, 'admin');
						localStorage.setItem(adminKey, JSON.stringify(adminData));
						syncResults.admin = true;
						
						// Trigger admin refresh ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô admin.html
						if (ADMIN_INDEX_BRIDGE.isAdminMode() && typeof walkablePointsData !== 'undefined') {
							Object.assign(walkablePointsData, adminData);
							if (typeof renderUI === 'function') {
								renderUI();
							}
						}
					}
				} catch (error) {
					debugLogSync('‚ùå Index‚ÜíAdmin sync error:', error);
					syncResults.admin = false;
					success = false;
				}
				
			} else if (sourceType === 'sheets') {
				// Sheets ‚Üí Both admin ‡πÅ‡∏•‡∏∞ index
				try {
					// Convert to admin format
					const adminData = sourceData.dataSource === 'admin' ? sourceData : convertIndexToAdminFormat(sourceData);
					if (adminData) {
						const adminKey = getSafeStorageKey(building, 'admin');
						localStorage.setItem(adminKey, JSON.stringify(adminData));
						syncResults.admin = true;
					}
					
					// Convert to index format
					const indexData = sourceData.dataSource === 'index' ? sourceData : convertAdminToIndexFormat(sourceData);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						syncResults.index = true;
					}
					
				} catch (error) {
					debugLogSync('‚ùå Sheets‚ÜíLocal sync error:', error);
					success = false;
				}
			}
			
			// Update sync statistics
			const syncTime = performance.now() - syncStartTime;
			updateSyncStatistics(success, syncTime);
			
			// Update last sync time
			CROSS_SYSTEM_SYNC.lastSyncTime = new Date().toISOString();
			
			debugLogSync(`‚úÖ Cross-system sync completed in ${syncTime.toFixed(2)}ms`, syncResults);
			
			return { success, results: syncResults, syncTime };
			
		} catch (error) {
			debugLogSync('‚ùå Cross-system sync failed:', error);
			CROSS_SYSTEM_SYNC.failedSyncs++;
			updateSyncHealth('error');
			
			// Log error
			logSyncError('crossSystemSync', error, { building, sourceType });
			
			return { success: false, error: error.message };
			
		} finally {
			CROSS_SYSTEM_SYNC.syncInProgress = false;
			
			// Process queue
			if (CROSS_SYSTEM_SYNC.syncQueue.length > 0) {
				const nextSync = CROSS_SYSTEM_SYNC.syncQueue.shift();
				setTimeout(() => {
					orchestrateCrossSystemSync(nextSync.building, nextSync.sourceData, nextSync.sourceType);
				}, 100);
			}
		}
	}

	// Sync to Google Sheets
	async function syncToGoogleSheets(data, building, sourceType) {
		try {
			// Use admin's saveWalkableDataToSheets function ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
			if (typeof saveWalkableDataToSheets === 'function') {
				const result = await saveWalkableDataToSheets(data);
				return { success: result, source: 'admin-function' };
			}
			
			// ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡∏ï‡∏£‡∏á‡πÜ
			const params = new URLSearchParams();
			params.append('action', 'saveWalkableData');
			params.append('building', building);
			params.append('nodes', JSON.stringify(data.nodes || {}));
			params.append('edges', JSON.stringify(data.edges || []));
			params.append('settings', JSON.stringify(data.settings || {}));
			
			const response = await fetch(INDEX_SHEETS_CONFIG.url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: params.toString()
			});
			
			const result = await response.json();
			return { success: result.success, source: 'direct-api', result };
			
		} catch (error) {
			return { success: false, error: error.message };
		}
	}

	// ========== 3. Conflict Resolution System ==========

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏≤ sync conflicts
	async function detectSyncConflicts(building) {
		const conflicts = [];
		
		try {
			// ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å sources
			const sources = {
				admin: null,
				index: null,
				sheets: null
			};
			
			// Admin data
			const adminKey = getSafeStorageKey(building, 'admin');
			const adminDataString = localStorage.getItem(adminKey);
			if (adminDataString) {
				sources.admin = JSON.parse(adminDataString);
			}
			
			// Index data
			const indexKey = getSafeStorageKey(building, 'index');
			const indexDataString = localStorage.getItem(indexKey);
			if (indexDataString) {
				sources.index = JSON.parse(indexDataString);
			}
			
			// Sheets data (‡∏ñ‡πâ‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ)
			if (INDEX_SHEETS_CONFIG.connected) {
				sources.sheets = await loadWalkableDataFromSheetsForIndex(building);
			}
			
			// ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö timestamps ‡πÅ‡∏•‡∏∞ node counts
			const timestamps = {};
			const nodeCounts = {};
			
			for (const [source, data] of Object.entries(sources)) {
				if (data) {
					timestamps[source] = new Date(data.syncTime || data.timestamp || 0).getTime();
					nodeCounts[source] = Object.keys(data.nodes || {}).length;
				}
			}
			
			// ‡∏´‡∏≤ conflicts
			const sourceKeys = Object.keys(sources).filter(key => sources[key]);
			
			if (sourceKeys.length > 1) {
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö timestamp conflicts
				const timestampValues = Object.values(timestamps);
				const uniqueTimestamps = [...new Set(timestampValues)];
				
				if (uniqueTimestamps.length > 1) {
					conflicts.push({
						type: 'timestamp',
						description: 'Different sync timestamps detected',
						sources: sourceKeys,
						timestamps: timestamps
					});
				}
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö data conflicts
				const nodeCountValues = Object.values(nodeCounts);
				const uniqueNodeCounts = [...new Set(nodeCountValues)];
				
				if (uniqueNodeCounts.length > 1) {
					conflicts.push({
						type: 'nodeCount',
						description: 'Different node counts detected',
						sources: sourceKeys,
						nodeCounts: nodeCounts
					});
				}
			}
			
			return conflicts;
			
		} catch (error) {
			debugLogSync('‚ùå Error detecting conflicts:', error);
			return [];
		}
	}

	// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç sync conflicts
	async function resolveSyncConflicts(building, conflicts) {
		if (!conflicts || conflicts.length === 0) return true;
		
		debugLogSync('üîß Resolving sync conflicts...', conflicts);
		
		for (const conflict of conflicts) {
			try {
				let winningSource = null;
				
				switch (CROSS_SYSTEM_SYNC.conflictResolution) {
					case 'timestamp':
						// ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ timestamp ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
						winningSource = Object.entries(conflict.timestamps || {})
							.sort(([,a], [,b]) => b - a)[0]?.[0];
						break;
						
					case 'admin-priority':
						// Admin ‡∏°‡∏µ priority ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
						winningSource = conflict.sources.includes('admin') ? 'admin' : 
									  conflict.sources.includes('sheets') ? 'sheets' : 
									  conflict.sources[0];
						break;
						
					case 'user-prompt':
						// ‡∏ñ‡∏≤‡∏° user (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô background)
						winningSource = await promptUserForConflictResolution(conflict);
						break;
				}
				
				if (winningSource) {
					debugLogSync(`üéØ Resolving conflict using ${winningSource} data`);
					
					// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å winning source ‡πÅ‡∏•‡∏∞ sync ‡πÑ‡∏õ‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ‡πà
					let winningData = null;
					
					if (winningSource === 'admin') {
						const adminKey = getSafeStorageKey(building, 'admin');
						const adminDataString = localStorage.getItem(adminKey);
						winningData = adminDataString ? JSON.parse(adminDataString) : null;
					} else if (winningSource === 'index') {
						const indexKey = getSafeStorageKey(building, 'index');
						const indexDataString = localStorage.getItem(indexKey);
						winningData = indexDataString ? JSON.parse(indexDataString) : null;
					} else if (winningSource === 'sheets') {
						winningData = await loadWalkableDataFromSheetsForIndex(building);
					}
					
					if (winningData) {
						// Sync winning data ‡πÑ‡∏õ‡∏ó‡∏∏‡∏Å sources
						await orchestrateCrossSystemSync(building, winningData, winningSource);
					}
				}
				
			} catch (error) {
				debugLogSync('‚ùå Error resolving conflict:', error);
				logSyncError('conflictResolution', error, conflict);
			}
		}
		
		return true;
	}

	// ========== 4. Sync Health Monitoring ==========

	// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï sync statistics
	function updateSyncStatistics(success, syncTime) {
		if (success) {
			CROSS_SYSTEM_SYNC.successfulSyncs++;
		} else {
			CROSS_SYSTEM_SYNC.failedSyncs++;
		}
		
		// Calculate success rate
		const totalSyncs = CROSS_SYSTEM_SYNC.successfulSyncs + CROSS_SYSTEM_SYNC.failedSyncs;
		CROSS_SYSTEM_SYNC.syncSuccessRate = totalSyncs > 0 ? 
			(CROSS_SYSTEM_SYNC.successfulSyncs / totalSyncs) * 100 : 100;
		
		// Track sync times
		if (syncTime) {
			CROSS_SYSTEM_SYNC.syncTimes.push(syncTime);
			
			// Keep only last 20 sync times
			if (CROSS_SYSTEM_SYNC.syncTimes.length > 20) {
				CROSS_SYSTEM_SYNC.syncTimes.shift();
			}
			
			// Calculate average
			CROSS_SYSTEM_SYNC.avgSyncTime = CROSS_SYSTEM_SYNC.syncTimes.reduce((a, b) => a + b, 0) / CROSS_SYSTEM_SYNC.syncTimes.length;
			
			// Track max time
			CROSS_SYSTEM_SYNC.maxSyncTime = Math.max(CROSS_SYSTEM_SYNC.maxSyncTime, syncTime);
		}
		
		// Update health status
		if (CROSS_SYSTEM_SYNC.syncSuccessRate >= 90) {
			updateSyncHealth('healthy');
		} else if (CROSS_SYSTEM_SYNC.syncSuccessRate >= 70) {
			updateSyncHealth('degraded');
		} else {
			updateSyncHealth('error');
		}
	}

	// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï sync health status
	function updateSyncHealth(newStatus) {
		const oldStatus = CROSS_SYSTEM_SYNC.syncHealth;
		CROSS_SYSTEM_SYNC.syncHealth = newStatus;
		
		if (oldStatus !== newStatus) {
			debugLogSync(`üè• Sync health changed: ${oldStatus} ‚Üí ${newStatus}`);
			
			// ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤ health ‡πÅ‡∏¢‡πà‡∏•‡∏á
			if (newStatus === 'error' || newStatus === 'degraded') {
				showSyncHealthAlert(newStatus);
			}
		}
	}

	// ‡πÅ‡∏™‡∏î‡∏á sync health alert
	function showSyncHealthAlert(status) {
		const messages = {
			degraded: '‚ö†Ô∏è ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏•‡∏î‡∏•‡∏á',
			error: '‚ùå ‡∏£‡∏∞‡∏ö‡∏ö‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤',
			offline: 'üì± ‡∏£‡∏∞‡∏ö‡∏ö‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏≠‡∏≠‡∏ü‡πÑ‡∏•‡∏ô‡πå'
		};
		
		const message = messages[status] || '‚ÑπÔ∏è ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á';
		
		if (typeof showIndexNotification === 'function') {
			showIndexNotification(message, status === 'error' ? 'error' : 'warning');
		}
	}

	// Log sync errors
	function logSyncError(operation, error, context) {
		const errorEntry = {
			timestamp: new Date().toISOString(),
			operation: operation,
			error: error.message || error.toString(),
			context: context,
			syncHealth: CROSS_SYSTEM_SYNC.syncHealth
		};
		
		CROSS_SYSTEM_SYNC.syncErrors.push(errorEntry);
		
		// Keep only recent errors
		if (CROSS_SYSTEM_SYNC.syncErrors.length > CROSS_SYSTEM_SYNC.maxErrors) {
			CROSS_SYSTEM_SYNC.syncErrors.shift();
		}
		
		debugLogSync('üìù Logged sync error:', errorEntry);
	}

	// ========== 5. Comprehensive Testing Framework ==========

	const TESTING_FRAMEWORK = {
		// Test configuration
		enabled: true,
		autoRunOnInit: false,
		verbose: true,
		
		// Test results
		testResults: [],
		totalTests: 0,
		passedTests: 0,
		failedTests: 0,
		
		// Test categories
		testCategories: {
			dataConversion: [],
			syncOperations: [],
			errorHandling: [],
			performance: [],
			integration: []
		}
	};

	// Main testing suite
	async function runComprehensiveTestSuite() {
		debugLogSync('üß™ Starting comprehensive test suite...');
		
		TESTING_FRAMEWORK.testResults = [];
		TESTING_FRAMEWORK.totalTests = 0;
		TESTING_FRAMEWORK.passedTests = 0;
		TESTING_FRAMEWORK.failedTests = 0;
		
		try {
			// Test categories
			await testDataConversionSuite();
			await testSyncOperationsSuite();
			await testErrorHandlingSuite();
			await testPerformanceSuite();
			await testIntegrationSuite();
			
			// Generate test report
			const report = generateTestReport();
			debugLogSync('üìä Test suite completed:', report);
			
			return report;
			
		} catch (error) {
			debugLogSync('‚ùå Test suite failed:', error);
			return { success: false, error: error.message };
		}
	}

	// Test data conversion functions
	async function testDataConversionSuite() {
		debugLogSync('üîÑ Testing data conversion...');
		
		// Test admin ‚Üí index conversion
		await runTest('adminToIndexConversion', () => {
			const testAdminData = {
				nodes: { '1': { id: '1', x: 10, y: 20, type: 'grid' } },
				edges: [{ from: '1', to: '2', weight: 15 }],
				settings: { metersPerPercent: 1.2 },
				currentBuilding: 'Test Building'
			};
			
			const indexData = convertAdminToIndexFormat(testAdminData);
			
			if (!indexData || !indexData.nodes || !indexData.nodes['1']) {
				throw new Error('Conversion failed or missing nodes');
			}
			
			if (indexData.currentBuilding !== 'Test Building') {
				throw new Error('Building name not preserved');
			}
			
			return { success: true, data: indexData };
		});
		
		// Test index ‚Üí admin conversion
		await runTest('indexToAdminConversion', () => {
			const testIndexData = {
				nodes: { '1': { id: '1', x: 10, y: 20, type: 'grid' } },
				edges: [{ from: '1', to: '2', weight: 15 }],
				settings: { metersPerPercent: 1.2 },
				currentBuilding: 'Test Building'
			};
			
			const adminData = convertIndexToAdminFormat(testIndexData);
			
			if (!adminData || !adminData.nodes || !adminData.nodes['1']) {
				throw new Error('Conversion failed or missing nodes');
			}
			
			return { success: true, data: adminData };
		});
		
		// Test round-trip conversion
		await runTest('roundTripConversion', () => {
			const originalData = {
				nodes: { '1': { id: '1', x: 10, y: 20, type: 'grid' } },
				edges: [{ from: '1', to: '2', weight: 15 }],
				currentBuilding: 'Test Building'
			};
			
			const indexData = convertAdminToIndexFormat(originalData);
			const backToAdmin = convertIndexToAdminFormat(indexData);
			
			if (!backToAdmin || !backToAdmin.nodes || !backToAdmin.nodes['1']) {
				throw new Error('Round-trip conversion failed');
			}
			
			// Check if key data is preserved
			if (backToAdmin.nodes['1'].x !== originalData.nodes['1'].x) {
				throw new Error('Data integrity lost in round-trip');
			}
			
			return { success: true };
		});
	}

	// Test sync operations
	async function testSyncOperationsSuite() {
		debugLogSync('üîÑ Testing sync operations...');
		
		// Test localStorage sync
		await runTest('localStorageSync', () => {
			const testBuilding = 'Test Building';
			const testData = {
				nodes: { 'test1': { id: 'test1', x: 5, y: 10 } },
				edges: [],
				currentBuilding: testBuilding
			};
			
			// Test admin ‚Üí index sync
			const adminKey = getSafeStorageKey(testBuilding, 'admin');
			localStorage.setItem(adminKey, JSON.stringify(testData));
			
			const synced = syncAdminDataToIndex(testBuilding);
			
			if (!synced) {
				throw new Error('Admin to index sync failed');
			}
			
			// Verify index data
			const indexKey = getSafeStorageKey(testBuilding, 'index');
			const indexDataString = localStorage.getItem(indexKey);
			
			if (!indexDataString) {
				throw new Error('Index data not found after sync');
			}
			
			// Cleanup
			localStorage.removeItem(adminKey);
			localStorage.removeItem(indexKey);
			
			return { success: true };
		});
		
		// Test conflict detection
		await runTest('conflictDetection', async () => {
			const testBuilding = 'Test Building Conflict';
			
			// Create conflicting data
			const adminData = { 
				nodes: { '1': { id: '1', x: 10, y: 20 } }, 
				syncTime: '2024-01-01T10:00:00Z',
				currentBuilding: testBuilding 
			};
			const indexData = { 
				nodes: { '1': { id: '1', x: 15, y: 25 }, '2': { id: '2', x: 30, y: 40 } }, 
				syncTime: '2024-01-01T11:00:00Z',
				currentBuilding: testBuilding 
			};
			
			// Save conflicting data
			const adminKey = getSafeStorageKey(testBuilding, 'admin');
			const indexKey = getSafeStorageKey(testBuilding, 'index');
			localStorage.setItem(adminKey, JSON.stringify(adminData));
			localStorage.setItem(indexKey, JSON.stringify(indexData));
			
			// Detect conflicts
			const conflicts = await detectSyncConflicts(testBuilding);
			
			if (!conflicts || conflicts.length === 0) {
				throw new Error('Failed to detect conflicts');
			}
			
			// Cleanup
			localStorage.removeItem(adminKey);
			localStorage.removeItem(indexKey);
			
			return { success: true, conflicts: conflicts.length };
		});
	}

	// Test error handling
	async function testErrorHandlingSuite() {
		debugLogSync('üõ°Ô∏è Testing error handling...');
		
		// Test invalid data handling
		await runTest('invalidDataHandling', () => {
			// Test with null data
			const result1 = convertAdminToIndexFormat(null);
			if (result1 !== null) {
				throw new Error('Should return null for invalid input');
			}
			
			// Test with malformed data
			const result2 = convertAdminToIndexFormat({ invalid: 'data' });
			if (result2 !== null) {
				throw new Error('Should return null for malformed data');
			}
			
			return { success: true };
		});
		
		// Test network failure handling
		await runTest('networkFailureHandling', async () => {
			// Temporarily break connection
			const originalUrl = INDEX_SHEETS_CONFIG.url;
			INDEX_SHEETS_CONFIG.url = 'https://invalid-url-for-testing.com';
			
			try {
				const result = await loadWalkableDataFromSheetsForIndex('Test Building');
				
				// Should fail gracefully and return null or cached data
				if (result && result.error) {
					// Good - error was handled
					return { success: true, handledGracefully: true };
				} else if (result === null) {
					// Also good - returned null as expected
					return { success: true, returnedNull: true };
				} else {
					throw new Error('Network failure not handled properly');
				}
				
			} finally {
				// Restore connection
				INDEX_SHEETS_CONFIG.url = originalUrl;
			}
		});
	}

	// Test performance
	async function testPerformanceSuite() {
		debugLogSync('‚ö° Testing performance...');
		
		// Test route calculation performance
		await runTest('routeCalculationPerformance', () => {
			// Create test data with many nodes
			const testNodes = {};
			for (let i = 1; i <= 50; i++) {
				testNodes[i.toString()] = {
					id: i.toString(),
					x: (i % 10) * 10,
					y: Math.floor(i / 10) * 10,
					type: 'grid'
				};
			}
			
			// Mock walkableRoutingData
			const originalData = window.walkableRoutingData;
			window.walkableRoutingData = {
				nodes: testNodes,
				edges: []
			};
			
			try {
				// Test route calculation time
				const startTime = performance.now();
				
				if (typeof calculateShortestPath === 'function') {
					calculateShortestPath('1', '50');
				}
				
				const endTime = performance.now();
				const calculationTime = endTime - startTime;
				
				// Should be under 500ms as per requirements
				if (calculationTime > 500) {
					throw new Error(`Route calculation too slow: ${calculationTime.toFixed(2)}ms > 500ms`);
				}
				
				return { success: true, time: calculationTime };
				
			} finally {
				// Restore original data
				window.walkableRoutingData = originalData;
			}
		});
		
		// Test data conversion performance
		await runTest('dataConversionPerformance', () => {
			// Create large test data
			const largeData = {
				nodes: {},
				edges: [],
				currentBuilding: 'Performance Test'
			};
			
			for (let i = 1; i <= 100; i++) {
				largeData.nodes[i.toString()] = {
					id: i.toString(),
					x: Math.random() * 100,
					y: Math.random() * 100,
					type: 'grid'
				};
			}
			
			// Test conversion time
			const startTime = performance.now();
			const converted = convertAdminToIndexFormat(largeData);
			const endTime = performance.now();
			
			const conversionTime = endTime - startTime;
			
			if (!converted) {
				throw new Error('Conversion failed');
			}
			
			// Should be reasonably fast
			if (conversionTime > 100) {
				throw new Error(`Data conversion too slow: ${conversionTime.toFixed(2)}ms > 100ms`);
			}
			
			return { success: true, time: conversionTime, nodeCount: 100 };
		});
	}

	// Test integration
	async function testIntegrationSuite() {
		debugLogSync('üîó Testing integration...');
		
		// Test end-to-end workflow
		await runTest('endToEndWorkflow', async () => {
			const testBuilding = 'E2E Test Building';
			
			try {
				// 1. Create admin data
				const adminData = {
					nodes: { 'e2e1': { id: 'e2e1', x: 10, y: 20, type: 'entrance' } },
					edges: [],
					currentBuilding: testBuilding,
					dataSource: 'admin',
					syncTime: new Date().toISOString()
				};
				
				// 2. Save admin data
				const adminKey = getSafeStorageKey(testBuilding, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(adminData));
				
				// 3. Sync to index
				const syncResult = syncAdminDataToIndex(testBuilding);
				if (!syncResult) {
					throw new Error('Failed to sync admin to index');
				}
				
				// 4. Verify index data
				const indexKey = getSafeStorageKey(testBuilding, 'index');
				const indexDataString = localStorage.getItem(indexKey);
				if (!indexDataString) {
					throw new Error('Index data not found');
				}
				
				const indexData = JSON.parse(indexDataString);
				if (!indexData.nodes || !indexData.nodes['e2e1']) {
					throw new Error('Index data structure invalid');
				}
				
				// 5. Test cross-system sync
				const crossSyncResult = await orchestrateCrossSystemSync(testBuilding, adminData, 'admin');
				if (!crossSyncResult.success) {
					throw new Error('Cross-system sync failed');
				}
				
				return { success: true, steps: 5 };
				
			} finally {
				// Cleanup
				const adminKey = getSafeStorageKey(testBuilding, 'admin');
				const indexKey = getSafeStorageKey(testBuilding, 'index');
				localStorage.removeItem(adminKey);
				localStorage.removeItem(indexKey);
			}
		});
	}

	// Helper function to run individual test
	async function runTest(testName, testFunction) {
		TESTING_FRAMEWORK.totalTests++;
		
		try {
			debugLogSync(`üß™ Running test: ${testName}`);
			
			const startTime = performance.now();
			const result = await testFunction();
			const endTime = performance.now();
			
			const testResult = {
				name: testName,
				status: 'passed',
				duration: endTime - startTime,
				result: result,
				timestamp: new Date().toISOString()
			};
			
			TESTING_FRAMEWORK.testResults.push(testResult);
			TESTING_FRAMEWORK.passedTests++;
			
			debugLogSync(`‚úÖ Test passed: ${testName} (${testResult.duration.toFixed(2)}ms)`);
			
		} catch (error) {
			const testResult = {
				name: testName,
				status: 'failed',
				error: error.message,
				timestamp: new Date().toISOString()
			};
			
			TESTING_FRAMEWORK.testResults.push(testResult);
			TESTING_FRAMEWORK.failedTests++;
			
			debugLogSync(`‚ùå Test failed: ${testName} - ${error.message}`);
		}
	}

	// Generate test report
	function generateTestReport() {
		const report = {
			summary: {
				total: TESTING_FRAMEWORK.totalTests,
				passed: TESTING_FRAMEWORK.passedTests,
				failed: TESTING_FRAMEWORK.failedTests,
				successRate: TESTING_FRAMEWORK.totalTests > 0 ? 
					(TESTING_FRAMEWORK.passedTests / TESTING_FRAMEWORK.totalTests) * 100 : 0
			},
			results: TESTING_FRAMEWORK.testResults,
			timestamp: new Date().toISOString()
		};
		
		// Log summary
		debugLogSync('üìä Test Report Summary:', {
			total: report.summary.total,
			passed: report.summary.passed,
			failed: report.summary.failed,
			successRate: `${report.summary.successRate.toFixed(1)}%`
		});
		
		return report;
	}

	// ========== 6. Debug ‡πÅ‡∏•‡∏∞ Monitoring Tools ==========

	// Comprehensive system status
	function getSystemStatus() {
		return {
			// Phase status
			phases: {
				phase21: 'complete', // Data bridge
				phase22: 'complete', // Admin sheets
				phase23: 'complete', // Index sheets
				phase24: 'complete'  // Cross-system sync
			},
			
			// Connection status
			connections: {
				sheetsConnected: INDEX_SHEETS_CONFIG.connected,
				offlineMode: INDEX_SHEETS_CONFIG.offlineMode,
				adminMode: ADMIN_INDEX_BRIDGE.isAdminMode(),
				indexMode: ADMIN_INDEX_BRIDGE.isIndexMode()
			},
			
			// Sync status
			sync: {
				health: CROSS_SYSTEM_SYNC.syncHealth,
				successRate: CROSS_SYSTEM_SYNC.syncSuccessRate,
				lastSync: CROSS_SYSTEM_SYNC.lastSyncTime,
				avgSyncTime: CROSS_SYSTEM_SYNC.avgSyncTime,
				totalSyncs: CROSS_SYSTEM_SYNC.totalSyncAttempts
			},
			
			// Cache status
			cache: {
				status: INDEX_SHEETS_CONFIG.cacheStatus,
				timestamp: INDEX_SHEETS_CONFIG.cacheTimestamp,
				building: INDEX_SHEETS_CONFIG.cacheBuilding
			},
			
			// Error status
			errors: {
				syncErrors: CROSS_SYSTEM_SYNC.syncErrors.length,
				indexErrors: INDEX_SHEETS_CONFIG.indexSyncErrors.length,
				recentErrors: [...CROSS_SYSTEM_SYNC.syncErrors.slice(-3)]
			}
		};
	}

	// Debug sync status
	function debugSyncStatus() {
		const status = getSystemStatus();
		
		console.group('üîç Smart School Map System Status');
		console.log('üìã Phases:', status.phases);
		console.log('üîó Connections:', status.connections);
		console.log('üîÑ Sync:', status.sync);
		console.log('üíæ Cache:', status.cache);
		console.log('‚ö†Ô∏è Errors:', status.errors);
		console.groupEnd();
		
		return status;
	}

	// Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug
	function debugLogSync(message, data = null) {
		if (ADMIN_INDEX_BRIDGE && ADMIN_INDEX_BRIDGE.debugMode) {
			const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
			const prefix = `[${timestamp}] CrossSync:`;
			
			if (data) {
				console.log(prefix, message, data);
			} else {
				console.log(prefix, message);
			}
		}
	}

	// ========== 7. Auto-Initialization ‡πÅ‡∏•‡∏∞ Global Integration ==========

	// Initialize Cross-System Sync
	async function initializeCrossSystemSync() {
		debugLogSync('üöÄ Initializing Cross-System Sync...');
		
		try {
			// Auto-detect ‡πÅ‡∏•‡∏∞ repair conflicts
			const building = getCurrentBuildingName();
			const conflicts = await detectSyncConflicts(building);
			
			if (conflicts.length > 0) {
				debugLogSync(`üîß Found ${conflicts.length} conflicts, resolving...`);
				await resolveSyncConflicts(building, conflicts);
			}
			
			// Start periodic sync monitoring
			if (CROSS_SYSTEM_SYNC.realTimeSync) {
				setInterval(async () => {
					try {
						const building = getCurrentBuildingName();
						const conflicts = await detectSyncConflicts(building);
						
						if (conflicts.length > 0) {
							await resolveSyncConflicts(building, conflicts);
						}
					} catch (error) {
						debugLogSync('‚ö†Ô∏è Periodic sync check failed:', error);
					}
				}, CROSS_SYSTEM_SYNC.syncInterval);
			}
			
			// Run tests ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ
			if (TESTING_FRAMEWORK.autoRunOnInit) {
				setTimeout(() => runComprehensiveTestSuite(), 2000);
			}
			
			debugLogSync('‚úÖ Cross-System Sync initialized successfully');
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° global functions
			window.orchestrateCrossSystemSync = orchestrateCrossSystemSync;
			window.debugSyncStatus = debugSyncStatus;
			window.runComprehensiveTestSuite = runComprehensiveTestSuite;
			window.CROSS_SYSTEM_SYNC = CROSS_SYSTEM_SYNC;
			
			return true;
			
		} catch (error) {
			debugLogSync('‚ùå Failed to initialize Cross-System Sync:', error);
			return false;
		}
	}

/*
	// Auto-initialize
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			setTimeout(initializeCrossSystemSync, 200);
		});
	} else {
		setTimeout(initializeCrossSystemSync, 200);
	}
*/

	// ========== End Phase 2.4: Cross-System Sync + Production Polish ==========


	// ========== ERROR FIX: SVG Routing Markers + Data Validation ==========
	// üéØ Mission: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç "undefined" cx attribute error ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö routing
	// üîß Target: Safe data validation + Error-free routing + Graceful fallbacks

	// ========== 1. Safe Data Validation Functions ==========

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç node data
	function validateAndFixNodeData(nodeId, nodeData) {
		if (!nodeData || typeof nodeData !== 'object') {
			console.warn(`Invalid node data for ${nodeId}:`, nodeData);
			return null;
		}
		
		// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç missing coordinates
		const fixedNode = { ...nodeData };
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö x coordinate
		if (typeof fixedNode.x !== 'number' || isNaN(fixedNode.x)) {
			console.warn(`Invalid x coordinate for node ${nodeId}:`, fixedNode.x);
			fixedNode.x = 50; // Default center x
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö y coordinate  
		if (typeof fixedNode.y !== 'number' || isNaN(fixedNode.y)) {
			console.warn(`Invalid y coordinate for node ${nodeId}:`, fixedNode.y);
			fixedNode.y = 50; // Default center y
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö id
		if (!fixedNode.id) {
			fixedNode.id = nodeId;
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö type
		if (!fixedNode.type) {
			fixedNode.type = 'grid';
		}
		
		return fixedNode;
	}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á walkableRoutingData
	function validateWalkableRoutingData() {
		if (typeof walkableRoutingData === 'undefined') {
			console.error('walkableRoutingData is undefined, initializing...');
			window.walkableRoutingData = {
				nodes: {},
				edges: [],
				currentBuilding: getCurrentBuildingName(),
				isInitialized: false
			};
			return false;
		}
		
		if (!walkableRoutingData.nodes || typeof walkableRoutingData.nodes !== 'object') {
			console.error('walkableRoutingData.nodes is invalid, fixing...');
			walkableRoutingData.nodes = {};
			return false;
		}
		
		if (!Array.isArray(walkableRoutingData.edges)) {
			console.error('walkableRoutingData.edges is invalid, fixing...');
			walkableRoutingData.edges = [];
			return false;
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç nodes
		let fixedNodes = 0;
		for (const nodeId in walkableRoutingData.nodes) {
			const originalNode = walkableRoutingData.nodes[nodeId];
			const fixedNode = validateAndFixNodeData(nodeId, originalNode);
			
			if (fixedNode && (fixedNode.x !== originalNode.x || fixedNode.y !== originalNode.y)) {
				walkableRoutingData.nodes[nodeId] = fixedNode;
				fixedNodes++;
			} else if (!fixedNode) {
				console.warn(`Removing invalid node: ${nodeId}`);
				delete walkableRoutingData.nodes[nodeId];
			}
		}
		
		if (fixedNodes > 0) {
			console.log(`Fixed ${fixedNodes} nodes with invalid coordinates`);
		}
		
		return true;
	}

	// ========== 2. Safe Node Retrieval Functions ==========

	// ‡∏î‡∏∂‡∏á node ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
	function getSafeNode(nodeId) {
		if (!nodeId) {
			console.warn('Node ID is empty or undefined');
			return null;
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö walkableRoutingData
		if (!validateWalkableRoutingData()) {
			console.error('Cannot get node: walkableRoutingData is invalid');
			return null;
		}
		
		const node = walkableRoutingData.nodes[nodeId];
		if (!node) {
			console.warn(`Node not found: ${nodeId}`);
			return null;
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç node data
		return validateAndFixNodeData(nodeId, node);
	}

	// ‡∏î‡∏∂‡∏á coordinates ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
	function getSafeNodeCoordinates(nodeId) {
		const node = getSafeNode(nodeId);
		if (!node) {
			console.warn(`Cannot get coordinates for node: ${nodeId}`);
			return { x: 50, y: 50 }; // Default center coordinates
		}
		
		return {
			x: typeof node.x === 'number' ? node.x : 50,
			y: typeof node.y === 'number' ? node.y : 50
		};
	}

	// ========== 3. Enhanced Route Marker Functions ==========

	// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà addRouteMarkers ‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢ safe version
	function addRouteMarkersSafe(path, svgElement) {
		if (!path || !Array.isArray(path) || path.length === 0) {
			console.warn('Invalid path for route markers:', path);
			return;
		}
		
		if (!svgElement) {
			console.warn('SVG element not provided for route markers');
			return;
		}
		
		try {
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö walkableRoutingData ‡∏Å‡πà‡∏≠‡∏ô
			if (!validateWalkableRoutingData()) {
				console.error('Cannot add route markers: invalid walkableRoutingData');
				return;
			}
			
			path.forEach((nodeId, index) => {
				if (!nodeId) {
					console.warn(`Empty node ID at path index ${index}`);
					return;
				}
				
				const coords = getSafeNodeCoordinates(nodeId);
				
				// ‡∏™‡∏£‡πâ‡∏≤‡∏á marker circle
				const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				
				// ‡πÉ‡∏ä‡πâ safe coordinates
				marker.setAttribute('cx', coords.x.toString());
				marker.setAttribute('cy', coords.y.toString());
				marker.setAttribute('r', '3');
				marker.setAttribute('class', 'route-marker');
				
				// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡∏ï‡∏≤‡∏° position ‡πÉ‡∏ô path
				if (index === 0) {
					marker.setAttribute('fill', '#00ff00'); // Start - Green
				} else if (index === path.length - 1) {
					marker.setAttribute('fill', '#ff0000'); // End - Red
				} else {
					marker.setAttribute('fill', '#ffff00'); // Middle - Yellow
				}
				
				marker.setAttribute('stroke', '#000000');
				marker.setAttribute('stroke-width', '1');
				
				svgElement.appendChild(marker);
			});
			
			console.log(`Added ${path.length} route markers successfully`);
			
		} catch (error) {
			console.error('Error adding route markers:', error);
			console.error('Path data:', path);
		}
	}

	// ========== 4. Enhanced Route Display Functions ==========

	// Safe version ‡∏Ç‡∏≠‡∏á showStraightRoutePath
	function showStraightRoutePathSafe(startNodeId, endNodeId) {
		try {
			console.log(`Showing route: ${startNodeId} ‚Üí ${endNodeId}`);
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö node IDs
			if (!startNodeId || !endNodeId) {
				throw new Error('Start or end node ID is missing');
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö nodes existence
			const startCoords = getSafeNodeCoordinates(startNodeId);
			const endCoords = getSafeNodeCoordinates(endNodeId);
			
			// ‡∏´‡∏≤ SVG element
			const svg = document.querySelector('.floor-map svg') || 
					   document.querySelector('svg') ||
					   document.getElementById('floorPlanSvg');
			
			if (!svg) {
				throw new Error('SVG element not found');
			}
			
			// ‡∏•‡∏ö route ‡πÄ‡∏Å‡πà‡∏≤
			clearExistingRoute(svg);
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á route line
			const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			line.setAttribute('x1', startCoords.x.toString());
			line.setAttribute('y1', startCoords.y.toString());
			line.setAttribute('x2', endCoords.x.toString());
			line.setAttribute('y2', endCoords.y.toString());
			line.setAttribute('stroke', '#ff0000');
			line.setAttribute('stroke-width', '3');
			line.setAttribute('stroke-dasharray', '5,5');
			line.setAttribute('class', 'route-line');
			
			svg.appendChild(line);
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° markers
			addRouteMarkersSafe([startNodeId, endNodeId], svg);
			
			// ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
			const distance = calculateDistanceBetweenNodes(startNodeId, endNodeId);
			showRouteInfo(startNodeId, endNodeId, distance, 'straight');
			
			console.log('Straight route displayed successfully');
			
		} catch (error) {
			console.error('Error showing straight route:', error);
			showErrorNotification('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÑ‡∏î‡πâ: ' + error.message);
		}
	}

	// Safe version ‡∏Ç‡∏≠‡∏á showRouteToSelected
	function showRouteToSelectedSafe(targetNodeId) {
		try {
			console.log(`Showing route to selected node: ${targetNodeId}`);
			
			if (!targetNodeId) {
				throw new Error('Target node ID is missing');
			}
			
			// ‡∏´‡∏≤ starting point (‡πÉ‡∏ä‡πâ center ‡∏´‡∏£‡∏∑‡∏≠ entrance)
			const startNodeId = findBestStartingPoint();
			
			if (!startNodeId) {
				throw new Error('Cannot find starting point');
			}
			
			// ‡πÉ‡∏ä‡πâ Dijkstra algorithm ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
			if (typeof calculateShortestPath === 'function') {
				const path = calculateShortestPath(startNodeId, targetNodeId);
				
				if (path && path.length > 0) {
					showCalculatedRouteSafe(path);
				} else {
					console.warn('No path found, showing straight line');
					showStraightRoutePath(getSafeNodeCoordinates(startNodeId), getSafeNodeCoordinates(targetNodeId));
				}
			} else {
				// Fallback ‡πÑ‡∏õ straight line
				console.warn('calculateShortestPath not available, showing straight line');
				showStraightRoutePath(getSafeNodeCoordinates(startNodeId), getSafeNodeCoordinates(targetNodeId));
			}
			
		} catch (error) {
			console.error('Error showing route to selected:', error);
			showStraightRoutePath(getSafeNodeCoordinates(startNodeId), getSafeNodeCoordinates(targetNodeId));
		}
	}

	// ‡πÅ‡∏™‡∏î‡∏á calculated route ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
	function showCalculatedRouteSafe(path) {
		if (!path || !Array.isArray(path) || path.length === 0) {
			console.warn('Invalid calculated path:', path);
			return;
		}
		
		try {
			const svg = document.querySelector('.floor-map svg') || 
					   document.querySelector('svg') ||
					   document.getElementById('floorPlanSvg');
			
			if (!svg) {
				throw new Error('SVG element not found');
			}
			
			// ‡∏•‡∏ö route ‡πÄ‡∏Å‡πà‡∏≤
			clearExistingRoute(svg);
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á polyline ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö path
			const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
			const points = [];
			
			path.forEach(nodeId => {
				const coords = getSafeNodeCoordinates(nodeId);
				points.push(`${coords.x},${coords.y}`);
			});
			
			polyline.setAttribute('points', points.join(' '));
			polyline.setAttribute('fill', 'none');
			polyline.setAttribute('stroke', '#0066cc');
			polyline.setAttribute('stroke-width', '4');
			polyline.setAttribute('stroke-linejoin', 'round');
			polyline.setAttribute('class', 'route-path');
			
			svg.appendChild(polyline);
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° markers
			addRouteMarkersSafe(path, svg);
			
			// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
			const totalDistance = calculatePathDistance(path);
			showRouteInfo(path[0], path[path.length - 1], totalDistance, 'calculated');
			
			console.log(`Calculated route displayed with ${path.length} nodes`);
			
		} catch (error) {
			console.error('Error showing calculated route:', error);
			showErrorNotification('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ: ' + error.message);
		}
	}

	// ========== 5. Helper Functions ==========

	// ‡∏´‡∏≤ starting point ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
	function findBestStartingPoint() {
		if (!validateWalkableRoutingData()) {
			return null;
		}
		
		const nodes = walkableRoutingData.nodes;
		
		// ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: center ‚Üí entrance ‚Üí grid ‚Üí ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
		const priorities = ['center', 'entrance', 'grid'];
		
		for (const type of priorities) {
			for (const nodeId in nodes) {
				const node = nodes[nodeId];
				if (node && node.type === type) {
					return nodeId;
				}
			}
		}
		
		// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡πÉ‡∏ä‡πâ node ‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏µ
		const firstNodeId = Object.keys(nodes)[0];
		return firstNodeId || null;
	}

	// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á nodes
	function calculateDistanceBetweenNodes(nodeId1, nodeId2) {
		const coords1 = getSafeNodeCoordinates(nodeId1);
		const coords2 = getSafeNodeCoordinates(nodeId2);
		
		const dx = coords2.x - coords1.x;
		const dy = coords2.y - coords1.y;
		const percentDistance = Math.sqrt(dx * dx + dy * dy);
		
		// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏°‡∏ï‡∏£
		const metersPerPercent = (walkableRoutingData.settings && walkableRoutingData.settings.metersPerPercent) || 1.2;
		return percentDistance * metersPerPercent;
	}

	// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á path ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	function calculatePathDistance(path) {
		if (!path || path.length < 2) return 0;
		
		let totalDistance = 0;
		for (let i = 0; i < path.length - 1; i++) {
			totalDistance += calculateDistanceBetweenNodes(path[i], path[i + 1]);
		}
		
		return totalDistance;
	}

	// ‡∏•‡∏ö route ‡πÄ‡∏Å‡πà‡∏≤
	function clearExistingRoute(svg) {
		if (!svg) return;
		
		try {
			// ‡∏•‡∏ö route elements
			const routeElements = svg.querySelectorAll('.route-line, .route-path, .route-marker');
			routeElements.forEach(element => element.remove());
			
			// ‡∏•‡∏ö old route elements (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
			const oldRoutes = svg.querySelectorAll('line[stroke="#ff0000"], polyline[stroke="#0066cc"]');
			oldRoutes.forEach(element => element.remove());
			
		} catch (error) {
			console.warn('Error clearing existing route:', error);
		}
	}

	// ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• route
	function showRouteInfo(startNodeId, endNodeId, distance, routeType) {
		try {
			const routeInfo = document.getElementById('routeInfo') || createRouteInfoElement();
			
			const startNode = getSafeNode(startNodeId);
			const endNode = getSafeNode(endNodeId);
			
			const startName = (startNode && startNode.name) || startNodeId;
			const endName = (endNode && endNode.name) || endNodeId;
			
			routeInfo.innerHTML = `
				<div class="route-info-content">
					<h4>üó∫Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á</h4>
					<p><strong>‡∏à‡∏≤‡∏Å:</strong> ${startName}</p>
					<p><strong>‡πÑ‡∏õ:</strong> ${endName}</p>
					<p><strong>‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á:</strong> ${distance.toFixed(1)} ‡πÄ‡∏°‡∏ï‡∏£</p>
					<p><strong>‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> ${routeType === 'calculated' ? '‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì' : '‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á'}</p>
				</div>
			`;
			
			routeInfo.style.display = 'block';
			
		} catch (error) {
			console.warn('Error showing route info:', error);
		}
	}

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á route info element
	function createRouteInfoElement() {
		const routeInfo = document.createElement('div');
		routeInfo.id = 'routeInfo';
		routeInfo.style.cssText = `
			position: fixed;
			top: 80px;
			right: 20px;
			background: white;
			border: 2px solid #0066cc;
			border-radius: 8px;
			padding: 15px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.15);
			z-index: 1000;
			max-width: 250px;
			font-family: Arial, sans-serif;
			display: none;
		`;
		
		document.body.appendChild(routeInfo);
		return routeInfo;
	}

	// ‡πÅ‡∏™‡∏î‡∏á error notification
	function showErrorNotification(message) {
		console.error(message);
		
		// ‡πÉ‡∏ä‡πâ existing notification system ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
		if (typeof showNotification === 'function') {
			showNotification(message, 'error');
		} else if (typeof showIndexNotification === 'function') {
			showIndexNotification(message, 'error');
		} else {
			// Fallback alert
			alert(message);
		}
	}

	// ========== 6. Data Recovery Functions ==========

	// ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• walkable ‡∏ñ‡πâ‡∏≤‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢
	async function recoverWalkableData() {
		console.log('üîß Attempting to recover walkable data...');
		
		try {
			const building = getCurrentBuildingName();
			
			// ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô: Sheets ‚Üí Admin cache ‚Üí Index cache ‚Üí Fixed grid
			
			// 1. ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Sheets
			if (typeof loadWalkableDataFromSheetsForIndex === 'function') {
				const sheetsData = await loadWalkableDataFromSheetsForIndex(building);
				if (sheetsData && sheetsData.nodes && Object.keys(sheetsData.nodes).length > 0) {
					console.log('‚úÖ Recovered data from Google Sheets');
					return true;
				}
			}
			
			// 2. ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ Phase 2.1 sync functions
			if (typeof syncAdminDataToIndex === 'function') {
				const synced = syncAdminDataToIndex(building);
				if (synced) {
					console.log('‚úÖ Recovered data from admin sync');
					return true;
				}
			}
			
			// 3. ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å cache
			if (typeof loadWalkableDataWithCacheFallback === 'function') {
				const cacheData = await loadWalkableDataWithCacheFallback(building);
				if (cacheData && cacheData.nodes && Object.keys(cacheData.nodes).length > 0) {
					console.log('‚úÖ Recovered data from cache');
					return true;
				}
			}
			
			// 4. ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ‡∏™‡∏£‡πâ‡∏≤‡∏á fixed grid
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
				console.log('‚úÖ Created fixed grid as fallback');
				return true;
			}
			
			console.warn('‚ùå Could not recover walkable data');
			return false;
			
		} catch (error) {
			console.error('‚ùå Error during data recovery:', error);
			return false;
		}
	}

	// ========== 7. Function Replacements ==========

	// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà functions ‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢ safe versions
	if (typeof window !== 'undefined') {
		// Backup original functions
		window.originalAddRouteMarkers = window.addRouteMarkers;
		window.originalShowStraightRoutePath = window.showStraightRoutePath;
		window.originalShowRouteToSelected = window.showRouteToSelected;
		
		// Replace with safe versions
		window.addRouteMarkers = addRouteMarkersSafe;
		//window.showStraightRoutePath = showStraightRoutePathSafe;
		window.showRouteToSelected = showRouteToSelectedSafe;
		
		// Add new functions
		window.validateWalkableRoutingData = validateWalkableRoutingData;
		window.getSafeNode = getSafeNode;
		window.getSafeNodeCoordinates = getSafeNodeCoordinates;
		window.recoverWalkableData = recoverWalkableData;
		
		console.log('‚úÖ Safe routing functions installed');
	}

	// ========== 8. Auto-Fix on Load ==========

	// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏ô‡πâ‡∏≤
	async function autoFixWalkableDataOnLoad() {
		console.log('üîß Auto-fixing walkable data on load...');
		
		try {
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
			const isValid = validateWalkableRoutingData();
			
			if (!isValid) {
				console.log('‚ö†Ô∏è Data validation failed, attempting recovery...');
				const recovered = await recoverWalkableData();
				
				if (!recovered) {
					console.error('‚ùå Data recovery failed');
					showErrorNotification('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
					return false;
				}
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà‡∏´‡∏•‡∏±‡∏á recovery
			const finalValidation = validateWalkableRoutingData();
			if (finalValidation) {
				console.log('‚úÖ Walkable data is now valid');
				
				// ‡πÅ‡∏™‡∏î‡∏á notification
				if (typeof showIndexNotification === 'function') {
					showIndexNotification('‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô', 'success');
				}
				
				return true;
			} else {
				console.error('‚ùå Final validation failed');
				return false;
			}
			
		} catch (error) {
			console.error('‚ùå Auto-fix failed:', error);
			return false;
		}
	}

	// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å auto-fix ‡πÄ‡∏°‡∏∑‡πà‡∏≠ DOM ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			setTimeout(autoFixWalkableDataOnLoad, 500);
		});
	} else {
		setTimeout(autoFixWalkableDataOnLoad, 500);
	}

	// ========== End Error Fix: SVG Routing Markers + Data Validation ==========

	// ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
	function ensurePersistentDestination() {
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ß‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
		if (!selectedRoom && persistentDestination && persistentDestination.roomCode) {
			selectedRoom = persistentDestination.roomCode;
			debugLog('üéØ Restored persistent destination:', persistentDestination.roomName);
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà
			updateDestinationDisplay();
			return true;
		}
		
		return selectedRoom && roomData[selectedRoom];
	}

	// ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
	function enhancedUpdateStartPointWithAutoRoute(x, y) {
		debugLog('üìç Enhanced start point update with persistent destination...', { 
			x: x.toFixed(2), 
			y: y.toFixed(2) 
		});
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
		const hasDestination = ensurePersistentDestination();
		autoRouteUpdate.hasActiveDestination = hasDestination;
		
		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏ã‡πà‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ)
		const oldStartPoint = startPoint ? { ...startPoint } : null;
		startPoint = {
			name: currentLanguage === 'th' ? '‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô' : 'Starting Point',
			x: x,
			y: y,
			hidden: true,
			timestamp: Date.now()
		};
		
		// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage
		localStorage.setItem('startPoint', JSON.stringify(startPoint));
		autoRouteUpdate.lastStartPoint = { ...startPoint };
		
		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI markers (‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô)
		updateStartPointMarker(x, y);
		
		// ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
		if (hasDestination && autoRouteUpdate.enabled) {
			debugLog('üîÑ Auto-updating route with persistent destination...', {
				destination: persistentDestination.roomName || selectedRoom,
				startPoint: { x: x.toFixed(2), y: y.toFixed(2) }
			});
			
			// ‡πÅ‡∏™‡∏î‡∏á brief notification
			const destination = roomData[selectedRoom];
			const message = currentLanguage === 'th' 
				? `üîÑ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á ${destination.name}`
				: `üîÑ Route updated to ${destination.name}`;
			showNotification(message, 'info', 2000); // ‡πÅ‡∏™‡∏î‡∏á 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å delay ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
			setTimeout(() => {
				enhancedAutoUpdateRoute();
			}, autoRouteUpdate.updateDelay);
			
		} else {
			// ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á ‡πÅ‡∏™‡∏î‡∏á notification ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
			updateRouteControls();
			
			const message = currentLanguage === 'th' 
				? `üìç ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢`
				: `üìç Start point updated - Please select destination`;
			showNotification(message, 'success');
		}
	}

	// ========== 3. Waypoint Generation System ==========

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á waypoints ‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
	function generateWaypoints(pathNodeIds) {
		if (!WAYPOINT_SYSTEM.enabled || !WAYPOINT_SYSTEM.showWaypoints) {
			return [];
		}
		
		const waypoints = [];
		const pathPoints = pathNodeIds.map(nodeId => walkableRoutingData.nodes[nodeId]);
		
		if (pathPoints.length < 2) return waypoints;
		
		debugLog('üéØ Generating waypoints for path...', {
			totalNodes: pathPoints.length,
			interval: WAYPOINT_SYSTEM.waypointInterval
		});
		
		// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
		let totalDistance = 0;
		const segmentDistances = [];
		
		for (let i = 0; i < pathPoints.length - 1; i++) {
			const segmentDistance = distanceBetweenPoints(pathPoints[i], pathPoints[i + 1]) 
								  * walkableRoutingData.settings.metersPerPercent;
			segmentDistances.push(segmentDistance);
			totalDistance += segmentDistance;
		}
		
		// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô waypoints ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
		const optimalWaypointCount = Math.max(
			WAYPOINT_SYSTEM.minWaypoints,
			Math.min(
				WAYPOINT_SYSTEM.maxWaypoints,
				Math.floor(totalDistance / WAYPOINT_SYSTEM.waypointInterval)
			)
		);
		
		// ‡∏™‡∏£‡πâ‡∏≤‡∏á waypoints ‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡πÜ ‡∏Å‡∏±‡∏ô‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
		for (let w = 1; w <= optimalWaypointCount; w++) {
			const targetDistance = (totalDistance * w) / (optimalWaypointCount + 1);
			
			// ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
			let accumulatedDistance = 0;
			let waypointPosition = null;
			
			for (let i = 0; i < segmentDistances.length; i++) {
				const segmentStart = accumulatedDistance;
				const segmentEnd = accumulatedDistance + segmentDistances[i];
				
				if (targetDistance >= segmentStart && targetDistance <= segmentEnd) {
					// interpolate ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ
					const ratio = (targetDistance - segmentStart) / segmentDistances[i];
					const pointA = pathPoints[i];
					const pointB = pathPoints[i + 1];
					
					waypointPosition = {
						x: pointA.x + (pointB.x - pointA.x) * ratio,
						y: pointA.y + (pointB.y - pointA.y) * ratio,
						segmentIndex: i,
						ratio: ratio
					};
					break;
				}
				
				accumulatedDistance += segmentDistances[i];
			}
			
			if (waypointPosition) {
				waypoints.push({
					id: `waypoint_${w}`,
					x: waypointPosition.x,
					y: waypointPosition.y,
					index: w,
					distance: targetDistance,
					segmentIndex: waypointPosition.segmentIndex,
					type: 'waypoint'
				});
			}
		}
		
		debugLog('‚úÖ Generated waypoints:', {
			count: waypoints.length,
			totalDistance: totalDistance.toFixed(1),
			interval: (totalDistance / (waypoints.length + 1)).toFixed(1)
		});
		
		return waypoints;
	}

	// ========== 4. Enhanced Route Drawing with Waypoints ==========

	// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô drawWalkablePath ‡πÄ‡∏î‡∏¥‡∏°
	 function drawWalkablePathWithWaypoints(pathNodeIds) {
		const routePath = document.getElementById('routePath') || createRoutePathElement();
		if (!routePath) return;
		
		routePath.innerHTML = ''; // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô
		
		// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
		const pathPoints = pathNodeIds.map(nodeId => walkableRoutingData.nodes[nodeId]);
		
		if (pathPoints.length < 2) return;
		
		debugLog('üé® Drawing walkable path with waypoints...', {
			points: pathPoints.length,
			waypointsEnabled: WAYPOINT_SYSTEM.showWaypoints
		});
		
		// ‡∏™‡∏£‡πâ‡∏≤‡∏á SVG path
		const pathString = pathPoints.map((point, index) => {
			const command = index === 0 ? 'M' : 'L';
			return `${command} ${point.x} ${point.y}`;
		}).join(' ');
		
		// 1. Glow effect (‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏£‡∏∑‡∏≠‡∏á‡πÅ‡∏™‡∏á)
		const glowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		glowPath.setAttribute('d', pathString);
		glowPath.setAttribute('class', 'route-line-glow');
		glowPath.setAttribute('stroke', '#fbbf24');
		glowPath.setAttribute('stroke-width', '1.2');
		glowPath.setAttribute('fill', 'none');
		glowPath.setAttribute('opacity', '0.6');
		routePath.appendChild(glowPath);
		
		// 2. Main path (‡πÄ‡∏™‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å)
		const mainPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
		mainPath.setAttribute('d', pathString);
		mainPath.setAttribute('class', 'route-line route-line-animated');
		mainPath.setAttribute('stroke', '#dc3545');
		mainPath.setAttribute('stroke-width', '0.6');
		mainPath.setAttribute('fill', 'none');
		mainPath.setAttribute('stroke-dasharray', '4 2');
		mainPath.setAttribute('stroke-linecap', 'round');
		routePath.appendChild(mainPath);
		
		// 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á waypoints
		if (WAYPOINT_SYSTEM.showWaypoints) {
			const waypoints = generateWaypoints(pathNodeIds);
			drawWaypoints(routePath, waypoints);
		}
		
		// 4. ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏° addRouteMarkers (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß)
		addRouteMarkers(pathPoints[0], pathPoints[pathPoints.length - 1]);
		
		routePath.style.display = 'block';
	}
 
 
	// ‡∏ß‡∏≤‡∏î waypoints ‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
	function drawWaypoints(routePath, waypoints) {
		if (!waypoints || waypoints.length === 0) return;
		
		debugLog('üéØ Drawing waypoints...', { count: waypoints.length });
		
		waypoints.forEach((waypoint, index) => {
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á waypoint marker
			const waypointGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			waypointGroup.setAttribute('class', 'waypoint-group');
			waypointGroup.setAttribute('data-waypoint-id', waypoint.id);
			
			// Pulse ring (animation)
			if (WAYPOINT_SYSTEM.animationEnabled) {
				const pulseRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				pulseRing.setAttribute('cx', waypoint.x);
				pulseRing.setAttribute('cy', waypoint.y);
				pulseRing.setAttribute('r', WAYPOINT_SYSTEM.waypointSize * 1.5);
				pulseRing.setAttribute('fill', 'none');
				pulseRing.setAttribute('stroke', WAYPOINT_STYLES.pulseColor);
				pulseRing.setAttribute('stroke-width', '0.2');
				pulseRing.setAttribute('opacity', '0');
				pulseRing.setAttribute('class', 'waypoint-pulse');
				
				// CSS animation ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡πà‡∏≤‡∏ô CSS
				waypointGroup.appendChild(pulseRing);
			}
			
			// Main waypoint circle
			const waypointCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			waypointCircle.setAttribute('cx', waypoint.x);
			waypointCircle.setAttribute('cy', waypoint.y);
			waypointCircle.setAttribute('r', WAYPOINT_SYSTEM.waypointSize);
			waypointCircle.setAttribute('fill', WAYPOINT_STYLES.fill);
			waypointCircle.setAttribute('stroke', WAYPOINT_STYLES.stroke);
			waypointCircle.setAttribute('stroke-width', WAYPOINT_STYLES.strokeWidth);
			waypointCircle.setAttribute('opacity', WAYPOINT_STYLES.opacity);
			waypointCircle.setAttribute('class', 'waypoint-marker');
			waypointGroup.appendChild(waypointCircle);
			
			// Label (‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç) ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
			if (WAYPOINT_SYSTEM.showLabels) {
				const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
				label.setAttribute('x', waypoint.x);
				label.setAttribute('y', waypoint.y + 0.2); // ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏•‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
				label.setAttribute('text-anchor', 'middle');
				label.setAttribute('font-size', WAYPOINT_STYLES.labelSize);
				label.setAttribute('font-weight', 'bold');
				label.setAttribute('fill', WAYPOINT_STYLES.labelColor);
				label.setAttribute('class', 'waypoint-label');
				label.textContent = waypoint.index;
				waypointGroup.appendChild(label);
			}
			
			routePath.appendChild(waypointGroup);
		});
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS animation ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö waypoints
		ensureWaypointCSS();
	}

	// ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö waypoint animations
	function ensureWaypointCSS() {
		if (document.getElementById('waypointAnimationCSS')) return;
		
		const css = document.createElement('style');
		css.id = 'waypointAnimationCSS';
		css.textContent = `
			/* Waypoint Animation Styles */
			.waypoint-pulse {
				animation: waypoint-pulse 2s ease-in-out infinite;
			}
			
			@keyframes waypoint-pulse {
				0% {
					r: ${WAYPOINT_SYSTEM.waypointSize * 0.5};
					opacity: 0.8;
				}
				50% {
					r: ${WAYPOINT_SYSTEM.waypointSize * 2};
					opacity: 0.3;
				}
				100% {
					r: ${WAYPOINT_SYSTEM.waypointSize * 3};
					opacity: 0;
				}
			}
			
			.waypoint-marker {
				transition: all 0.3s ease;
				cursor: pointer;
			}
			
			.waypoint-marker:hover {
				r: ${WAYPOINT_SYSTEM.waypointSize * 1.3};
				opacity: 1;
			}
			
			.waypoint-group:hover .waypoint-pulse {
				animation-duration: 1s;
			}
			
			.waypoint-label {
				pointer-events: none;
				transition: opacity 0.3s ease;
			}
			
			/* Waypoint visibility toggle */
			.waypoints-hidden .waypoint-group {
				opacity: 0;
				transition: opacity 0.5s ease;
			}
			
			.waypoints-visible .waypoint-group {
				opacity: 1;
				transition: opacity 0.5s ease;
			}
		`;
		document.head.appendChild(css);
	}

 
	// ========== 6. Waypoint Control Toggle ==========

	// ‡∏™‡∏£‡πâ‡∏≤‡∏á waypoint toggle control
	function createWaypointToggle() {
		const routeControls = document.querySelector('.route-controls');
		if (!routeControls) return;
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ toggle ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
		if (document.getElementById('waypointToggle')) return;
		
		const toggleContainer = document.createElement('div');
		toggleContainer.className = 'waypoint-toggle-container';
		toggleContainer.style.cssText = `
			display: flex;
			align-items: center;
			gap: 8px;
			margin-left: 10px;
			font-size: 12px;
			color: var(--text-secondary);
		`;
		
		toggleContainer.innerHTML = `
			<label class="waypoint-toggle">
				<input type="checkbox" id="waypointToggle" ${WAYPOINT_SYSTEM.showWaypoints ? 'checked' : ''}>
				<span class="toggle-slider"></span>
			</label>
			<span>${currentLanguage === 'th' ? '‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á' : 'Waypoints'}</span>
			<button id="waypointSettings" class="waypoint-settings-btn" title="Waypoint Settings">
				<i class="fas fa-cog"></i>
			</button>
		`;
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö toggle (‡πÉ‡∏ä‡πâ CSS ‡πÄ‡∏î‡∏¥‡∏°‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠ class)
		if (!document.getElementById('waypointToggleCSS')) {
			const css = document.createElement('style');
			css.id = 'waypointToggleCSS';
			css.textContent = `
				.waypoint-toggle {
					position: relative;
					display: inline-block;
					width: 40px;
					height: 20px;
				}
				
				.waypoint-toggle input {
					opacity: 0;
					width: 0;
					height: 0;
				}
				
				.waypoint-settings-btn {
					background: none;
					border: none;
					color: var(--text-secondary);
					cursor: pointer;
					padding: 4px;
					border-radius: 4px;
					font-size: 12px;
					transition: all 0.2s ease;
				}
				
				.waypoint-settings-btn:hover {
					background: var(--primary-color);
					color: white;
				}
			`;
			document.head.appendChild(css);
		}
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° event listeners
		const toggle = toggleContainer.querySelector('#waypointToggle');
		toggle.addEventListener('change', function() {
			WAYPOINT_SYSTEM.showWaypoints = this.checked;
			localStorage.setItem('waypointSystemEnabled', this.checked);
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
			if (routeDisplayed && currentRoute) {
				updateCurrentRouteWaypoints();
			}
			
			const message = currentLanguage === 'th' 
				? (this.checked ? '‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á' : '‚ùå ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á')
				: (this.checked ? '‚úÖ Waypoints enabled' : '‚ùå Waypoints disabled');
			showNotification(message, 'info');
		});
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° settings button
		const settingsBtn = toggleContainer.querySelector('#waypointSettings');
		settingsBtn.addEventListener('click', showWaypointSettings);
		
		routeControls.appendChild(toggleContainer);
	}

	// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï waypoints ‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
	function updateCurrentRouteWaypoints() {
		if (!walkableRoutingData.lastPath) return;
		
		debugLog('üîÑ Updating current route waypoints...', {
			showWaypoints: WAYPOINT_SYSTEM.showWaypoints,
			pathLength: walkableRoutingData.lastPath.length
		});
		
		// ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏° waypoints
		drawWalkablePathWithWaypoints(walkableRoutingData.lastPath);
	}

	// ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ waypoints
	function showWaypointSettings() {
		const modal = document.createElement('div');
		modal.className = 'waypoint-settings-modal';
		modal.style.cssText = `
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0,0,0,0.5);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
		`;
		
		modal.innerHTML = `
			<div class="settings-content" style="
				background: white;
				padding: 20px;
				border-radius: 12px;
				width: 300px;
				max-width: 90vw;
			">
				<h3>‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á</h3>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î (‡πÄ‡∏°‡∏ï‡∏£)</label>
					<input type="number" id="waypointInterval" value="${WAYPOINT_SYSTEM.waypointInterval}" min="5" max="50">
				</div>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</label>
					<input type="number" id="maxWaypoints" value="${WAYPOINT_SYSTEM.maxWaypoints}" min="2" max="15">
				</div>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>
						<input type="checkbox" id="showLabels" ${WAYPOINT_SYSTEM.showLabels ? 'checked' : ''}>
						‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á
					</label>
				</div>
				
				<div class="setting-group" style="margin: 15px 0;">
					<label>
						<input type="checkbox" id="animationEnabled" ${WAYPOINT_SYSTEM.animationEnabled ? 'checked' : ''}>
						‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Animation
					</label>
				</div>
				
				<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
					<button id="cancelSettings" style="padding: 8px 15px; border: 1px solid #ccc; background: white; border-radius: 6px;">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
					<button id="saveSettings" style="padding: 8px 15px; background: var(--primary-color); color: white; border: none; border-radius: 6px;">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</button>
				</div>
			</div>
		`;
		
		document.body.appendChild(modal);
		
		// Event listeners
		modal.querySelector('#cancelSettings').addEventListener('click', () => {
			document.body.removeChild(modal);
		});
		
		modal.querySelector('#saveSettings').addEventListener('click', () => {
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
			WAYPOINT_SYSTEM.waypointInterval = parseInt(modal.querySelector('#waypointInterval').value);
			WAYPOINT_SYSTEM.maxWaypoints = parseInt(modal.querySelector('#maxWaypoints').value);
			WAYPOINT_SYSTEM.showLabels = modal.querySelector('#showLabels').checked;
			WAYPOINT_SYSTEM.animationEnabled = modal.querySelector('#animationEnabled').checked;
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage
			localStorage.setItem('waypointSystemConfig', JSON.stringify(WAYPOINT_SYSTEM));
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
			if (routeDisplayed && currentRoute) {
				updateCurrentRouteWaypoints();
			}
			
			showNotification('‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß', 'success');
			document.body.removeChild(modal);
		});
		
		// ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á
		modal.addEventListener('click', (e) => {
			if (e.target === modal) {
				document.body.removeChild(modal);
			}
		});
	}

	// ========== 7. Enhanced Auto Update with Persistence ==========

	function enhancedAutoUpdateRoute() {
		if (routingLock.isProcessing) {
			debugLog('‚è≥ Route update already in progress, skipping enhanced auto update...');
			return;
		}
		
		if (autoRouteUpdate.isUpdating) {
			debugLog('‚è≥ Enhanced auto update already in progress...');
			return;
		}
		
		autoRouteUpdate.isUpdating = true;
		
		try {
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
			const hasDestination = ensurePersistentDestination();
			
			if (!startPoint || !hasDestination) {
				debugLog('‚ö†Ô∏è Missing required data for enhanced route update', {
					hasStartPoint: !!startPoint,
					hasDestination,
					selectedRoom
				});
				autoRouteUpdate.isUpdating = false;
				return;
			}
			
			// ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°
			safeClearRouteVisuals();
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
			const destination = roomData[selectedRoom];
			currentRoute = { start: startPoint, destination: destination };
			
			debugLog('üîÑ Enhanced auto-updating route with waypoints...', { 
				start: startPoint, 
				destination: destination.name,
				waypointsEnabled: WAYPOINT_SYSTEM.showWaypoints
			});
			
			showRouteToSelected();
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï state
			routeDisplayed = true;
			updateRouteControls(true);
			updateRoomMarkers();
			
			ensureRouteConsistency();
			
			
			debugLog('‚úÖ Enhanced auto route update completed with persistent destination');
			
		} catch (error) {
			debugLog('‚ùå Error in enhanced auto route update', error);
			showNotification('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á', 'error');
		} finally {
			autoRouteUpdate.isUpdating = false;
		}
	}

	 

	// ========== 9. Initialize Enhanced System ==========

	// ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ waypoint system
	function loadWaypointSettings() {
		const saved = localStorage.getItem('waypointSystemConfig');
		if (saved) {
			try {
				const config = JSON.parse(saved);
				Object.assign(WAYPOINT_SYSTEM, config);
				debugLog('üìÅ Loaded waypoint settings from localStorage');
			} catch (error) {
				debugLog('‚ö†Ô∏è Error loading waypoint settings:', error);
			}
		}
		
		// ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ enabled/disabled
		const enabled = localStorage.getItem('waypointSystemEnabled');
		if (enabled !== null) {
			WAYPOINT_SYSTEM.showWaypoints = enabled === 'true';
		}
	}

	// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö waypoint
	function initializeWaypointSystem() {
		debugLog('üéØ Initializing waypoint navigation system...');
		
		// ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
		loadWaypointSettings();
		
		// ‡∏™‡∏£‡πâ‡∏≤‡∏á toggle control
		setTimeout(() => {
			createWaypointToggle();
		}, 1000);
		
		debugLog('‚úÖ Waypoint system initialized:', {
			enabled: WAYPOINT_SYSTEM.enabled,
			showWaypoints: WAYPOINT_SYSTEM.showWaypoints,
			interval: WAYPOINT_SYSTEM.waypointInterval,
			maxWaypoints: WAYPOINT_SYSTEM.maxWaypoints
		});
	}

	// ========== 10. Integration and Exports ==========

	// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å
	function replaceWithEnhancedFunctions() {
		debugLog('üîÑ Replacing with enhanced waypoint functions...');
		
		// Backup original functions
		if (typeof window.originalUpdateStartPointWithAutoRoute === 'undefined') {
			window.originalUpdateStartPointWithAutoRoute = window.updateStartPointWithAutoRoute;
			window.originalDrawWalkablePath = window.drawWalkablePath;
			window.originalAutoUpdateRoute = window.autoUpdateRoute;
		}
		
		// Replace with enhanced versions
		window.updateStartPointWithAutoRoute = enhancedUpdateStartPointWithAutoRoute;
		window.drawWalkablePath = drawWalkablePathWithWaypoints;
		window.autoUpdateRoute = enhancedAutoUpdateRoute;
		
		debugLog('‚úÖ Enhanced waypoint functions activated');
	}

	// Auto-Initialize
	document.addEventListener('DOMContentLoaded', function() {
		setTimeout(() => {
			debugLog('üöÄ Starting waypoint navigation enhancement...');
			
			try {
				loadWaypointSettings();
				replaceWithEnhancedFunctions();
				//initializeWaypointSystem();
				
				debugLog('‚úÖ Waypoint navigation enhancement initialized');
				
			} catch (error) {
				debugLog('‚ùå Error initializing waypoint system', error);
			}
			
		}, 5000); // ‡∏£‡∏≠‡∏´‡∏•‡∏±‡∏á routing system ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
	});

	// Export enhanced system
	window.waypointNavigationSystem = {
		config: WAYPOINT_SYSTEM,
		generateWaypoints,
		updateWaypoints: updateCurrentRouteWaypoints,
		showSettings: showWaypointSettings,
		toggleWaypoints: (enabled) => {
			WAYPOINT_SYSTEM.showWaypoints = enabled;
			document.getElementById('waypointToggle').checked = enabled;
			updateCurrentRouteWaypoints();
		}
	};
	
	// üîß Debug & Fix Critical Routing Issues
        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏ô index.html

        // ========== 1. Enhanced Debugging & Safety Guards ==========

        // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô infinite loop
        let routingLock = {
            isProcessing: false,
            lastUpdate: 0,
            minInterval: 500, // ms
            maxRetries: 3,
            currentRetries: 0
        };

        // Enhanced logging
        function debugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] üîç ${message}`, data || '');
        }

        // ========== 2. Walkable Data Structure (Global Variables) ==========
        let walkableRoutingData = {
            nodes: {},           // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô { id: {x, y, building} }
            edges: [],          // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° [{from, to, weight, bidirectional}]
            settings: {
                metersPerPercent: 1.2,
                maxSearchRadius: 25,
                defaultWalkSpeed: 1.5  // m/s
            },
            currentBuilding: null,
            lastPath: null,
            isInitialized: false
        };

        // Auto-update configuration
        let autoRouteUpdate = {
            enabled: true,
            lastStartPoint: null,
            hasActiveDestination: false,
            isUpdating: false,
            updateDelay: 300 // milliseconds
        };

        // ========== 3. Core Functions ==========
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î (‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå)
        function distanceBetweenPoints(pointA, pointB) {
            return Math.sqrt(
                Math.pow(pointA.x - pointB.x, 2) + 
                Math.pow(pointA.y - pointB.y, 2)
            );
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á adjacency list ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö graph
        function buildAdjacencyList(metersPerPercent = 1.2) {
            const adj = {};
            
            for (const edge of walkableRoutingData.edges) {
                const weight = edge.weight || (distanceBetweenPoints(
                    walkableRoutingData.nodes[edge.from], 
                    walkableRoutingData.nodes[edge.to]
                ) * metersPerPercent);
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° edge ‡πÑ‡∏õ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á
                (adj[edge.from] ||= []).push({to: edge.to, weight: weight});
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° edge ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô bidirectional
                if (edge.bidirectional !== false) {
                    (adj[edge.to] ||= []).push({to: edge.from, weight: weight});
                }
            }
            
            return adj;
        }

        // Dijkstra's shortest path algorithm
        function dijkstraPathfinder(startId, endId, metersPerPercent = 1.2) {
            const adj = buildAdjacencyList(metersPerPercent);
            const distances = {};
            const previous = {};
            const priorityQueue = [[0, startId]];
            const visited = new Set();
            
            distances[startId] = 0;
            
            while (priorityQueue.length > 0) {
                // Sort ‡∏ï‡∏≤‡∏° distance (simple implementation)
                priorityQueue.sort((a, b) => a[0] - b[0]);
                const [currentDistance, currentNode] = priorityQueue.shift();
                
                if (visited.has(currentNode)) continue;
                visited.add(currentNode);
                
                // ‡∏´‡∏≤‡∏ñ‡∏∂‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß
                if (currentNode === endId) break;
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö neighbors
                for (const neighbor of (adj[currentNode] || [])) {
                    const newDistance = currentDistance + neighbor.weight;
                    
                    if (newDistance < (distances[neighbor.to] ?? Infinity)) {
                        distances[neighbor.to] = newDistance;
                        previous[neighbor.to] = currentNode;
                        priorityQueue.push([newDistance, neighbor.to]);
                    }
                }
            }
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á path
            const path = [];
            let currentNode = endId;
            
            // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ path
            if (!previous[currentNode] && currentNode !== startId) {
                return { path: [], distance: Infinity, error: 'No path found' };
            }
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á path ‡πÇ‡∏î‡∏¢‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö
            while (currentNode) {
                path.unshift(currentNode);
                if (currentNode === startId) break;
                currentNode = previous[currentNode];
            }
            
            return { 
                path, 
                distance: distances[endId] ?? 0,
                nodeCount: path.length
            };
        }

        // ========== 4. Enhanced Sample Data Creation ==========
        function createRobustSampleWalkableData() {
            debugLog('üèóÔ∏è Creating robust sample walkable data...');
            
            let nodeId = 1;
            walkableRoutingData.nodes = {};
            walkableRoutingData.edges = [];
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á grid ‡∏ó‡∏µ‡πà‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô 6x6 instead of 4x4
            const gridPoints = [];
            for (let x = 10; x <= 90; x += 16) { // ‡∏ó‡∏∏‡∏Å‡πÜ 16% ‡πÅ‡∏ó‡∏ô 20%
                for (let y = 10; y <= 90; y += 16) {
                    const point = {
                        id: nodeId.toString(),
                        x: x,
                        y: y,
                        building: walkableRoutingData.currentBuilding
                    };
                    walkableRoutingData.nodes[nodeId] = point;
                    gridPoints.push(point);
                    nodeId++;
                }
            }
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
            const centerPoints = [
                {x: 50, y: 50}, // ‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á
                {x: 30, y: 50}, // ‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢
                {x: 70, y: 50}, // ‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤
                {x: 50, y: 30}, // ‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏ö‡∏ô
                {x: 50, y: 70}  // ‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏•‡πà‡∏≤‡∏á
            ];
            
            centerPoints.forEach(point => {
                walkableRoutingData.nodes[nodeId] = {
                    id: nodeId.toString(),
                    x: point.x,
                    y: point.y,
                    building: walkableRoutingData.currentBuilding
                };
                nodeId++;
            });
            
            // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô - ‡πÄ‡∏û‡∏¥‡πà‡∏° radius
            const maxConnectionDistance = 25; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 20 ‡πÄ‡∏õ‡πá‡∏ô 25
            const nodes = Object.values(walkableRoutingData.nodes);
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const distance = distanceBetweenPoints(nodes[i], nodes[j]);
                    if (distance <= maxConnectionDistance) {
                        walkableRoutingData.edges.push({
                            from: nodes[i].id,
                            to: nodes[j].id,
                            weight: distance * walkableRoutingData.settings.metersPerPercent,
                            bidirectional: true
                        });
                    }
                }
            }
            
            debugLog('‚úÖ Sample walkable data created:', {
                nodes: Object.keys(walkableRoutingData.nodes).length,
                edges: walkableRoutingData.edges.length,
                maxDistance: maxConnectionDistance
            });
            
            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage
            try {
                const building = getCurrentBuilding();
                const storageKey = `walkableData_${building}`;
                const dataToSave = {
                    nodes: walkableRoutingData.nodes,
                    edges: walkableRoutingData.edges,
                    settings: walkableRoutingData.settings,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(storageKey, JSON.stringify(dataToSave));
                debugLog('üíæ Sample data saved to localStorage');
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not save to localStorage:', error);
            }
        }

        // ========== 5. Helper Functions ==========
        
        // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Å‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        function findNearestWalkableNode(targetX, targetY, maxRadius = 25) {
            let nearestNode = null;
            let nearestDistance = Infinity;
            
            for (const nodeId in walkableRoutingData.nodes) {
                const node = walkableRoutingData.nodes[nodeId];
                const distance = distanceBetweenPoints({x: targetX, y: targetY}, node);
                
                if (distance < nearestDistance && distance <= maxRadius) {
                    nearestDistance = distance;
                    nearestNode = { id: nodeId, distance, ...node };
                }
            }
            
            return nearestNode;
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á temporary node ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
        function createTemporaryNode(x, y, nodeId) {
            return {
                id: nodeId,
                x: x,
                y: y,
                isTemporary: true,
                building: walkableRoutingData.currentBuilding
            };
        }

        // Enhanced connection logic
        function enhancedConnectTemporaryNode(tempNodeId, maxRadius = 30) { // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 15 ‡πÄ‡∏õ‡πá‡∏ô 30
            const tempNode = walkableRoutingData.nodes[tempNodeId];
            if (!tempNode) {
                debugLog('‚ùå Temporary node not found:', tempNodeId);
                return [];
            }
            
            const connectedNodes = [];
            let nearestNodes = [];
            
            // ‡∏´‡∏≤‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
            for (const nodeId in walkableRoutingData.nodes) {
                if (nodeId === tempNodeId) continue;
                
                const node = walkableRoutingData.nodes[nodeId];
                const distance = distanceBetweenPoints(tempNode, node);
                
                if (distance <= maxRadius) {
                    nearestNodes.push({ nodeId, node, distance });
                }
            }
            
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡πÑ‡∏Å‡∏•
            nearestNodes.sort((a, b) => a.distance - b.distance);
            
            // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î 3-5 ‡∏à‡∏∏‡∏î
            const maxConnections = Math.min(5, nearestNodes.length);
            
            for (let i = 0; i < maxConnections; i++) {
                const { nodeId, node, distance } = nearestNodes[i];
                const weight = distance * walkableRoutingData.settings.metersPerPercent;
                
                walkableRoutingData.edges.push({
                    from: tempNodeId,
                    to: nodeId,
                    weight: weight,
                    bidirectional: true,
                    isTemporary: true
                });
                
                connectedNodes.push(nodeId);
            }
            
            debugLog(`üîó Connected temporary node ${tempNodeId} to ${connectedNodes.length}/${nearestNodes.length} nearby nodes`, {
                connections: connectedNodes,
                maxRadius,
                nearestDistance: nearestNodes[0]?.distance
            });
            
            return connectedNodes;
        }

        // ‡∏•‡∏ö temporary nodes ‡πÅ‡∏•‡∏∞ edges
        function cleanupTemporaryNodes() {
            // ‡∏•‡∏ö temporary nodes
            for (const nodeId in walkableRoutingData.nodes) {
                if (walkableRoutingData.nodes[nodeId].isTemporary) {
                    delete walkableRoutingData.nodes[nodeId];
                }
            }
            
            // ‡∏•‡∏ö temporary edges
            walkableRoutingData.edges = walkableRoutingData.edges.filter(edge => !edge.isTemporary);
        }

        // ========== 6. Safe Route Creation ==========
        
        function safeShowWalkableRoutePath(start, destination) {
            const now = Date.now();
            
            // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô rapid successive calls
            if (routingLock.isProcessing) {
                debugLog('‚è≥ Routing already in progress, skipping...');
                return;
            }
            
            if (now - routingLock.lastUpdate < routingLock.minInterval) {
                debugLog('‚è±Ô∏è Too soon for another route update, skipping...');
                return;
            }
            
            routingLock.isProcessing = true;
            routingLock.lastUpdate = now;
            
            try {
                debugLog('üõ£Ô∏è Safe walkable route creation started', {start, destination});
                
                // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô
                safeClearRouteVisuals();
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° walkable data
                if (!walkableRoutingData.isInitialized) {
                    debugLog('üìö Initializing walkable data...');
                    initializeWalkableRouting();
                }
                
                const nodesCount = Object.keys(walkableRoutingData.nodes).length;
                const edgesCount = walkableRoutingData.edges.length;
                
                debugLog('üìä Walkable data status:', { nodesCount, edgesCount });
                
                if (nodesCount === 0) {
                    debugLog('‚ö†Ô∏è No walkable nodes, creating sample data...');
                    createRobustSampleWalkableData();
                }
                
                if (Object.keys(walkableRoutingData.nodes).length < 5) {
                    debugLog('‚ùå Insufficient walkable data, falling back to straight line');
                    routingLock.isProcessing = false;
                    return showStraightRoutePath(start, destination);
                }
                
                // ‡∏•‡∏ö temporary nodes ‡πÄ‡∏Å‡πà‡∏≤
                cleanupTemporaryNodes();
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á temporary nodes ‡πÉ‡∏´‡∏°‡πà
                const startNodeId = 'temp_start';
                const endNodeId = 'temp_end';
                
                walkableRoutingData.nodes[startNodeId] = createTemporaryNode(start.x, start.y, startNodeId);
                walkableRoutingData.nodes[endNodeId] = createTemporaryNode(destination.x, destination.y, endNodeId);
                
                // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ temporary nodes
                const startConnections = enhancedConnectTemporaryNode(startNodeId, 35);
                const endConnections = enhancedConnectTemporaryNode(endNodeId, 35);
                
                if (startConnections.length === 0 || endConnections.length === 0) {
                    debugLog('‚ùå Cannot connect to walkable network, using straight line', {
                        startConnections: startConnections.length,
                        endConnections: endConnections.length,
                        totalNodes: Object.keys(walkableRoutingData.nodes).length
                    });
                    
                    cleanupTemporaryNodes();
                    routingLock.isProcessing = false;
                    return showStraightRoutePath(start, destination);
                }
                
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
                debugLog('üßÆ Calculating Dijkstra path...');
                const result = dijkstraPathfinder(startNodeId, endNodeId, walkableRoutingData.settings.metersPerPercent);
                
                if (result.path.length === 0) {
                    debugLog('‚ùå No walkable path found, using straight line');
                    cleanupTemporaryNodes();
                    routingLock.isProcessing = false;
                    return showStraightRoutePath(start, destination);
                }
                
                // ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
                drawWalkablePath(result.path);
                displayRouteInfo(result);
                
                // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï state
                routeDisplayed = true;
                walkableRoutingData.lastPath = result.path;
                updateRouteControls(true);
                
                // ‡πÅ‡∏™‡∏î‡∏á notification
                const message = currentLanguage === 'th' 
                    ? `üõ£Ô∏è ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô: ${result.distance.toFixed(1)}m, ${result.nodeCount} ‡∏à‡∏∏‡∏î`
                    : `üõ£Ô∏è Walking route: ${result.distance.toFixed(1)}m, ${result.nodeCount} points`;
                showNotification(message, 'success');
                
                debugLog('‚úÖ Walkable route created successfully', result);
                
            } catch (error) {
                debugLog('‚ùå Error in walkable route creation', error);
                cleanupTemporaryNodes();
                showNotification('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á', 'error');
                
                // Fallback ‡πÅ‡∏ï‡πà‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô loop
                if (routingLock.currentRetries < routingLock.maxRetries) {
                    routingLock.currentRetries++;
                    setTimeout(() => {
                        showStraightRoutePath(start, destination);
                    }, 100);
                }
            } finally {
                routingLock.isProcessing = false;
                routingLock.currentRetries = 0;
            }
        }

        // ========== 7. Visual Functions ==========
        
        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô drawWalkablePath ‡πÄ‡∏î‡∏¥‡∏°
		function drawWalkablePath(pathNodeIds) {
			const routePath = document.getElementById('routePath') || createRoutePathElement();
			if (!routePath) return;
			
			routePath.innerHTML = '';
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
			const pathPoints = pathNodeIds.map(nodeId => walkableRoutingData.nodes[nodeId]);
			
			if (pathPoints.length < 2) return;
			
			debugLog('üé® Drawing walkable path:', {
				points: pathPoints.length,
				startHidden: true,
				endVisible: true
			});
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á SVG path
			const pathString = pathPoints.map((point, index) => {
				const command = index === 0 ? 'M' : 'L';
				return `${command} ${point.x} ${point.y}`;
			}).join(' ');
			
			// Glow effect (‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏£‡∏∑‡∏≠‡∏á‡πÅ‡∏™‡∏á)
			const glowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			glowPath.setAttribute('d', pathString);
			glowPath.setAttribute('class', 'route-line-glow');
			glowPath.setAttribute('stroke', '#fbbf24');
			glowPath.setAttribute('stroke-width', '1.0');
			glowPath.setAttribute('fill', 'none');
			glowPath.setAttribute('opacity', '0.7');
			routePath.appendChild(glowPath);
			
			// Main path (‡πÄ‡∏™‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å)
			const mainPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			mainPath.setAttribute('d', pathString);
			mainPath.setAttribute('class', 'route-line route-line-animated');
			mainPath.setAttribute('stroke', '#dc3545');
			mainPath.setAttribute('stroke-width', '0.5');
			mainPath.setAttribute('fill', 'none');
			mainPath.setAttribute('stroke-dasharray', '3 1');
			mainPath.setAttribute('stroke-linecap', 'round');
			routePath.appendChild(mainPath);
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏â‡∏û‡∏≤‡∏∞ destination marker (‡πÑ‡∏°‡πà‡∏°‡∏µ start marker)
			addRouteMarkers(pathPoints[0], pathPoints[pathPoints.length - 1]);
			
			routePath.style.display = 'block';
		}

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° route markers ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏° - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ destination marker
		function addRouteMarkers(startPoint, endPoint) {
			const routePath = document.getElementById('routePath');
			if (!routePath) return;
			
			// ‡∏•‡∏ö markers ‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≥)
			routePath.querySelectorAll('.route-marker, .destination-marker, .destination-label').forEach(el => el.remove());
			
			// ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ End marker (‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á) - ‡πÑ‡∏°‡πà‡∏°‡∏µ start marker
			const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			endMarker.setAttribute('cx', endPoint.x);
			endMarker.setAttribute('cy', endPoint.y);
			endMarker.setAttribute('r', '1.5');
			endMarker.setAttribute('fill', '#dc3545');
			endMarker.setAttribute('stroke', '#fff');
			endMarker.setAttribute('stroke-width', '0.4');
			endMarker.setAttribute('class', 'route-marker destination-marker');
			endMarker.setAttribute('data-marker-type', 'destination');
			routePath.appendChild(endMarker);
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° destination label
			const destLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
			destLabel.setAttribute('x', endPoint.x);
			destLabel.setAttribute('y', endPoint.y - 2.5);
			destLabel.setAttribute('text-anchor', 'middle');
			destLabel.setAttribute('font-size', '8px');
			destLabel.setAttribute('font-weight', 'bold');
			destLabel.setAttribute('fill', '#dc3545');
			destLabel.setAttribute('class', 'destination-label');
			destLabel.setAttribute('data-marker-type', 'destination');
			destLabel.textContent = 'üéØ';
			routePath.appendChild(destLabel);
			
			debugLog('üéØ Only destination marker shown (no duplicates)');
		}
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
        function displayRouteInfo(routeResult) {
			const { distance, nodeCount, path } = routeResult;
			
			// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
			const walkingTime = Math.ceil(distance / walkableRoutingData.settings.defaultWalkSpeed);
			const gridNodesUsed = path.filter(nodeId => {
				const node = walkableRoutingData.nodes[nodeId];
				return node && node.type === 'grid';
			}).length;
			const strategicNodesUsed = nodeCount - gridNodesUsed;
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï route steps ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ element
			const routeSteps = document.getElementById('routeSteps');
			if (routeSteps) {
				const stepsHTML = `
					<div class="route-summary">
						<div class="summary-item">
							<i class="fas fa-route"></i>
							<span>‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á: ${distance.toFixed(1)} ‡πÄ‡∏°‡∏ï‡∏£</span>
						</div>
						<div class="summary-item">
							<i class="fas fa-clock"></i>
							<span>‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏¥‡∏ô: ~${walkingTime} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ</span>
						</div>
						<div class="summary-item">
							<i class="fas fa-map-marker-alt"></i>
							<span>‡∏à‡∏∏‡∏î‡∏ú‡πà‡∏≤‡∏ô: ${nodeCount} ‡∏à‡∏∏‡∏î</span>
						</div>
						<div class="summary-item">
							<i class="fas fa-network-wired"></i>
							<span>Grid: ${gridNodesUsed} | Strategic: ${strategicNodesUsed}</span>
						</div>
					</div>
				`;
				
				routeSteps.innerHTML = stepsHTML;
			}
			
			debugLog('üìä Route info displayed:', { 
				distance: distance.toFixed(1), 
				nodeCount, 
				walkingTime,
				gridNodesUsed,
				strategicNodesUsed
			});
		}

        // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞ visual elements ‡πÑ‡∏°‡πà‡∏•‡∏ö state
        function safeClearRouteVisuals() {
            debugLog('üóëÔ∏è Safely clearing route visuals...');
            
            try {
                // ‡∏•‡∏ö visual elements
                const routeSelectors = [
                    '.route-line', 
                    '.route-marker', 
                    '.route-path',
                    '.route-step-marker',
                    '.navigation-marker',
                    '[data-route="true"]',
                    '.route-animated',
                    '.route-line-animated',
                    '.route-marker-enhanced',
                    'path[stroke="#dc3545"]',
                    'circle[fill="#28a745"]',
                    'circle[fill="#dc3545"]'
                ];
                
                let removedCount = 0;
                routeSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        el.remove();
                        removedCount++;
                    });
                });
                
                // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå routePath
                const routePath = document.getElementById('routePath');
                if (routePath) {
                    routePath.innerHTML = '';
                }
                
                debugLog(`‚úÖ Cleared ${removedCount} route visual elements`);
                
            } catch (error) {
                debugLog('‚ùå Error clearing route visuals', error);
            }
        }

        // ========== 8. Auto-Update Functions ==========
        
        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà event listeners ‡πÄ‡∏î‡∏¥‡∏°
        function enhancedMapClickHandler(event) {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà room marker ‡∏´‡∏£‡∏∑‡∏≠ controls
            if (event.target.closest('.room-marker') || 
                event.target.closest('.route-controls') ||
                event.target.closest('.search-container') ||
                event.target.closest('.room-action-overlay')) {
                return;
            }

            const mapArea = event.currentTarget;
            const rect = mapArea.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï
            if (x >= 0 && x <= 100 && y >= 0 && y <= 100) {
                updateStartPointWithAutoRoute(x, y);
			
            }
        }

        function updateStartPointWithAutoRoute(x, y) {
			debugLog('üìç Updating hidden start point with auto-route...', { x: x.toFixed(2), y: y.toFixed(2) });
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
			const hasDestination = selectedRoom && roomData[selectedRoom];
			autoRouteUpdate.hasActiveDestination = hasDestination;
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏ã‡πà‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ)
			const oldStartPoint = startPoint ? { ...startPoint } : null;
			startPoint = {
				name: currentLanguage === 'th' ? '‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô' : 'Starting Point',
				x: x,
				y: y,
				hidden: true  // flag ‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡∏ã‡πà‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
			};
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage
			localStorage.setItem('startPoint', JSON.stringify(startPoint));
			autoRouteUpdate.lastStartPoint = { ...startPoint };
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI markers (‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô)
			updateStartPointMarker(x, y);
			
			// ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
			if (hasDestination && autoRouteUpdate.enabled) {
				debugLog('üîÑ Auto-updating route to existing destination (start point hidden)...');
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å delay ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
				setTimeout(() => {
					safeAutoUpdateRoute();
				}, autoRouteUpdate.updateDelay);
				
			} else {
				// ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà notification (‡πÑ‡∏°‡πà‡∏ö‡∏≠‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô)
				updateRouteControls();
				
				const message = currentLanguage === 'th' 
					? `üìç ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢`
					: `üìç Start point updated - Please select destination`;
				showNotification(message, 'success');
			}
		}

        function safeAutoUpdateRoute() {
            if (routingLock.isProcessing) {
                debugLog('‚è≥ Route update already in progress, skipping auto update...');
                return;
            }
            
            if (autoRouteUpdate.isUpdating) {
                debugLog('‚è≥ Auto update already in progress...');
                return;
            }
            
            autoRouteUpdate.isUpdating = true;
            
            try {
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
                if (!startPoint || !selectedRoom || !roomData[selectedRoom]) {
                    debugLog('‚ö†Ô∏è Missing required data for auto route update');
                    autoRouteUpdate.isUpdating = false;
                    return;
                }
                
                // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°
                safeClearRouteVisuals();
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
                const destination = roomData[selectedRoom];
                currentRoute = { start: startPoint, destination: destination };
                
                debugLog('üîÑ Auto-updating route', { start: startPoint, destination: destination.name });
                
                // ‡πÉ‡∏ä‡πâ safe walkable routing
                safeShowWalkableRoutePath(startPoint, destination);
                
                // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï state
                routeDisplayed = true;
                updateRouteControls(true);
                updateRoomMarkers();
                
                debugLog('‚úÖ Auto route update completed');
                
            } catch (error) {
                debugLog('‚ùå Error in auto route update', error);
                showNotification('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á', 'error');
            } finally {
                autoRouteUpdate.isUpdating = false;
            }
        }
		
		
        // ========== 9. Initialization Functions ==========
        
        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö walkable routing
		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï initialization ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ fixed grid
		function initializeWalkableRouting() {
			debugLog('üöÄ Initializing walkable routing system with fixed grid...');
			
			// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å localStorage ‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á fixed grid
			loadWalkableData();
			
			// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
			walkableRoutingData.currentBuilding = getCurrentBuilding();
			
			walkableRoutingData.isInitialized = true;
			
			debugLog('‚úÖ Fixed walkable routing initialized:', {
				nodesCount: Object.keys(walkableRoutingData.nodes).length,
				edgesCount: walkableRoutingData.edges.length,
				building: walkableRoutingData.currentBuilding,
				gridType: 'Fixed 6x6 + Strategic',
				startPointVisible: false
			});
		}

        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadWalkableData ‡πÄ‡∏î‡∏¥‡∏°
		function loadWalkableData() {
			const building = getCurrentBuilding();
			const storageKey = `walkableData_${building}`;
			const savedData = localStorage.getItem(storageKey);
			
			let useFixed = true;  // ‡πÉ‡∏ä‡πâ fixed grid ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å
			
			if (savedData) {
				try {
					const data = JSON.parse(savedData);
					
					// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô fixed grid data ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
					if (data.gridInfo && data.gridInfo.type === 'fixed_grid') {
						walkableRoutingData.nodes = data.nodes || {};
						walkableRoutingData.edges = data.edges || [];
						
						if (data.settings) {
							walkableRoutingData.settings = { ...walkableRoutingData.settings, ...data.settings };
						}
						
						debugLog('üìÅ Loaded fixed grid data from localStorage:', storageKey);
						debugLog('Grid info:', data.gridInfo);
						useFixed = false;  // ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
					}
				} catch (error) {
					console.error('Error loading walkable data:', error);
					useFixed = true;  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
				}
			}
			
			if (useFixed) {
				debugLog('üèóÔ∏è Creating new fixed walkable grid...');
				createFixedWalkableGrid();
			}
		}

        // ‡πÑ‡∏î‡πâ building ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        function getCurrentBuilding() {
            return window.currentSelectedBuilding || 
                   document.querySelector('.building-filter-active')?.textContent || 
                   'Main Building';
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á route path element ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
        function createRoutePathElement() {
			let routePath = document.getElementById('routePath');
			
			if (!routePath) {
				const mapContainer = document.getElementById('mapContainer') || 
								   document.querySelector('.map-area') ||
								   document.querySelector('.map-container');
				
				if (mapContainer) {
					routePath = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
					routePath.id = 'routePath';
					routePath.className = 'route-path';
					// ‡∏•‡∏ö‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß:
					routePath.setAttribute('viewBox', '0 0 100 100');
				    routePath.setAttribute('preserveAspectRatio', 'none');
					
					// ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ:
					routePath.style.position = 'absolute';
					routePath.style.top = '0';
					routePath.style.left = '0';
					routePath.style.width = '100%';
					routePath.style.height = '100%';
					//routePath.style.pointerEvents = 'none';
					//routePath.style.zIndex = '10';
					
					mapContainer.appendChild(routePath);
				}
			}
			
			return routePath;
		}
				 

        // ========== 11. Integration and Auto-Initialize ==========
        
        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
        function replaceFunctionsWithSafeVersions() {
            debugLog('üîÑ Replacing functions with safe versions...');
            
            // Backup original functions
            if (typeof window.originalShowWalkableRoutePath === 'undefined') {
                window.originalShowStraightRoutePath = window.showStraightRoutePath;
            }
            
            // Replace with safe versions
            window.showStraightRoutePath = safeShowWalkableRoutePath;
            window.clearRouteVisuals = safeClearRouteVisuals;
            
            debugLog('‚úÖ Functions replaced with safe versions');
        }

        // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà event listeners ‡πÄ‡∏î‡∏¥‡∏°
        function initializeEnhancedRouting() {
            debugLog('üöÄ Initializing enhanced auto-route system...');
            
            // ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å localStorage
            const savedSetting = localStorage.getItem('autoRouteUpdateEnabled');
            if (savedSetting !== null) {
                autoRouteUpdate.enabled = savedSetting === 'true';
            }
            
            // ‡∏´‡∏≤ map area elements
            const mapAreas = document.querySelectorAll('.map-area, #mapContainer, .map-container');
            
            mapAreas.forEach(mapArea => {
                if (mapArea) {
                    // ‡∏•‡∏ö event listeners ‡πÄ‡∏î‡∏¥‡∏°
                    const newMapArea = mapArea.cloneNode(true);
                    mapArea.parentNode.replaceChild(newMapArea, mapArea);
                    
                    // ‡πÄ‡∏û‡∏¥‡πà‡∏° enhanced event listener
                    newMapArea.addEventListener('click', enhancedMapClickHandler);
                    debugLog('‚úÖ Enhanced click handler attached to:', newMapArea.className);
                }
            });
            
            debugLog('üéØ Enhanced auto-route system initialized!');
        }
		//************************* V1.2End: Dijkstra *************************
	
		// üîó Admin-Index Integration Bridge V1.3
		// ========== 1. Compatibility Analysis ==========
		/*V1.3
		üîç CONFLICTS DETECTED:

		Admin.html ‡πÉ‡∏ä‡πâ:
		- walkablePointsData (global object)
		- Dynamic node creation (click to add)
		- localStorage key: walkableData_${building}
		- Manual node management via UI

		Index.html ‡πÉ‡∏ä‡πâ:
		- walkableRoutingData (global object) 
		- Fixed grid system (48 nodes)
		- localStorage key: walkableData_${building} (SAME!)
		- Automatic grid generation

		‚ùå CONFLICT: Data structure ‡πÅ‡∏•‡∏∞ management approach ‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô
		‚úÖ SOLUTION: ‡∏™‡∏£‡πâ‡∏≤‡∏á integration bridge
		*/
 

		// ========== 3. Data Format Converter ==========

		// ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å admin format ‡πÄ‡∏õ‡πá‡∏ô index format
		function convertAdminToIndexFormat(adminData) {
			if (!adminData || !adminData.nodes) return null;
			
			debugLog('üîÑ Converting admin data to index format...', {
				adminNodes: Object.keys(adminData.nodes).length,
				adminEdges: adminData.edges ? adminData.edges.length : 0
			});
			
			const indexData = {
				nodes: {},
				edges: [],
				settings: {
					metersPerPercent: adminData.settings?.metersPerPercent || 1.2,
					maxSearchRadius: adminData.settings?.maxConnectionDistance || 25,
					defaultWalkSpeed: 1.5
				},
				currentBuilding: adminData.building || adminData.currentBuilding,
				lastPath: null,
				isInitialized: true,
				dataSource: 'admin',
				syncTime: new Date().toISOString()
			};
			
			// ‡πÅ‡∏õ‡∏•‡∏á nodes
			Object.values(adminData.nodes).forEach(node => {
				indexData.nodes[node.id] = {
					id: node.id,
					x: node.x,
					y: node.y,
					type: node.type || 'admin',  // mark as admin-created
					building: node.building || indexData.currentBuilding,
					isFixed: false,  // admin nodes ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà fixed
					source: 'admin'
				};
			});
			
			// ‡πÅ‡∏õ‡∏•‡∏á edges
			if (adminData.edges && Array.isArray(adminData.edges)) {
				adminData.edges.forEach(edge => {
					indexData.edges.push({
						from: edge.from,
						to: edge.to,
						weight: edge.weight,
						bidirectional: edge.bidirectional !== false,
						type: 'admin',
						source: 'admin'
					});
				});
			}
			
			debugLog('‚úÖ Admin to index conversion completed:', {
				convertedNodes: Object.keys(indexData.nodes).length,
				convertedEdges: indexData.edges.length
			});
			
			return indexData;
		}

		// ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å index format ‡πÄ‡∏õ‡πá‡∏ô admin format
		function convertIndexToAdminFormat(indexData) {
			if (!indexData || !indexData.nodes) return null;
			
			debugLog('üîÑ Converting index data to admin format...', {
				indexNodes: Object.keys(indexData.nodes).length,
				indexEdges: indexData.edges ? indexData.edges.length : 0
			});
			
			const adminData = {
				currentBuilding: indexData.currentBuilding,
				building: indexData.currentBuilding,
				nodes: {},
				edges: [],
				settings: {
					maxConnectionDistance: indexData.settings?.maxSearchRadius || 25,
					metersPerPercent: indexData.settings?.metersPerPercent || 1.2,
					autoConnect: true,
					snapToGrid: false,
					gridSize: 5
				},
				selectedNodes: new Set(),
				isDragging: false,
				dragNode: null,
				dataSource: 'index',
				syncTime: new Date().toISOString()
			};
			
			// ‡πÅ‡∏õ‡∏•‡∏á nodes
			Object.values(indexData.nodes).forEach(node => {
				adminData.nodes[node.id] = {
					id: node.id,
					x: node.x,
					y: node.y,
					type: node.type || 'grid',
					building: node.building || adminData.currentBuilding,
					source: node.source || 'index'
				};
			});
			
			// ‡πÅ‡∏õ‡∏•‡∏á edges
			if (indexData.edges && Array.isArray(indexData.edges)) {
				indexData.edges.forEach(edge => {
					adminData.edges.push({
						from: edge.from,
						to: edge.to,
						weight: edge.weight,
						bidirectional: edge.bidirectional !== false,
						source: edge.source || 'index'
					});
				});
			}
			
			debugLog('‚úÖ Index to admin conversion completed:', {
				convertedNodes: Object.keys(adminData.nodes).length,
				convertedEdges: adminData.edges.length
			});
			
			return adminData;
		}

		// ========== 4. Smart Data Sync ==========

		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô index.html ‡∏à‡∏≤‡∏Å admin data
		function syncAdminDataToIndex(building) {
			if (!ADMIN_INDEX_BRIDGE.isIndexMode()) return false;
			
			debugLog('üì• Syncing admin data to index...', { building });
			
			try {
				// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å admin
				const storageKey = `walkableData_${building}`;
				const adminDataString = localStorage.getItem(storageKey);
				
				if (!adminDataString) {
					debugLog('‚ö†Ô∏è No admin data found, using fixed grid');
					return false;
				}
				
				const adminData = JSON.parse(adminDataString);
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å admin ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
				if (adminData.dataSource === 'index') {
					debugLog('‚ÑπÔ∏è Data source is index, no sync needed');
					return false;
				}
				
				// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô index format
				const indexData = convertAdminToIndexFormat(adminData);
				if (!indexData) {
					debugLog('‚ùå Failed to convert admin data');
					return false;
				}
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkableRoutingData
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					debugLog('‚úÖ walkableRoutingData updated from admin');
				}
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï localStorage ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index
				const indexStorageKey = `walkableData_${building}_index`;
				localStorage.setItem(indexStorageKey, JSON.stringify(indexData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('‚úÖ Admin data synced to index successfully');
				return true;
				
			} catch (error) {
				debugLog('‚ùå Error syncing admin data to index:', error);
				return false;
			}
		}

		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô admin.html ‡∏à‡∏≤‡∏Å index data
		function syncIndexDataToAdmin(building) {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) return false;
			
			debugLog('üì§ Syncing index data to admin...', { building });
			
			try {
				// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å index
				const indexStorageKey = `walkableData_${building}_index`;
				const indexDataString = localStorage.getItem(indexStorageKey);
				
				if (!indexDataString) {
					debugLog('‚ö†Ô∏è No index data found');
					return false;
				}
				
				const indexData = JSON.parse(indexDataString);
				
				// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô admin format
				const adminData = convertIndexToAdminFormat(indexData);
				if (!adminData) {
					debugLog('‚ùå Failed to convert index data');
					return false;
				}
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkablePointsData
				if (typeof walkablePointsData !== 'undefined') {
					Object.assign(walkablePointsData, adminData);
					
					// Render ‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
					
					debugLog('‚úÖ walkablePointsData updated from index');
				}
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('‚úÖ Index data synced to admin successfully');
				return true;
				
			} catch (error) {
				debugLog('‚ùå Error syncing index data to admin:', error);
				return false;
			}
		}

		// ========== 5. Automatic Sync Triggers ==========

		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞ sync ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏ô‡πâ‡∏≤
		function autoSyncOnPageLoad() {
			if (!ADMIN_INDEX_BRIDGE.syncEnabled) return;
			
			const building = getCurrentBuilding();
			if (!building) return;
			
			debugLog('üîÑ Auto-sync on page load...', { 
				building, 
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode()
			});
			
			if (ADMIN_INDEX_BRIDGE.isIndexMode()) {
				// ‡πÉ‡∏ô index.html - ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å admin ‡∏Å‡πà‡∏≠‡∏ô
				const adminSynced = syncAdminDataToIndex(building);
				
				if (!adminSynced) {
					debugLog('üìã No admin data available, creating fixed grid for index');
					// ‡∏™‡∏£‡πâ‡∏≤‡∏á fixed grid ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
					if (typeof createFixedWalkableGrid === 'function') {
						createFixedWalkableGrid();
					}
				} else {
					debugLog('‚úÖ Using admin-created walkable points in index');
				}
				
			} else if (ADMIN_INDEX_BRIDGE.isAdminMode()) {
				// ‡πÉ‡∏ô admin.html - ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏Å‡∏ï‡∏¥
				debugLog('üìã Admin mode: Using standard admin data loading');
			}
		}

		// ========== 6. Enhanced Integration Functions ==========

		// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadWalkableData ‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏ô index.html
		function loadWalkableDataWithAdminSync() {
			const building = getCurrentBuilding();
			const storageKey = `walkableData_${building}`;
			const indexStorageKey = `walkableData_${building}_index`;
			
			debugLog('üìÅ Loading walkable data with admin sync...', { building });
			
			// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å admin ‡∏Å‡πà‡∏≠‡∏ô
			const adminSynced = syncAdminDataToIndex(building);
			
			if (adminSynced) {
				debugLog('‚úÖ Loaded admin-created walkable data');
				return;
			}
			
			// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å admin ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å index cache
			const indexDataString = localStorage.getItem(indexStorageKey);
			if (indexDataString) {
				try {
					const data = JSON.parse(indexDataString);
					Object.assign(walkableRoutingData, data);
					debugLog('üìÅ Loaded cached index walkable data');
					return;
				} catch (error) {
					debugLog('‚ö†Ô∏è Error loading cached data:', error);
				}
			}
			
			// ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏î‡πÜ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á fixed grid
			debugLog('üèóÔ∏è No existing data, creating fixed grid');
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
			}
		}

		// ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô saveWalkableData ‡πÉ‡∏ô admin.html
		function enhancedSaveWalkableData() {
			if (typeof saveWalkableData === 'function') {
				// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô
				saveWalkableData();
				
				// ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô sync ‡πÑ‡∏õ index
				const building = getCurrentBuilding() || walkablePointsData?.currentBuilding;
				if (building) {
					debugLog('üíæ Syncing saved admin data to index format...');
					
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï data source flag
					if (walkablePointsData) {
						walkablePointsData.dataSource = 'admin';
						walkablePointsData.syncTime = new Date().toISOString();
					}
					
					// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏° flag
					const storageKey = `walkableData_${building}`;
					localStorage.setItem(storageKey, JSON.stringify(walkablePointsData));
					
					debugLog('‚úÖ Admin data saved with sync metadata');
				}
			}
		}

		// ========== 7. UI Integration Helpers ==========

		// ‡πÄ‡∏û‡∏¥‡πà‡∏° sync status indicator ‡πÉ‡∏ô admin
		function addSyncStatusIndicator() {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) return;
			
			const header = document.querySelector('.walkable-header');
			if (!header || document.getElementById('syncStatus')) return;
			
			const syncStatus = document.createElement('div');
			syncStatus.id = 'syncStatus';
			syncStatus.className = 'sync-status';
			syncStatus.innerHTML = `
				<div class="sync-indicator">
					<i class="fas fa-sync"></i>
					<span>Sync Ready</span>
				</div>
			`;
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS
			const style = document.createElement('style');
			style.textContent = `
				.sync-status {
					display: flex;
					align-items: center;
					gap: 8px;
					font-size: 12px;
					color: var(--text-secondary);
				}
				
				.sync-indicator {
					display: flex;
					align-items: center;
					gap: 4px;
					padding: 4px 8px;
					background: #f0f9ff;
					border: 1px solid #bae6fd;
					border-radius: 4px;
				}
				
				.sync-indicator.syncing {
					background: #fef3c7;
					border-color: #fcd34d;
				}
				
				.sync-indicator.synced {
					background: #dcfce7;
					border-color: #86efac;
				}
				
				.sync-indicator i {
					font-size: 10px;
				}
				
				.sync-indicator.syncing i {
					animation: spin 1s linear infinite;
				}
				
				@keyframes spin {
					from { transform: rotate(0deg); }
					to { transform: rotate(360deg); }
				}
			`;
			document.head.appendChild(style);
			
			header.appendChild(syncStatus);
		}

		// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï sync status
		function updateSyncStatus(status, message) {
			const indicator = document.querySelector('.sync-indicator');
			if (!indicator) return;
			
			indicator.className = `sync-indicator ${status}`;
			
			const statusMessages = {
				ready: 'üîÑ ‡∏û‡∏£‡πâ‡∏≠‡∏° sync',
				syncing: '‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á sync...',
				synced: '‚úÖ Sync ‡πÅ‡∏•‡πâ‡∏ß',
				error: '‚ùå Sync ‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î'
			};
			
			indicator.querySelector('span').textContent = message || statusMessages[status] || status;
		}

		// ========== 8. Debug and Monitoring ==========

		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ compatibility
		function debugCompatibilityStatus() {
			console.group('üîç Admin-Index Compatibility Status');
			
			console.log('Environment:', {
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode(),
				syncEnabled: ADMIN_INDEX_BRIDGE.syncEnabled
			});
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö global objects
			const adminDataExists = typeof walkablePointsData !== 'undefined';
			const indexDataExists = typeof walkableRoutingData !== 'undefined';
			
			console.log('Global Objects:', {
				walkablePointsData: adminDataExists ? 'EXISTS' : 'NOT FOUND',
				walkableRoutingData: indexDataExists ? 'EXISTS' : 'NOT FOUND'
			});
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô localStorage
			const building = getCurrentBuilding();
			if (building) {
				const adminKey = `walkableData_${building}`;
				const indexKey = `walkableData_${building}_index`;
				
				const adminData = localStorage.getItem(adminKey);
				const indexData = localStorage.getItem(indexKey);
				
				console.log('LocalStorage Data:', {
					adminData: adminData ? 'EXISTS' : 'NOT FOUND',
					indexData: indexData ? 'EXISTS' : 'NOT FOUND',
					lastSync: ADMIN_INDEX_BRIDGE.lastSyncTime
				});
				
				if (adminData) {
					try {
						const parsed = JSON.parse(adminData);
						console.log('Admin Data Summary:', {
							nodes: Object.keys(parsed.nodes || {}).length,
							edges: (parsed.edges || []).length,
							source: parsed.dataSource,
							building: parsed.building || parsed.currentBuilding
						});
					} catch (e) {
						console.warn('‚ö†Ô∏è Admin data parsing error:', e);
					}
				}
			}
			
			console.log('Sync Status:', ADMIN_INDEX_BRIDGE);
			console.groupEnd();
		}

		// ========== 9. Auto-Initialize Integration ==========

		// Initialize integration bridge
		function initializeAdminIndexBridge() {
			debugLog('üåâ Initializing Admin-Index Integration Bridge...');
			
			try {
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö environment
				const isAdmin = ADMIN_INDEX_BRIDGE.isAdminMode();
				const isIndex = ADMIN_INDEX_BRIDGE.isIndexMode();
				
				debugLog('Environment detection:', { isAdmin, isIndex });
				
				if (isAdmin) {
					// Admin mode setup
					addSyncStatusIndicator();
					updateSyncStatus('ready');
					
					// Hook into save function
					if (typeof window.saveWalkableData === 'function') {
						const originalSave = window.saveWalkableData;
						window.saveWalkableData = function() {
							updateSyncStatus('syncing');
							const result = originalSave.apply(this, arguments);
							enhancedSaveWalkableData();
							updateSyncStatus('synced');
							return result;
						};
					}
					
				} else if (isIndex) {
					// Index mode setup
					autoSyncOnPageLoad();
					
					// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadWalkableData
					if (typeof window.loadWalkableData === 'function') {
						window.originalLoadWalkableData = window.loadWalkableData;
						window.loadWalkableData = loadWalkableDataWithAdminSync;
					}
				}
				
				debugLog('‚úÖ Admin-Index Integration Bridge initialized');
				
			} catch (error) {
				debugLog('‚ùå Error initializing bridge:', error);
			}
		}

		// Auto-initialize based on page type
		document.addEventListener('DOMContentLoaded', function() {
			setTimeout(() => {
				initializeAdminIndexBridge();
				
				// Debug compatibility after initialization
				setTimeout(() => {
					debugCompatibilityStatus();
				}, 2000);
				
			}, 1000);
		});

		// Export bridge functions
		window.adminIndexBridge = {
			sync: {
				adminToIndex: syncAdminDataToIndex,
				indexToAdmin: syncIndexDataToAdmin,
				auto: autoSyncOnPageLoad
			},
			convert: {
				adminToIndex: convertAdminToIndexFormat,
				indexToAdmin: convertIndexToAdminFormat
			},
			debug: debugCompatibilityStatus,
			config: ADMIN_INDEX_BRIDGE
		};
	//******************* End Admin-index Integration bridge *********************
	
	</script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
		 
			<!-- ‡∏¢‡πâ‡∏≤‡∏¢ Version Indicator ‡πÑ‡∏õ‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô -->
			<span id="globalVersionIndicator" class="status-indicator status-connected" 
				  style="position: absolute; top: 2px; right: 10px; z-index: 200; font-size: 8px; padding: 1px 6px;">
			</span>
			
			<div class="header-top">
				<img class="school-logo" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%23667eea'/%3E%3Ctext x='50' y='60' text-anchor='middle' font-family='Arial' font-size='40' fill='white'%3Eüè´%3C/text%3E%3C/svg%3E" alt="School Logo">
				
				<div class="header-title">
					<h1 id="systemTitle">üè´ ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞</h1>
					<p id="systemSubtitle">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</p>
				</div>
				
				<button class="header-btn language-btn" onclick="toggleLanguage()">
					<i class="fas fa-globe"></i>
					<span id="languageText">TH</span>
				</button>
			</div>
		

        <!-- ======================== Search Page ======================== -->
        <div class="page active" id="search-page">
            <div class="search-container">
                <h2><i class="fas fa-search"></i> <span data-translate="search_title">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà</span></h2>
                
                <div class="search-box">
                    <input class="search-input" id="searchInput" 
                           onkeypress="handleSearchKeyPress(event)" 
                           oninput="liveSearch()" 
                           placeholder="üîç ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏´‡πâ‡∏≠‡∏á ‡∏£‡∏´‡∏±‡∏™ ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á..." 
                           data-placeholder-th="üîç ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏´‡πâ‡∏≠‡∏á ‡∏£‡∏´‡∏±‡∏™ ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á..."
                           data-placeholder-en="üîç Search room, code, or location..."
                           type="text">
                    <button class="search-btn" onclick="searchRoom()">
                        <i class="fas fa-search"></i> <span data-translate="search_btn">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</span>
                    </button>
                </div>
                
                <div class="live-results" id="liveResults"></div>
            </div>

            <div class="quick-categories">
                <div class="category-card" onclick="quickSearch('classroom')">
                    <i class="fas fa-graduation-cap"></i>
                    <h4 data-translate="category_classroom">‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô</h4>
                    <p data-translate="category_classroom_desc">‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</p>
                </div>
                <div class="category-card" onclick="quickSearch('special')">
                    <i class="fas fa-flask"></i>
                    <h4 data-translate="category_special">‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©</h4>
                    <p data-translate="category_special_desc">‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£</p>
                </div>
                <div class="category-card" onclick="quickSearch('facilities')">
                    <i class="fas fa-building"></i>
                    <h4 data-translate="category_facilities">‡∏™‡∏¥‡πà‡∏á‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å</h4>
                    <p data-translate="category_facilities_desc">‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏∏‡∏î ‡πÇ‡∏£‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£</p>
                </div>
                <div class="category-card" onclick="quickSearch('office')">
                    <i class="fas fa-briefcase"></i>
                    <h4 data-translate="category_office">‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô</h4>
                    <p data-translate="category_office_desc">‡∏´‡πâ‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£</p>
                </div>
            </div>
        </div>

        <!-- ======================== Map Page ======================== -->
        <div class="page" id="map-page">
            <!--
			<h2><i class="fas fa-map"></i> <span data-translate="map_title">‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô</span></h2>
            -->
			  <!-- ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö Toggle  
			<div id="usageGuideContainer" style="background: linear-gradient(135deg, #f8f9ff, #e6f3ff); border-radius: var(--border-radius); margin-bottom: 20px; overflow: hidden; border: 2px solid var(--border-color);">
			 
				
				<div style="padding: 15px; text-align: center; cursor: pointer; background: rgba(102, 126, 234, 0.1);" onclick="toggleUsageGuide()">
					<i class="fas fa-question-circle" style="color: var(--primary-color); margin-right: 8px;"></i>
					<span style="color: var(--primary-color); font-weight: 600; font-size: 14px;" id="usageGuideToggleText">
						<span data-translate="show_usage_guide">‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>
					</span>
					<i class="fas fa-chevron-down" id="usageGuideChevron" style="color: var(--primary-color); margin-left: 8px; transition: transform 0.3s ease;"></i>
				</div>
				
				 
				<div id="usageGuideContent" style="display: none; padding: 20px; border-top: 1px solid var(--border-color);">
					<h4 style="color: var(--primary-color); margin-bottom: 15px; text-align: center;">
						<i class="fas fa-info-circle"></i> <span data-translate="usage_guide_title">‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</span>
					</h4>
					<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
						<div style="background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px; border-left: 4px solid var(--primary-color);">
							<div style="color: var(--primary-color); font-weight: 600; margin-bottom: 8px;">
								<i class="fas fa-search"></i> <span data-translate="step1">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á</span>
							</div>
							<p style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; margin: 0;">
								<span data-translate="step1_desc">‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏î‡πà‡∏ß‡∏ô</span>
							</p>
						</div>
						<div style="background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px; border-left: 4px solid var(--accent-color);">
							<div style="color: var(--accent-color); font-weight: 600; margin-bottom: 8px;">
								<i class="fas fa-map-marker-alt"></i> <span data-translate="step2">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</span>
							</div>
							<p style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; margin: 0;">
								<span data-translate="step2_desc">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡∏π‡πà</span>
							</p>
						</div>
						<div style="background: rgba(255,255,255,0.7); padding: 15px; border-radius: 8px; border-left: 4px solid var(--warning-color);">
							<div style="color: #856404; font-weight: 600; margin-bottom: 8px;">
								<i class="fas fa-route"></i> <span data-translate="step3">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á</span>
							</div>
							<p style="color: var(--text-secondary); font-size: 13px; line-height: 1.5; margin: 0;">
								<span data-translate="step3_desc">‡∏Ñ‡∏•‡∏¥‡∏Å "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö step by step</span>
							</p>
						</div>
					</div>
				</div>
			</div>
			-->	
            <!-- 1.1: Map controls with toggle -->
            <!-- ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏™‡πà‡∏ß‡∏ô map-controls ‡πÉ‡∏ô index.html
			<div class="map-controls" id="mapControls">
				<button class="map-control-btn toggle-btn" onclick="toggleMapControls()" id="toggleControlsBtn">
					<i class="fas fa-eye-slash"></i> <span data-translate="hide_controls">‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°</span>
				</button>
				<button class="map-control-btn" onclick="setMapLayout('floorplan')" id="floorplanBtn" data-layout="floorplan">
					<i class="fas fa-th-large"></i> <span data-translate="floorplan">‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á</span>
				</button>
				
				<button class="map-control-btn" onclick="setMapLayout('photo')" id="photoBtn" data-layout="photo">
					<i class="fas fa-camera"></i> <span data-translate="real_photo">‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á</span>
				</button>
				<button class="map-control-btn" onclick="toggleFullscreen()" id="fullscreenBtn">
					<i class="fas fa-expand"></i> <span data-translate="fullscreen">‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠</span>
				</button>
			</div>
			 -->
            
            <div class="map-container">
                <div class="map-area" id="mapArea">
                    <img id="mapImage" class="map-image" 
                         src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='600' viewBox='0 0 800 600'%3E%3Crect width='800' height='600' fill='%23f0f8ff'/%3E%3Ctext x='400' y='280' text-anchor='middle' font-family='Arial' font-size='28' fill='%23667eea' font-weight='bold'%3Eüè´ ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞%3C/text%3E%3Ctext x='400' y='320' text-anchor='middle' font-family='Arial' font-size='16' fill='%23999'%3E(‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô)%3C/text%3E%3Ctext x='400' y='350' text-anchor='middle' font-family='Arial' font-size='14' fill='%23667eea'%3Eüìç ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á%3C/text%3E%3C/svg%3E" 
                         alt="‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô">
                    
                    <!-- Route Path SVG -->
                    <svg class="route-path" id="routePath" style="display: none;">
                        <!-- Path elements will be created by JavaScript -->
                    </svg>
                    
                    <!-- 1.2: Room action selection overlay -->
                    <div class="room-action-overlay" id="roomActionOverlay">
                        <div class="room-action-header" id="roomActionHeader">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£</div>
                        <button class="room-action-btn" onclick="showRoomDetails()">
                            <i class="fas fa-info-circle"></i>
                            <span data-translate="view_details">‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡πâ‡∏≠‡∏á</span>
                        </button>
                        <button class="room-action-btn" onclick="showRouteDirectly()">
                            <i class="fas fa-route"></i>
                            <span data-translate="show_route_direct">‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á</span>
                        </button>
                    </div>
                    
                    <div id="roomMarkers"></div>
                </div>
				<button class="show-controls-btn" id="showControlsBtn" onclick="showAllControls()">
				<i class="fas fa-eye"></i> <span data-translate="show_controls">‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°</span>
			</button>
            </div>
            
            <!-- Route Controls moved outside map -->
            <div class="route-controls">
			<div id="destinationStatus" style="
				position: fixed; 
				top: 80px; 
				right: 20px; 
				background: rgba(102, 126, 234, 0.95); 
				color: white; 
				padding: 10px 15px; 
				border-radius: 20px; 
				font-size: 14px; 
				display: none;
				z-index: 1000;
				box-shadow: 0 4px 12px rgba(0,0,0,0.15);
			">
				<i class="fas fa-map-marker-alt"></i> 
				<span id="destinationText">-</span>
				<button onclick="clearDestination(); updateDestinationDisplay();" style="
					background: none; 
					border: none; 
					color: white; 
					margin-left: 8px; 
					cursor: pointer;
					opacity: 0.8;
				">
					<i class="fas fa-times"></i>
				</button>
			</div>
                <button class="route-control-btn" onclick="showRouteToSelected()" id="showRouteBtn" disabled>
                    <i class="fas fa-route"></i> <span data-translate="show_route">‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á</span>
                </button>
                <button class="route-control-btn clear-route-btn" onclick="clearRoute()" id="clearRouteBtn" style="display: none;">
                    <i class="fas fa-times"></i> <span data-translate="clear_route">‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á</span>
                </button>
                <button class="route-control-btn voice-btn" onclick="startContinuousVoiceNavigation()" id="voiceNavigationBtn" style="display: none;">
                    <i class="fas fa-volume-up"></i> <span data-translate="voice_nav">‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
                </button>
            </div>
        </div>

        <!-- ======================== About Page ======================== -->
        <div class="page" id="about-page">
			<!-- Header Section -->
			<div style="text-align: center; margin-bottom: 30px;">
				<div style="font-size: 64px; margin-bottom: 20px;">üè´</div>
				<h1 style="color: var(--primary-color); margin-bottom: 10px; font-size: 2em;">
					<span data-translate="system_name">‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞ V1.2</span>
				</h1>
				<p style="color: var(--text-secondary); font-size: 1.1em; max-width: 600px; margin: 0 auto; line-height: 1.6;">
					<span data-translate="system_desc">‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏±‡∏ô‡∏™‡∏°‡∏±‡∏¢ ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</span>
				</p>
			</div>

			<!-- Features Grid -->
			<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;">
				<!-- Feature 1 -->
				<div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: var(--border-radius); text-align: center; box-shadow: var(--box-shadow);">
					<div style="font-size: 48px; margin-bottom: 15px;">üéØ</div>
					<h3 style="margin-bottom: 10px; font-size: 1.2em;" data-translate="feature1_title">‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥</h3>
					<p style="opacity: 0.9; font-size: 0.9em; line-height: 1.5;" data-translate="feature1_desc">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</p>
				</div>

				<!-- Feature 2 -->
				<div style="background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 25px; border-radius: var(--border-radius); text-align: center; box-shadow: var(--box-shadow);">
					<div style="font-size: 48px; margin-bottom: 15px;">üîä</div>
					<h3 style="margin-bottom: 10px; font-size: 1.2em;" data-translate="feature2_title">‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á</h3>
					<p style="opacity: 0.9; font-size: 0.9em; line-height: 1.5;" data-translate="feature2_desc">‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©</p>
				</div>

				<!-- Feature 3 -->
				<div style="background: linear-gradient(135deg, #17a2b8, #6f42c1); color: white; padding: 25px; border-radius: var(--border-radius); text-align: center; box-shadow: var(--box-shadow);">
					<div style="font-size: 48px; margin-bottom: 15px;">üì±</div>
					<h3 style="margin-bottom: 10px; font-size: 1.2em;" data-translate="feature3_title">Mobile First</h3>
					<p style="opacity: 0.9; font-size: 0.9em; line-height: 1.5;" data-translate="feature3_desc">‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ UI ‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏ó‡∏±‡∏ô‡∏™‡∏°‡∏±‡∏¢</p>
				</div>
			</div>

			<!-- New Features Section -->
			<div style="background: linear-gradient(135deg, #f8f9ff, #e6f3ff); padding: 30px; border-radius: var(--border-radius); margin-bottom: 25px; border: 2px solid var(--border-color);">
				<h2 style="text-align: center; color: var(--primary-color); margin-bottom: 25px; font-size: 1.5em;">
					<i class="fas fa-sparkles"></i> <span data-translate="whats_new">‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô 1.3</span>
				</h2>
				
				<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
					<div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 12px; border-left: 4px solid var(--primary-color);">
						<div style="display: flex; align-items: center; margin-bottom: 10px;">
							<div style="background: var(--primary-color); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 14px;">üéØ</div>
							<h4 style="color: var(--primary-color); margin: 0;" data-translate="new1_title">‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏ö‡∏ö Custom</h4>
						</div>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; margin: 0;" data-translate="new1_desc">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£</p>
					</div>

					<div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 12px; border-left: 4px solid var(--accent-color);">
						<div style="display: flex; align-items: center; margin-bottom: 10px;">
							<div style="background: var(--accent-color); color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 14px;">üõ£Ô∏è</div>
							<h4 style="color: var(--accent-color); margin: 0;" data-translate="new2_title">‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</h4>
						</div>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; margin: 0;" data-translate="new2_desc">‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏à‡∏∏‡∏î‡∏ï‡πà‡∏≠‡∏à‡∏∏‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô</p>
					</div>

					<div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 12px; border-left: 4px solid var(--warning-color);">
						<div style="display: flex; align-items: center; margin-bottom: 10px;">
							<div style="background: var(--warning-color); color: black; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 14px;">‚ö°</div>
							<h4 style="color: #856404; margin: 0;" data-translate="new3_title">‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á</h4>
						</div>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; margin: 0;" data-translate="new3_desc">‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô ‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å</p>
					</div>
				</div>
			</div>

			<!-- How to Use Section -->
			<div style="background: var(--card-background); padding: 30px; border-radius: var(--border-radius); margin-bottom: 25px; box-shadow: var(--box-shadow);">
				<h2 style="text-align: center; color: var(--primary-color); margin-bottom: 25px; font-size: 1.5em;">
					<i class="fas fa-question-circle"></i> <span data-translate="how_to_use">‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>
				</h2>
				
				<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px;">
					<!-- Step 1 -->
					<div style="text-align: center;">
						<div style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 24px; font-weight: bold;">1</div>
						<h4 style="color: var(--primary-color); margin-bottom: 10px;" data-translate="step1_title">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á</h4>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6;" data-translate="step1_desc">‡πÉ‡∏ä‡πâ‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏î‡πà‡∏ß‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£</p>
					</div>

					<!-- Step 2 -->
					<div style="text-align: center;">
						<div style="background: linear-gradient(135deg, var(--accent-color), #20c997); color: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 24px; font-weight: bold;">2</div>
						<h4 style="color: var(--accent-color); margin-bottom: 10px;" data-translate="step2_title">‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</h4>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6;" data-translate="step2_desc">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á</p>
					</div>

					<!-- Step 3 -->
					<div style="text-align: center;">
						<div style="background: linear-gradient(135deg, var(--info-color), #6f42c1); color: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 24px; font-weight: bold;">3</div>
						<h4 style="color: var(--info-color); margin-bottom: 10px;" data-translate="step3_title">‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á</h4>
						<p style="color: var(--text-secondary); font-size: 0.9em; line-height: 1.6;" data-translate="step3_desc">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÑ‡∏õ ‡∏Ñ‡∏•‡∏¥‡∏Å "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</p>
					</div>
				</div>
			</div>

			<!-- Technical Info -->
			<div style="background: linear-gradient(135deg, #e8f5e8, #d4edda); padding: 25px; border-radius: var(--border-radius); border: 2px solid var(--accent-color);">
				<h3 style="text-align: center; color: var(--accent-color); margin-bottom: 20px;">
					<i class="fas fa-cog"></i> <span data-translate="tech_info">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ</span>
				</h3>
				
				<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">üåê</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="web_tech">‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡πÄ‡∏ß‡πá‡∏ö</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">HTML5, CSS3, JavaScript</div>
					</div>
					
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">üìä</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="data_source">‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">Google Sheets Integration</div>
					</div>
					
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">üîä</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="voice_tech">‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡πÄ‡∏™‡∏µ‡∏¢‡∏á</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">Web Speech API</div>
					</div>
					
					<div style="text-align: center; padding: 15px;">
						<div style="color: var(--accent-color); font-size: 32px; margin-bottom: 8px;">üì±</div>
						<div style="font-weight: 600; color: var(--text-primary); font-size: 0.9em;" data-translate="responsive">Responsive Design</div>
						<div style="color: var(--text-secondary); font-size: 0.8em;">Mobile First Approach</div>
					</div>
				</div>
			</div>
		</div>
    </div>

    <!-- Admin Link (Hidden) - Removed from bottom left -->

    <!-- Bottom Navigation -->
    <div class="bottom-navigation">
        <div class="nav-item active" onclick="showPage('search')">
            <i class="fas fa-search"></i>
            <span data-translate="nav_search">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</span>
        </div>
        <div class="nav-item" onclick="showPage('map')">
            <i class="fas fa-map"></i>
            <span data-translate="nav_map">‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</span>
        </div>
        <div class="nav-item" onclick="showPage('about')">
            <i class="fas fa-info-circle"></i>
            <span data-translate="nav_about">‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö</span>
        </div>
        <!-- 1.3: Admin button moved to bottom navigation -->
        <div class="nav-item" onclick="openAdminInterface()" title="Admin Panel">
            <i class="fas fa-cog"></i>
            <span data-translate="nav_admin">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£</span>
        </div>
		  <div class="nav-item" onclick="openSystemPresentation()" title="‡∏û‡∏£‡∏µ‡πÄ‡∏ã‡πâ‡∏ô‡∏ó‡πå‡∏£‡∏∞‡∏ö‡∏ö">
            <i class="fas fa-exclamation-triangle"></i>
            <span data-translate="nav_Present">‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏£‡∏∞‡∏ö‡∏ö</span>
        </div>
		
    </div>

    <!-- Room Info Overlay -->
    <div class="room-info-overlay" id="roomInfoOverlay">
        <div class="room-info-content">
            <div class="room-info-header">
                <div class="room-title" id="overlayRoomName"></div>
               <!-- <div style="font-size: 16px; opacity: 0.9;" id="overlayRoomLocation"></div> -->
                <button class="room-info-close" onclick="closeRoomInfoOverlay()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="room-info-body">
                <!-- 1.3: Remove status info, enhanced room information display -->
                <div class="compact-info">
                    <div class="info-item">
                        <div class="info-label" data-translate="info_building">üè¢ ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£</div>
                        <div class="info-value" id="overlayRoomBuilding"></div>
                    </div>
                    <div class="info-item">
                        <div class="info-label" data-translate="info_floor">üìç ‡∏ä‡∏±‡πâ‡∏ô</div>
                        <div class="info-value" id="overlayRoomFloor"></div>
                    </div>
                    <div class="info-item">
						<div class="info-label" data-translate="info_type">üè∑Ô∏è ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏´‡πâ‡∏≠‡∏á</div>
                        <div class="info-value" id="overlayRoomType"></div>
                    </div>
                </div>
 
                
                <div style="background: rgba(255,255,255,0.7); padding: 20px; border-radius: var(--border-radius); margin-bottom: 20px;">
                    <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 8px;" data-translate="info_description">‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î</div>
                    <div style="font-size: 16px;" id="overlayRoomDescription"></div>
                </div>
                
                <div id="overlayRoomGallery" style="display: none;">
                    <h4 style="font-size: 16px; color: var(--primary-color); margin-bottom: 15px;">
                        <i class="fas fa-images"></i> <span data-translate="room_images">‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡πâ‡∏≠‡∏á</span>
                    </h4>
                    <div id="overlayImageGallery" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;"></div>
                </div>
                
                <div class="navigation-controls">
                    <button class="nav-control-btn" onclick="generateCompleteRoute()" id="routeBtn">
                        <i class="fas fa-route"></i> <span data-translate="route_navigation">‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ô‡∏≥‡∏ó‡∏≤‡∏á</span>
                    </button>
                    <button class="nav-control-btn voice-btn" onclick="toggleVoiceNavigation()" id="overlayVoiceBtn">
                        <i class="fas fa-volume-up"></i> <span data-translate="voice">‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
                    </button>
                </div>
                
                <div id="overlayRouteSteps"></div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>
	
	<!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h3 style="color: var(--primary-color); margin-bottom: 10px;" id="loadingTitle">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</h3>
            <p style="color: var(--text-secondary);" id="loadingMessage">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...</p>
        </div>
    </div>

    <script>
        // =================== Global Variables ===================
       // ======= Enhanced Global Variables =======
		let roomData = {};
		let selectedRoom = null;
		let startPoint = null;
		let voiceNavigationEnabled = false;
		let currentSpeech = null;
		let currentLanguage = 'th';
		let currentMapLayout = 'floorplan';
		let isFullscreen = false;
		let currentVersion = 'live'; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å 'demo' ‡πÄ‡∏õ‡πá‡∏ô 'live'
		let buildingsData = {};

		// Enhanced variables
		let systemConfig = {
			version: 'demo',
			maintenance_mode: false,
			maintenance_message: '‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏ã‡∏ï‡πå‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á'
		};
		let isMaintenanceMode = false;

		// Route persistence variables
		let currentRoute = null;
		let routeDisplayed = false;

		// Voice navigation queue
		let voiceQueue = [];
		let isVoiceNavigating = false;
		let voiceTimeout = null;

		// Sheets configuration (same as admin)
		 
		let sheetsConfig = {
			url: 'https://script.google.com/macros/s/AKfycbzpCFGZ_7kvyvAqiQGw3y_t6ROwUhh8Csp-I3xOPZZhP_XJ9Yyfyjsrl88s5qg3xx56/exec',
			buildingsSheet: 'Buildings',
			roomsSheet: 'Rooms',
			mapImagesSheet: 'MapImages',
			systemConfigSheet: 'SystemConfig',
			connected: false
		};
	
		// ======= ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		let mapData = {
			floorplan: null,
			realphoto: null,
			notes: '',
			loaded: false
		};

		 let persistentDestination = {
			roomCode: null,
			roomName: null,
			timestamp: null
		};
		
		
		// ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Cache System
		let CACHE_CONFIG = {
				buildings: {
					maxAge: 60 * 60 * 1000,  // 30 ‡∏ô‡∏≤‡∏ó‡∏µ
					priority: 'high',
					retryInterval: 50 * 60 * 1000  // ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
				},
				rooms: {
					maxAge: 60 * 60 * 1000,  // 60 ‡∏ô‡∏≤‡∏ó‡∏µ  
					priority: 'high',
					retryInterval: 30 * 60 * 1000  // ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å 3 ‡∏ô‡∏≤‡∏ó‡∏µ
				},
				mapImages: {
					maxAge: 5 * 60 * 60 * 1000, // 5 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
					priority: 'low',
					retryInterval: 30 * 60 * 1000  // ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å 30 ‡∏ô‡∏≤‡∏ó‡∏µ
				},
				batch: {
					maxAge: 10 * 60 * 1000,  // 10 ‡∏ô‡∏≤‡∏ó‡∏µ
					priority: 'highest'
				}
		};
		
		let IMAGE_STORAGE_CONFIG = {
			provider: 'github',
			
			github: {
				username: 'benzbil',        // üî• ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô GitHub username ‡∏à‡∏£‡∏¥‡∏á
				repo: 'school-map-images',               
				token: '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', // üî• ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Personal Access Token ‡∏à‡∏£‡∏¥‡∏á
				branch: 'main',                          
				folder: 'room-images',                   
				baseUrl: 'https://raw.githubusercontent.com'
			} 
		};
		
		// ===== üåê Universal Code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á Local PC ‡πÅ‡∏•‡∏∞ Web Server =====
		//  ‚úÖ Environment Detection System
		const Environment = {
			isLocalPC: false,
			isWebServer: false,
			
			init() {
				try {
					// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å protocol ‡πÅ‡∏•‡∏∞ hostname
					const protocol = window.location.protocol;
					const hostname = window.location.hostname;
					
					this.isLocalPC = protocol === 'file:' || 
								   hostname === 'localhost' || 
								   hostname === '127.0.0.1' ||
								   hostname.startsWith('192.168.') ||
								   hostname.includes('.local');
								   
					this.isWebServer = !this.isLocalPC;
					
					console.log(`üåê Environment: ${this.getType()}`);
				} catch (error) {
					console.warn('Environment detection error:', error);
					// Fallback ‡πÄ‡∏õ‡πá‡∏ô web server
					this.isLocalPC = false;
					this.isWebServer = true;
				}
			},
			
			getType() {
				return this.isLocalPC ? 'Local PC' : 'Web Server';
			}
		};

		
		// 2. ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏π‡∏õ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ index
		function displayRoomImages(room) {
			if (!room.images || room.images.length === 0) {
				return '<p style="color: #666; text-align: center; padding: 20px;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û</p>';
			}
			
			return room.images.map((imageData, index) => {
				const imageUrl = typeof imageData === 'string' ? imageData : imageData.url;
				const provider = typeof imageData === 'string' ? 'unknown' : imageData.provider;
				const fileName = typeof imageData === 'string' ? `image-${index + 1}` : (imageData.fileName || `image-${index + 1}`);
				
				return `
					<div style="position: relative; display: inline-block; margin: 5px;">
						<div style="position: absolute; top: 5px; right: 5px; background: rgba(40, 167, 69, 0.9); color: white; border-radius: 4px; padding: 2px 6px; font-size: 10px; z-index: 2;" title="GitHub Storage">
							üêô
						</div>
						<img src="${imageUrl}" 
							 alt="${fileName}" 
							 style="width: 150px; height: 100px; object-fit: cover; border-radius: 8px; cursor: pointer; border: 2px solid #ddd;"
							 onclick="showImageModal('${imageUrl}', '${fileName}', 'github')"
							 onerror="this.style.opacity='0.5'; this.alt='‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡∏û‡∏ö';">
					</div>
				`;
			}).join('');
		}

		// 3. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô showImageModal ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index.html
		function showImageModal(imageUrl, fileName = '', provider = '') {
			const modal = document.createElement('div');
			modal.innerHTML = `
				<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 10000;">
					<div style="position: relative; max-width: 90%; max-height: 90%; background: white; border-radius: 8px; padding: 20px;">
						<div style="text-align: center; margin-bottom: 15px;">
							<h5 style="margin: 0; color: #333;">üêô ${fileName}</h5>
							<small style="color: #666;">‡∏à‡∏≤‡∏Å GitHub Image Storage</small>
						</div>
						<img src="${imageUrl}" style="max-width: 100%; max-height: 70vh; object-fit: contain; border-radius: 4px;">
						<div style="text-align: center; margin-top: 15px;">
							<button onclick="window.open('${imageUrl}', '_blank')" 
									style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">
								‡∏î‡∏π‡∏£‡∏π‡∏õ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
							</button>
							<button onclick="this.closest('div').remove()" 
									style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
								‡∏õ‡∏¥‡∏î
							</button>
						</div>
						<button onclick="this.closest('div').remove()" 
								style="position: absolute; top: 10px; right: 15px; background: transparent; border: none; font-size: 24px; cursor: pointer; color: #666;">√ó</button>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
			modal.addEventListener('click', (e) => {
				if (e.target === modal) modal.remove();
			});
		}

		// 4. ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏ô search results
		function updateSearchResults(results) {
			const container = document.getElementById('searchResults');
			if (!container) return;
			
			if (results.length === 0) {
				container.innerHTML = '<div class="no-results">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏≠‡∏á‡∏´‡∏≤</div>';
				return;
			}
			
			container.innerHTML = results.map(room => `
				<div class="search-result-item" onclick="selectRoom('${room.code}')">
					<div class="room-info">
						<h4>${room.name}</h4>
						<p><strong>‡∏£‡∏´‡∏±‡∏™:</strong> ${room.code}</p>
						<p><strong>‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</strong> ${room.building} ‡∏ä‡∏±‡πâ‡∏ô ${room.floor}</p>
						<p><strong>‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> ${room.type}</p>
						${room.description ? `<p><strong>‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î:</strong> ${room.description}</p>` : ''}
					</div>
					<div class="room-images">
						${displayRoomImages(room)}
					</div>
				</div>
			`).join('');
		}

		console.log('üåü GitHub Image Storage Code Added to index.html');

		// Enhanced Cache Management
		function smartCacheLoader(dataType) {
			const config = CACHE_CONFIG[dataType];
			const cacheKey = getDataCacheKey(dataType);
			const timestampKey = getDataTimestampKey(dataType);
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö cache validity
			if (isCacheValid(dataType, config.maxAge)) {
				const cachedData = getCachedData(dataType);
				if (cachedData) {
					console.log(`üíæ Using cached ${dataType} data`);
					return cachedData;
				}
			}
			
			return null;
		}

		// Background Sync with Smart Timing
		async function intelligentSync() {
			if (!sheetsConfig.connected) return;
			
			const syncQueue = [];
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á sync
			Object.keys(CACHE_CONFIG).forEach(dataType => {
				if (!isCacheValid(dataType, CACHE_CONFIG[dataType].maxAge)) {
					syncQueue.push({
						type: dataType,
						priority: CACHE_CONFIG[dataType].priority
					});
				}
			});
			
			// ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏° priority
			syncQueue.sort((a, b) => {
				const priorities = { high: 3, medium: 2, low: 1 };
				return priorities[b.priority] - priorities[a.priority];
			});
			
			// Sync ‡∏ó‡∏µ‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
			for (const item of syncQueue) {
				try {
					await syncDataType(item.type);
					await new Promise(resolve => setTimeout(resolve, 1000)); // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
				} catch (error) {
					console.error(`Failed to sync ${item.type}:`, error);
				}
			}
		}

		// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ó‡∏∏‡∏Å 10 ‡∏ô‡∏≤‡∏ó‡∏µ
		setInterval(intelligentSync, 10 * 60 * 1000);
		
		
		// ======= Loading Overlay Functions =======
		function showLoadingOverlay(title, message) {
			const overlay = document.getElementById('loadingOverlay');
			const titleEl = document.getElementById('loadingTitle');
			const messageEl = document.getElementById('loadingMessage');
			
			if (overlay) overlay.style.display = 'flex';
			if (titleEl) titleEl.textContent = title || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
			if (messageEl) messageEl.textContent = message || '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...';
		}

		function hideLoadingOverlay() {
			const overlay = document.getElementById('loadingOverlay');
			if (overlay) overlay.style.display = 'none';
		}
				
		// ======= Enhanced Version Management ‡πÅ‡∏ö‡∏ö‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏∞‡∏ó‡∏±‡∏î‡∏£‡∏±‡∏î =======
		function updateGlobalVersionIndicator(version) {
			const indicator = document.getElementById('globalVersionIndicator');
			if (!indicator) return;
			
			if (version === 'demo') {
				indicator.innerHTML = 'üéÆ';  // ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
				indicator.className = 'status-indicator status-connected';
				indicator.title = 'Demo Mode'; // ‡πÉ‡∏ä‡πâ tooltip ‡πÅ‡∏ó‡∏ô
			} else {
				// Live Mode - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Google Sheets
				if (sheetsConfig.connected) {
					indicator.innerHTML = 'üî¥';
					indicator.className = 'status-indicator status-active';
					indicator.title = 'Live Mode (Connected)';
				} else {
					indicator.innerHTML = '‚ö†Ô∏è';
					indicator.className = 'status-indicator status-error';
					indicator.title = 'Live Mode (Disconnected)';
				}
			}
		}

		// ======= Loading Overlay Functions =======
		function showLoadingOverlay(title, message) {
			const overlay = document.getElementById('loadingOverlay');
			const titleEl = document.getElementById('loadingTitle');
			const messageEl = document.getElementById('loadingMessage');
			
			if (overlay) overlay.style.display = 'flex';
			if (titleEl) titleEl.textContent = title || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
			if (messageEl) messageEl.textContent = message || '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...';
		}

		function hideLoadingOverlay() {
			const overlay = document.getElementById('loadingOverlay');
			if (overlay) overlay.style.display = 'none';
		}

		// ======= Data Caching System =======
		function getDataCacheKey(dataType) {
			return `${dataType}_cache_${currentVersion}`;
		}

		function getDataTimestampKey(dataType) {
			return `${dataType}_timestamp_${currentVersion}`;
		}

		// ======= ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Cache Management =======
		function isCacheValid(dataType, customMaxAge = null) {
			const config = CACHE_CONFIG[dataType];
			const maxAge = customMaxAge || (config ? config.maxAge : 30 * 60 * 1000);
			
			const timestamp = localStorage.getItem(getDataTimestampKey(dataType));
			if (!timestamp) return false;
			
			const cacheAge = Date.now() - parseInt(timestamp);
			
			if (!Environment.isLocalPC) {  //Benz: ‡∏Å‡∏£‡∏ì‡∏µ Local PC ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ cache
				return cacheAge < maxAge;
			}else{
				return false;  
			}
		}

		function setCachedData(dataType, data) {
			try {
				const dataString = JSON.stringify(data);
				const dataSize = new Blob([dataString]).size;
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
				if (dataSize > 5 * 1024 * 1024) { // 5MB
					console.warn(`‚ö†Ô∏è Large data size for ${dataType}: ${(dataSize / 1024 / 1024).toFixed(2)}MB`);
					
					// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà ‡πÉ‡∏´‡πâ‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î
					if (dataType === 'mapImages') {
						return compressAndCacheMapData(data);
					}
				}
				
				localStorage.setItem(getDataCacheKey(dataType), dataString);
				localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
				
				console.log(`üíæ Cached ${dataType}: ${(dataSize / 1024).toFixed(1)}KB`);
				return true;
				
			} catch (error) {
				console.error(`‚ùå Failed to cache ${dataType}:`, error);
				
				// ‡∏ñ‡πâ‡∏≤ localStorage ‡πÄ‡∏ï‡πá‡∏° ‡πÉ‡∏´‡πâ‡∏•‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤
				if (error.name === 'QuotaExceededError') {
					cleanOldCache();
					try {
						localStorage.setItem(getDataCacheKey(dataType), JSON.stringify(data));
						localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
						return true;
					} catch (retryError) {
						console.error('‚ùå Still failed after cleanup:', retryError);
					}
				}
				return false;
			}
		}

		// ======= ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Batch Loading ‡πÉ‡∏´‡∏°‡πà =======
		async function loadDataWithBatchAPI() {
			try {
				showProgressiveStatus('üì• ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö Batch...', 'info');
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö cache batch ‡∏Å‡πà‡∏≠‡∏ô
				if (isCacheValid('batch')) {
					const batchData = getCachedData('batch');
					if (batchData && batchData.buildings && batchData.rooms) {
						console.log('üíæ Using cached batch data');
						processBatchData(batchData);
						return true;
					}
				}
				
				// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡πÅ‡∏ö‡∏ö batch
				const params = new URLSearchParams();
				params.append('action', 'getBatchData');
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				
				const result = await response.json();
				
				if (result.success && result.data) {
					console.log('‚úÖ Batch data loaded successfully');
					
					// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å cache
					setCachedData('batch', result.data);
					
					// ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
					processBatchData(result.data);
					
					showProgressiveStatus('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
					return true;
				} else {
					throw new Error(result.error || 'Batch loading failed');
				}
				
			} catch (error) {
				console.error('‚ùå Batch loading failed:', error);
				showProgressiveStatus('‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß', 'error');
				
				// ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ cache ‡πÄ‡∏Å‡πà‡∏≤
				return loadFromFallbackCache();
			}
		}

		// V1.1 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô processBatchData
		function processBatchData(batchData) {
			// ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Buildings
			if (batchData.buildings && Array.isArray(batchData.buildings)) {
				const buildings = {};
				batchData.buildings.forEach(building => {
					if (building.code && building.name) {
						buildings[building.code] = {
							code: building.code,
							name: building.name,
							floors: parseInt(building.floors) || 1,
							year: parseInt(building.year) || new Date().getFullYear(),
							description: building.description || '',
							status: building.status || 'active',
							rooms: parseInt(building.rooms) || 0,
							created: building.created || '',
							updated: building.updated || ''
						};
					}
				});
				
				window.buildingsData = buildings;
				setCachedData('buildings', buildings);
				console.log(`üìã Processed ${Object.keys(buildings).length} buildings`);
			}
			
			// ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Rooms
			if (batchData.rooms && Array.isArray(batchData.rooms)) {
				const rooms = {};
				batchData.rooms.forEach(room => {
					if (room.code && room.name) {
						// üîß v1.1 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ image_urls ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
						let processedImages = [];
						if (room.image_urls) {
							if (Array.isArray(room.image_urls)) {
								processedImages = room.image_urls;
							} else if (typeof room.image_urls === 'string') {
								try {
									processedImages = JSON.parse(room.image_urls);
								} catch (e) {
									// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏•‡∏≠‡∏á‡πÅ‡∏¢‡∏Å‡∏î‡πâ‡∏ß‡∏¢ comma
									processedImages = room.image_urls.split(',').map(url => url.trim()).filter(url => url);
								}
							}
						}
						
						rooms[room.code] = {
							code: room.code,
							name: room.name,
							building: room.building,
							floor: parseInt(room.floor) || 1,
							type: room.type || 'classroom',
							description: room.description || '',
							status: room.status || 'active',
							x: parseFloat(room.x) || 0,
							y: parseFloat(room.y) || 0,
							images: processedImages, // ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà process ‡πÅ‡∏•‡πâ‡∏ß
							image_urls: processedImages, // ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠ compatibility
							created: room.created || '',
							updated: room.updated || ''
						};
					} 					
				});
				
		 
				window.roomsData = rooms;
				setCachedData('rooms', rooms);
				console.log(`üìã Processed ${Object.keys(rooms).length} rooms`);
				
				// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index.html ‡πÉ‡∏ä‡πâ roomData
				if (typeof window.roomData !== 'undefined') {
					window.roomData = rooms;
				}
				// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö admin.html ‡πÉ‡∏ä‡πâ roomsData  
				if (typeof window.roomsData !== 'undefined') {
					window.roomsData = rooms;
				}
				
				setCachedData('rooms', rooms);
				console.log(`üè† Processed ${Object.keys(rooms).length} rooms`);
			}
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ó UI
			if (typeof updateDashboardStats === 'function') {
				updateDashboardStats();
			}
			if (typeof loadBuildingsTable === 'function') {
				loadBuildingsTable();
			}
			if (typeof loadRoomsTable === 'function') {
				loadRoomsTable();
			}
		}

		function loadFromFallbackCache() {
			console.log('üîÑ Trying fallback cache...');
			
			let hasData = false;
			
			// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î buildings ‡∏à‡∏≤‡∏Å cache
			if (isCacheValid('buildings', 60 * 60 * 1000)) { // ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤ 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
				const buildings = getCachedData('buildings');
				if (buildings) {
					window.buildingsData = buildings;
					hasData = true;
					console.log('üíæ Loaded buildings from fallback cache');
				}
			}
			
			// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î rooms ‡∏à‡∏≤‡∏Å cache
			if (isCacheValid('rooms', 60 * 60 * 1000)) { // ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤ 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
				const rooms = getCachedData('rooms');
				if (rooms) {
					if (typeof window.roomData !== 'undefined') {
						window.roomData = rooms;
					}
					if (typeof window.roomsData !== 'undefined') {
						window.roomsData = rooms;
					}
					hasData = true;
					console.log('üíæ Loaded rooms from fallback cache');
				}
			}
			
			if (hasData) {
				showProgressiveStatus('üíæ ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Cache', 'warning');
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ó UI
				if (typeof updateDashboardStats === 'function') {
					updateDashboardStats();
				}
				if (typeof loadBuildingsTable === 'function') {
					loadBuildingsTable();
				}
				if (typeof loadRoomsTable === 'function') {
					loadRoomsTable();
				}
				
				return true;
			}
			
			return false;
		}

		// ======= ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Auto Code Generation =======
		function generateBuildingCode() {
			const existingCodes = Object.keys(buildingsData || {});
			const codeNumbers = existingCodes
				.filter(code => /^B\d+$/.test(code))
				.map(code => parseInt(code.substring(1)))
				.filter(num => !isNaN(num));
			
			const nextNumber = codeNumbers.length > 0 ? Math.max(...codeNumbers) + 1 : 1;
			return `B${nextNumber.toString().padStart(3, '0')}`;
		}

		function generateRoomCode() {
			const rooms = window.roomsData || window.roomData || {};
			const existingCodes = Object.keys(rooms);
			const codeNumbers = existingCodes
				.filter(code => /^R\d+$/.test(code))
				.map(code => parseInt(code.substring(1)))
				.filter(num => !isNaN(num));
			
			const nextNumber = codeNumbers.length > 0 ? Math.max(...codeNumbers) + 1 : 1;
			return `R${nextNumber.toString().padStart(4, '0')}`;
		}

		// ======= Cache Cleanup =======
		function cleanOldCache() {
			console.log('üßπ Cleaning old cache...');
			
			const keys = Object.keys(localStorage);
			const now = Date.now();
			let cleanedCount = 0;
			
			keys.forEach(key => {
				if (key.includes('_timestamp_')) {
					const timestamp = localStorage.getItem(key);
					const dataType = key.replace('_timestamp_', '').replace('_live', '').replace('_demo', '');
					const config = CACHE_CONFIG[dataType];
					const maxAge = config ? config.maxAge * 2 : 60 * 60 * 1000; // 2x ‡∏õ‡∏Å‡∏ï‡∏¥ ‡∏´‡∏£‡∏∑‡∏≠ 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
					
					if (timestamp && (now - parseInt(timestamp)) > maxAge) {
						const cacheKey = key.replace('_timestamp_', '_cache_');
						localStorage.removeItem(key);
						localStorage.removeItem(cacheKey);
						cleanedCount++;
						console.log(`üóëÔ∏è Removed expired cache: ${dataType}`);
					}
				}
			});
			
			console.log(`üßπ Cleaned ${cleanedCount} expired cache entries`);
		}

		// ======= Background Sync =======
		async function intelligentBackgroundSync() {
			if (!sheetsConfig.connected) return;
			
			console.log('üîÑ Starting intelligent background sync...');
			
			const syncNeeded = [];
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ cache ‡πÑ‡∏´‡∏ô‡∏ï‡πâ‡∏≠‡∏á refresh
			Object.keys(CACHE_CONFIG).forEach(dataType => {
				if (!isCacheValid(dataType)) {
					syncNeeded.push({
						type: dataType,
						priority: CACHE_CONFIG[dataType].priority
					});
				}
			});
			
			if (syncNeeded.length === 0) {
				console.log('üíæ All cache is still valid');
				return;
			}
			
			// ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏° priority
			const priorities = { highest: 4, high: 3, medium: 2, low: 1 };
			syncNeeded.sort((a, b) => priorities[b.priority] - priorities[a.priority]);
			
			console.log(`üîÑ Need to sync: ${syncNeeded.map(s => s.type).join(', ')}`);
			
			// ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ buildings ‡∏´‡∏£‡∏∑‡∏≠ rooms ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ batch loading
			if (syncNeeded.some(s => s.type === 'buildings' || s.type === 'rooms')) {
				try {
					await loadDataWithBatchAPI();
					console.log('‚úÖ Background batch sync completed');
				} catch (error) {
					console.error('‚ùå Background batch sync failed:', error);
				}
			}
			
			// Sync map images ‡πÅ‡∏¢‡∏Å (‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô)
			if (syncNeeded.some(s => s.type === 'mapImages')) {
				try {
					await backgroundSyncMapImages();
					console.log('‚úÖ Background map sync completed');
				} catch (error) {
					console.error('‚ùå Background map sync failed:', error);
				}
			}
		}

		// ======= ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadDataFromSheets ‡πÄ‡∏î‡∏¥‡∏° =======
		async function loadDataFromSheets() {
			if (!sheetsConfig.connected) {
				showNotification('‚ùå ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Google Sheets', 'error');
				return false;
			}
			
			try {
				// ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ batch loading ‡∏Å‡πà‡∏≠‡∏ô
				const batchSuccess = await loadDataWithBatchAPI();
				if (batchSuccess) {
					updateLastSyncTime();
					addSyncHistoryItem('üì• ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö Batch ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
					return true;
				}
				
				// ‡∏ñ‡πâ‡∏≤ batch ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏î‡∏¥‡∏°
				return await loadDataLegacyMethod();
				
			} catch (error) {
				console.error('‚ùå All loading methods failed:', error);
				showNotification('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ', 'error');
				return false;
			}
		}

		// ======= ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Background Sync =======
		// ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å 10 ‡∏ô‡∏≤‡∏ó‡∏µ
		setInterval(intelligentBackgroundSync, 10 * 60 * 1000);

		// ‡∏ó‡∏≥ cache cleanup ‡∏ó‡∏∏‡∏Å 30 ‡∏ô‡∏≤‡∏ó‡∏µ
		setInterval(cleanOldCache, 30 * 60 * 1000);

		// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
		setTimeout(intelligentBackgroundSync, 5000); // ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ

		console.log('üöÄ Smart Cache ‡πÅ‡∏•‡∏∞ Batch Loading System ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
		console.log('üìä Cache Config:', CACHE_CONFIG);

		function getCachedData(dataType) {
			const cached = localStorage.getItem(getDataCacheKey(dataType));
			return cached ? JSON.parse(cached) : null;
		}
		
		// 1. ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô connectToGoogleSheets
		async function connectToGoogleSheets() {
			try {
				if (!sheetsConfig.url) {
					console.log('‚ö†Ô∏è No Google Sheets URL configured');
					return false;
				}
				
				console.log('üîó Attempting to connect to Google Sheets...');
				
				// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', 'Buildings');
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/x-www-form-urlencoded',
					},
					body: params.toString()
				});
				
				if (response.ok) {
					const data = await response.json();
					if (data.success !== false) {
						sheetsConfig.connected = true;
						console.log('‚úÖ Connected to Google Sheets successfully');
						showProgressiveStatus('‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Google Sheets ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
						return true;
					}
				}
				
				throw new Error(`Connection failed: ${response.status}`);
				
			} catch (error) {
				console.warn('‚ö†Ô∏è Google Sheets connection failed:', error.message);
				sheetsConfig.connected = false;
				showProgressiveStatus('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Google Sheets', 'warning');
				return false;
			}
		}		
		 

		// 4. ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadFallbackData
		async function loadFallbackData() {
			console.log('üîÑ Loading fallback data...');
			
			// ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
			roomData = {
				'R001': {
					code: 'R001',
					name: '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô 1',
					building: 'B001',
					floor: 1,
					type: 'classroom',
					description: '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á',
					status: 'active',
					x: 300,
					y: 200,
					images: []
				}
			};
			
			buildingsData = {
				'B001': {
					code: 'B001',
					name: '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô 1',
					floors: 3,
					year: 2020,
					description: '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏´‡∏•‡∏±‡∏Å',
					status: 'active',
					rooms: 1
				}
			};
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô localStorage
			setCachedData('rooms', roomData);
			setCachedData('buildings', buildingsData);
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ó UI
			updateRoomMarkers();
			updateRouteControls(false);
			
			console.log('‚úÖ Fallback data loaded');
		}	

		// 6. ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadSystemConfig
		function loadSystemConfig() {
			try {
				const savedConfig = localStorage.getItem('systemConfig');
				if (savedConfig) {
					const config = JSON.parse(savedConfig);
					
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ó UI elements
					const maintenanceCheckbox = document.getElementById('maintenanceMode');
					const maintenanceMessage = document.getElementById('maintenanceMessage');
					
					if (maintenanceCheckbox) {
						maintenanceCheckbox.checked = config.maintenance_mode === true;
					}
					
					if (maintenanceMessage) {
						maintenanceMessage.value = config.maintenance_message || '‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏ã‡∏ï‡πå‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á';
					}
					
					console.log('‚öôÔ∏è System config loaded');
				}
			} catch (error) {
				console.error('Error loading system config:', error);
			}
		}

		console.log('‚úÖ Admin.html functions restored');		
		
		async function loadSystemConfigFromSheets() {
			try {
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', sheetsConfig.systemConfigSheet);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.success && result.data && result.data.length > 0) {
						const config = result.data.find(item => item.id === 'system') || result.data[0];
						return {
							version: config.version || 'demo',
							maintenance_mode: config.maintenance_mode === 'true' || config.maintenance_mode === true,
							maintenance_message: config.maintenance_message || systemConfig.maintenance_message
						};
					}
				}
				
				return null;
				
			} catch (error) {
				console.error('Failed to load system config from sheets:', error);
				return null;
			}
		}

		// ===================  ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏ô‡πâ‡∏≤ Under Construction  =====
		function showMaintenancePage() {
			console.log('üöß Displaying maintenance page');
			document.body.innerHTML = `
				<div style="
					font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
					background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
					margin: 0;
					padding: 20px;
					display: flex;
					align-items: center;
					justify-content: center;
					min-height: 100vh;
					color: #333;
				">
					<div style="
						background: rgba(255, 255, 255, 0.95);
						backdrop-filter: blur(20px);
						padding: 50px;
						border-radius: 20px;
						text-align: center;
						max-width: 600px;
						box-shadow: 0 25px 50px rgba(0,0,0,0.3);
					">
						<div style="font-size: 80px; margin-bottom: 30px;">üöß</div>
						<h1 style="
							font-size: 2.5em;
							margin-bottom: 20px;
							background: linear-gradient(135deg, #667eea, #764ba2);
							-webkit-background-clip: text;
							-webkit-text-fill-color: transparent;
							background-clip: text;
						">Under Construction</h1>
						<p style="
							font-size: 1.2em;
							line-height: 1.6;
							color: #666;
							margin-bottom: 30px;
						">${systemConfig.maintenance_message}</p>
						<div style="
							background: rgba(102, 126, 234, 0.1);
							padding: 20px;
							border-radius: 15px;
							border-left: 4px solid #667eea;
						">
							<p style="margin: 0; font-size: 0.9em; color: #888;">
								<i class="fas fa-info-circle"></i>
								‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
							</p>
							<small style="color: #999; margin-top: 10px; display: block;">
							Version: ${currentVersion} | Mode: ${isMaintenanceMode ? 'Maintenance' : 'Normal'}
						</small>
						</div>
					</div>
				</div>
			`;
		}
        // FIX 1: Language translations
        const translations = {
            th: {
                search_title: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà",
                search_btn: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤",
                category_classroom: "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô",
                category_classroom_desc: "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
                category_special: "‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©",
                category_special_desc: "‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£",
                category_facilities: "‡∏™‡∏¥‡πà‡∏á‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å",
                category_facilities_desc: "‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏∏‡∏î ‡πÇ‡∏£‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£",
                category_office: "‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô",
                category_office_desc: "‡∏´‡πâ‡∏≠‡∏á‡∏ú‡∏π‡πâ‡∏ö‡∏£‡∏¥‡∏´‡∏≤‡∏£",
                map_title: "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô",
                filter_building: "üè¢ ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£",
                hide_controls: "‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°",
                show_controls: "‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°",
                floorplan: "‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á",
                real_photo: "‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á",
                fullscreen: "‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠",
                exit_fullscreen: "‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠",
                show_route: "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á",
                clear_route: "‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á",
                voice_nav: "‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á",
                about_title: "‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö",
                system_name: "‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞ Version1.3",
                system_desc: "‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏±‡∏ô‡∏™‡∏°‡∏±‡∏¢ ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô",
                features_title: "‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô 1.3",
                usage_title: "‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
                step1_title: "1. ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á:",
                step1_desc: "‡πÉ‡∏ä‡πâ‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏î‡πà‡∏ß‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£",
                step2_title: "2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô:",
                step2_desc: "‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á",
                step3_title: "3. ‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á:",
                step3_desc: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÑ‡∏õ ‡∏Ñ‡∏•‡∏¥‡∏Å \"‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á\" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥",
                step4_title: "4. ‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á:",
                step4_desc: "‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô",
                nav_search: "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤",
                nav_map: "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà",
                nav_about: "‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö",
                nav_admin: "‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£",
				nav_Present: "‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏£‡∏∞‡∏ö‡∏ö",
                info_building: "‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£",
                info_floor: "‡∏ä‡∏±‡πâ‡∏ô",
                info_type: "‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏´‡πâ‡∏≠‡∏á",
                info_description: "‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î",
                room_images: "‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡πâ‡∏≠‡∏á",
                route_navigation: "‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ô‡∏≥‡∏ó‡∏≤‡∏á",
                voice: "‡πÄ‡∏™‡∏µ‡∏¢‡∏á",
                view_details: "‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡πâ‡∏≠‡∏á",
                show_route_direct: "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á",
                select_action: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£",
				whats_new: "‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô 6",
				feature1_title: "‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥",
				feature1_desc: "‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô",
				feature2_title: "‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á",
				feature2_desc: "‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©",
				feature3_title: "Mobile First",
				feature3_desc: "‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ UI ‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏ó‡∏±‡∏ô‡∏™‡∏°‡∏±‡∏¢",
				new1_title: "‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏ö‡∏ö Custom",
				new1_desc: "‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£",
				new2_title: "‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô",
				new2_desc: "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏à‡∏∏‡∏î‡∏ï‡πà‡∏≠‡∏à‡∏∏‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô",
				new3_title: "‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á",
				new3_desc: "‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô ‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å",
				how_to_use: "‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
				tech_info: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ",
				web_tech: "‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡πÄ‡∏ß‡πá‡∏ö",
				data_source: "‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•",
				voice_tech: "‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡πÄ‡∏™‡∏µ‡∏¢‡∏á",
				responsive: "Responsive Design", 
				show_usage_guide: "‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
				hide_usage_guide: "‡∏ã‡πà‡∏≠‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
				usage_guide_title: "‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà",
				step1: "‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á",
				step1_desc: "‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏î‡πà‡∏ß‡∏ô",
				step2: "‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", 
				step2_desc: "‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡∏π‡πà",
				step3: "‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á",
				step3_desc: "‡∏Ñ‡∏•‡∏¥‡∏Å \"‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á\" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö step by step"			
				
            },
            en: {
                search_title: "Search Classrooms and Places",
                search_btn: "Search",
                category_classroom: "Classrooms",
                category_classroom_desc: "All regular classrooms",
                category_special: "Special Rooms",
                category_special_desc: "Laboratories",
                category_facilities: "Facilities",
                category_facilities_desc: "Library, Cafeteria",
                category_office: "Offices",
                category_office_desc: "Administrative offices",
                map_title: "School Map",
                filter_building: "üè¢ Filter by Building",
                hide_controls: "Hide Controls",
                show_controls: "Show Controls",
                floorplan: "Floor Plan",
                real_photo: "Real Photo",
                fullscreen: "Fullscreen",
                exit_fullscreen: "Exit Fullscreen",
                show_route: "Show Route",
                clear_route: "Clear Route",
                voice_nav: "Voice Navigation",
                about_title: "About System",
                system_name: "Smart School Map System Version1.3",
                system_desc: "Modern classroom search and navigation system designed primarily for mobile use with voice navigation and clear route display.",
                features_title: "New Features in version1.3",
                usage_title: "How to Use",
                step1_title: "1. Search Rooms:",
                step1_desc: "Use search box or click quick categories to find desired rooms",
                step2_title: "2. Set Starting Point:",
                step2_desc: "Click on the map to set navigation starting point",
                step3_title: "3. View Route:",
                step3_desc: "Select destination room, click \"Show Route\" to see path and directions",
                step4_title: "4. Voice Navigation:",
                step4_desc: "Enable sound to hear step-by-step navigation instructions",
                nav_search: "Search",
                nav_map: "Map",
                nav_about: "About",
                nav_admin: "Admin",
				nav_Present: "‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏£‡∏∞‡∏ö‡∏ö",
                info_building: "Building",
                info_floor: "Floor",
                info_type: "Room Type",
                info_description: "Description",
                room_images: "Room Images",
                route_navigation: "Route Navigation",
                voice: "Voice",
                view_details: "View Room Details",
                show_route_direct: "Show Route",
                select_action: "Select Action",
				whats_new: "What's New in Version 6",
				feature1_title: "Precise Navigation",
				feature1_desc: "Set starting point anywhere on the map with clear route guidance",
				feature2_title: "Voice Navigation",
				feature2_desc: "Step-by-step audio directions supporting Thai and English languages",
				feature3_title: "Mobile First",
				feature3_desc: "Designed for mobile devices with beautiful and modern UI",
				new1_title: "Custom Starting Point",
				new1_desc: "Set starting point anywhere on the map as desired",
				new2_title: "Clear Route Display",
				new2_desc: "Point-to-point route visualization with animations",
				new3_title: "High Performance",
				new3_desc: "Faster loading, lower memory usage, supports large datasets",
				how_to_use: "How to Use",
				tech_info: "Technical Information",
				web_tech: "Web Technology",
				data_source: "Data Source",
				voice_tech: "Voice Technology",
				responsive: "Responsive Design",
				show_usage_guide: "Show Usage Guide",
				hide_usage_guide: "Hide Usage Guide", 
				usage_guide_title: "Map Usage Guide",
				step1: "Step 1: Search Room",
				step1_desc: "Go to search page, select desired room or click quick categories",
				step2: "Step 2: Set Starting Point",
				step2_desc: "Click on map to set your current position",
				step3: "Step 3: View Route", 
				step3_desc: "Click \"Show Route\" to see step-by-step navigation"
            }
        };

        // =================== Sample Data ===================
        const sampleRoomData = {
            'R001': {
                code: 'R001',
                name: '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô ‡∏°.1/1',
                building: 'B001',
                location: '‡∏ä‡∏±‡πâ‡∏ô 1',
                description: '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ä‡∏±‡πâ‡∏ô‡∏°‡∏±‡∏ò‡∏¢‡∏°‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏õ‡∏µ‡∏ó‡∏µ‡πà 1',
                hours: '08:00 - 16:30',
                status: 'active',
                x: 20, y: 30,
                images: ['https://picsum.photos/400/300?random=1']
            },
            'R002': {
                code: 'R002',
                name: '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô ‡∏°.1/2',
                building: 'B001',
                location: '‡∏ä‡∏±‡πâ‡∏ô 1',
                description: '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏ä‡∏±‡πâ‡∏ô‡∏°‡∏±‡∏ò‡∏¢‡∏°‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏õ‡∏µ‡∏ó‡∏µ‡πà 1',
                hours: '08:00 - 16:30',
                status: 'active',
                x: 45, y: 30,
                images: ['https://picsum.photos/400/300?random=2']
            },
            'C001': {
                code: 'C001',
                name: '‡∏´‡πâ‡∏≠‡∏á‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå 1',
                building: 'B002',
                location: '‡∏ä‡∏±‡πâ‡∏ô 2',
                description: '‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå ‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå 30 ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
                hours: '08:00 - 17:00',
                status: 'active',
                x: 25, y: 65,
                images: ['https://picsum.photos/400/300?random=3']
            },
            'L001': {
                code: 'L001',
                name: '‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏∏‡∏î‡∏´‡∏•‡∏±‡∏Å',
                building: 'B003',
                location: '‡∏ä‡∏±‡πâ‡∏ô 1',
                description: '‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏∏‡∏î‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô ‡∏°‡∏µ‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 15,000 ‡πÄ‡∏•‡πà‡∏°',
                hours: '07:30 - 18:00',
                status: 'active',
                x: 80, y: 70,
                images: ['https://picsum.photos/400/300?random=4']
            },
            'CAFE001': {
                code: 'CAFE001',
                name: '‡πÇ‡∏£‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å',
                building: 'B004',
                location: '‡∏ä‡∏±‡πâ‡∏ô 1',
                description: '‡πÇ‡∏£‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô 500 ‡∏Ñ‡∏ô',
                hours: '06:30 - 14:00',
                status: 'active',
                x: 85, y: 40,
                images: ['https://picsum.photos/400/300?random=5']
            }
        };

        const sampleBuildingsData = {
            'B001': { code: 'B001', name: '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô 1' },
            'B002': { code: 'B002', name: '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô 2' },
            'B003': { code: 'B003', name: '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô' },
            'B004': { code: 'B004', name: '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏™‡∏¥‡πà‡∏á‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å' }
        };

        // =================== FIX 1: Language System ===================
        
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'th' ? 'en' : 'th';
            localStorage.setItem('preferredLanguage', currentLanguage);
            updateLanguageButton();
            updateAllTranslations();
            updateSearchPlaceholder();
            showNotification(
                currentLanguage === 'th' ? 'üáπüá≠ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢' : 'üá∫üá∏ Changed to English',
                'success'
            );
        }

        function updateLanguageButton() {
            const languageText = document.getElementById('languageText');
            if (languageText) {
                languageText.textContent = currentLanguage === 'th' ? 'TH' : 'EN';
            }
        }

        function updateAllTranslations() {
            const elementsToTranslate = document.querySelectorAll('[data-translate]');
            elementsToTranslate.forEach(element => {
                const key = element.getAttribute('data-translate');
                if (translations[currentLanguage] && translations[currentLanguage][key]) {
                    if (element.tagName === 'UL' && key === 'features_list') {
                        // Special handling for features list
                        if (currentLanguage === 'en') {
                            element.innerHTML = `
                                <li>üéØ Set starting point anywhere on the map</li>
                                <li>üõ£Ô∏è Clear point-to-point route display</li>
                                <li>üì± Mobile-optimized UI</li>
                                <li>üîä Detailed voice navigation system</li>
                                <li>‚ö° Better performance and lower memory usage</li>
                            `;
                        } else {
                            element.innerHTML = `
                                <li>üéØ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</li>
                                <li>üõ£Ô∏è ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏à‡∏∏‡∏î‡∏ï‡πà‡∏≠‡∏à‡∏∏‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</li>
                                <li>üì± UI ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠</li>
                                <li>üîä ‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î</li>
                                <li>‚ö° ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡πâ‡∏≠‡∏¢‡∏•‡∏á</li>
                            `;
                        }
                    } else {
                        element.textContent = translations[currentLanguage][key];
                    }
                }
            });
            
            // Update title and subtitle
            const systemTitle = document.getElementById('systemTitle');
            const systemSubtitle = document.getElementById('systemSubtitle');
            
            if (currentLanguage === 'en') {
                if (systemTitle) systemTitle.textContent = 'üè´ Smart School Map System';
                if (systemSubtitle) systemSubtitle.textContent = 'Find classrooms and navigate with voice guidance';
            } else {
                if (systemTitle) systemTitle.textContent = 'üè´ ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞';
                if (systemSubtitle) systemSubtitle.textContent = '‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á';
            }
        }

        function updateSearchPlaceholder() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                const placeholder = currentLanguage === 'th' 
                    ? searchInput.getAttribute('data-placeholder-th')
                    : searchInput.getAttribute('data-placeholder-en');
                searchInput.placeholder = placeholder;
            }
        }


		// ======= localStorage Quota Management =======
		function getStorageQuota() {
			try {
				// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö localStorage quota
				const testKey = 'storage_test_' + Date.now();
				const testData = 'x'.repeat(1024); // 1KB test
				localStorage.setItem(testKey, testData);
				localStorage.removeItem(testKey);
				return true;
			} catch (e) {
				return false;
			}
		}

		function getStorageSize() {
			let total = 0;
			for (let key in localStorage) {
				if (localStorage.hasOwnProperty(key)) {
					total += localStorage[key].length + key.length;
				}
			}
			return total;
		}

		function freeUpStorage(targetSize = 50000) { // 50KB
			const keys = Object.keys(localStorage);
			const cacheKeys = keys.filter(key => key.includes('_cache_') || key.includes('_timestamp_'));
			
			// ‡∏•‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤
			cacheKeys.sort((a, b) => {
				const timeA = localStorage.getItem(a.replace('_cache_', '_timestamp_').replace('_timestamp_', '_timestamp_'));
				const timeB = localStorage.getItem(b.replace('_cache_', '_timestamp_').replace('_timestamp_', '_timestamp_'));
				return parseInt(timeA || '0') - parseInt(timeB || '0');
			});
			
			let freed = 0;
			for (const key of cacheKeys) {
				if (freed >= targetSize) break;
				const size = localStorage[key]?.length || 0;
				localStorage.removeItem(key);
				freed += size;
				console.log(`üóëÔ∏è Removed cache: ${key} (${size} bytes)`);
			}
			
			return freed;
		}

		// ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Cache Management ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà =======
		function safeSetCachedData(dataType, data) {
			try {
				const dataString = JSON.stringify(data);
				const dataSize = dataString.length;
				
				// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ï‡πà‡∏≤‡∏á‡πÜ
				const sizeLimit = {
					'mapImages': 2000000,    // 2MB ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
					'rooms': 1000000,       // 1MB ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
					'buildings': 500000,    // 500KB ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
					'default': 500000       // 500KB ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∑‡πà‡∏ô‡πÜ
				};
				
				const maxSize = sizeLimit[dataType] || sizeLimit['default'];
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
				if (dataSize > maxSize) {
					console.warn(`‚ö†Ô∏è Data too large for cache: ${dataType} (${dataSize} bytes) > limit (${maxSize} bytes)`);
					
					// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mapImages ‡πÉ‡∏´‡πâ‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏Å‡πá‡∏ö
					if (dataType === 'mapImages') {
						return compressAndCacheMapImages(data);
					}
					
					return false;
				}
				
				// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á
				if (!getStorageQuota()) {
					console.log('üíæ Storage quota low, freeing up space...');
					freeUpStorage(dataSize + 100000); // ‡πÄ‡∏û‡∏¥‡πà‡∏° buffer 100KB
				}
				
				localStorage.setItem(getDataCacheKey(dataType), dataString);
				localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
				
				console.log(`‚úÖ Cached ${dataType}: ${(dataSize/1024).toFixed(1)}KB`);
				return true;
				
			} catch (error) {
				if (error.name === 'QuotaExceededError') {
					console.warn('üö® Storage quota exceeded, attempting cleanup...');
					freeUpStorage(200000); // ‡∏•‡πâ‡∏≤‡∏á 200KB
					
					try {
						// ‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏•‡∏±‡∏á‡∏•‡πâ‡∏≤‡∏á
						localStorage.setItem(getDataCacheKey(dataType), JSON.stringify(data));
						localStorage.setItem(getDataTimestampKey(dataType), Date.now().toString());
						console.log(`‚úÖ Cached ${dataType} after cleanup`);
						return true;
					} catch (retryError) {
						console.error(`‚ùå Failed to cache ${dataType} even after cleanup:`, retryError);
						return false;
					}
				} else {
					console.error(`‚ùå Cache error for ${dataType}:`, error);
					return false;
				}
			}
		}
		
		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		function compressAndCacheMapImages(mapData) {
			try {
				// ‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û base64 ‡πÇ‡∏î‡∏¢‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ metadata ‡πÅ‡∏•‡∏∞ URL ‡∏™‡∏±‡πâ‡∏ô‡πÜ
				const compressedData = {
					floorplan: mapData.floorplan ? 'compressed_floorplan' : null,
					realphoto: mapData.realphoto ? 'compressed_realphoto' : null,
					notes: mapData.notes || '',
					loaded: mapData.loaded || false,
					compressed: true,
					originalSizes: {
						floorplan: mapData.floorplan ? mapData.floorplan.length : 0,
						realphoto: mapData.realphoto ? mapData.realphoto.length : 0
					}
				};
				
				// ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏π‡∏õ‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô session storage ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
				if (mapData.floorplan) {
					try {
						sessionStorage.setItem('temp_floorplan', mapData.floorplan);
					} catch (e) {
						console.warn('Cannot store floorplan in session storage');
					}
				}
				
				if (mapData.realphoto) {
					try {
						sessionStorage.setItem('temp_realphoto', mapData.realphoto);
					} catch (e) {
						console.warn('Cannot store realphoto in session storage');
					}
				}
				
				// ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß
				const compressedString = JSON.stringify(compressedData);
				localStorage.setItem(getDataCacheKey('mapImages'), compressedString);
				localStorage.setItem(getDataTimestampKey('mapImages'), Date.now().toString());
				
				console.log(`üóúÔ∏è Map images compressed and cached: ${(compressedString.length/1024).toFixed(1)}KB`);
				return true;
				
			} catch (error) {
				console.error('‚ùå Failed to compress map images:', error);
				return false;
			}
		}

      // ======= Progressive Data Loading ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Live Mode =======
			async function loadRoomDataFromAdmin() {
				try {
					console.log('üîÑ Loading room data for version:', currentVersion);
					await progressiveLoadLiveData();
					 
					// ‡πÇ‡∏´‡∏•‡∏î buildings data
					await loadBuildingsData();
					
					//updateGlobalVersionIndicator(currentVersion);
					showDataSourceStatus();
					
				} catch (error) {
					console.error('‚ùå Error loading room data:', error);
					// Fallback to cached or sample data
					roomData = getCachedData('rooms') || { ...sampleRoomData };
					showNotification('‚ö†Ô∏è ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏£‡∏≠‡∏á', 'warning');
				}
			}
			

			async function progressiveLoadLiveData() {
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö cache ‡∏Å‡πà‡∏≠‡∏ô
				if (isCacheValid('rooms', 10 * 60 * 1000)) { // 10 ‡∏ô‡∏≤‡∏ó‡∏µ
					roomData = getCachedData('rooms') || {};
					console.log('üíæ Using cached rooms:', Object.keys(roomData).length, 'rooms');
					showProgressiveStatus('üèÉ‚Äç‚ôÇÔ∏è ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Cache', 'success');
					return;
				}
				
				// ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£ Loading Overlay
				showProgressiveStatus('üåê ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets...', 'info');
				
				try {
					// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Google Sheets
					const sheetsData = await loadRoomsFromSheets();
					
					if (sheetsData && Object.keys(sheetsData).length > 0) {
						roomData = sheetsData;
						
						// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å cache ‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
						const cacheSuccess = safeSetCachedData('rooms', roomData);
						
						console.log('‚úÖ Loaded rooms from Google Sheets:', Object.keys(roomData).length, 'rooms');
						showProgressiveStatus(`‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ${Object.keys(roomData).length} ‡∏´‡πâ‡∏≠‡∏á`, 'success');
						
						if (!cacheSuccess) {
							showProgressiveStatus('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Cache ‡πÑ‡∏î‡πâ', 'warning');
						}
					} else {
						// Fallback to cache or sample
						roomData = getCachedData('rooms') || { ...sampleRoomData };
						console.log('üì± Using fallback data:', Object.keys(roomData).length, 'rooms');
						showProgressiveStatus('üì± ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏£‡∏≠‡∏á', 'warning');
					}
					
				} catch (error) {
					console.error('‚ùå Failed to load from sheets:', error);
					roomData = getCachedData('rooms') || { ...sampleRoomData };
					showProgressiveStatus('‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏£‡∏≠‡∏á', 'error');
				}
			}

			function showProgressiveStatus(message, type = 'info') {
				// ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ö‡∏î‡∏ö‡∏±‡∏á UI
				showNotification(message, type);
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï version indicator ‡∏î‡πâ‡∏ß‡∏¢‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
				/*
				const indicator = document.getElementById('globalVersionIndicator');
				if (indicator && currentVersion === 'live') {
					if (type === 'info') {
						indicator.innerHTML = '‚è≥ LOADING...';
						indicator.className = 'status-indicator status-error';
					} else if (type === 'success') {
						indicator.innerHTML = 'üî¥ LIVE';
						indicator.className = 'status-indicator status-active';
					} else if (type === 'warning' || type === 'error') {
						indicator.innerHTML = '‚ö†Ô∏è ISSUES';
						indicator.className = 'status-indicator status-error';
					}
				}
				*/
			}
			
 
			// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÇ‡∏´‡∏•‡∏î Buildings Data
			 
			async function loadBuildingsData() {
				try {
					if (currentVersion === 'demo') {
						if (isCacheValid('buildings')) {
							buildingsData = getCachedData('buildings') || { ...sampleBuildingsData };
						} else {
							const savedBuildings = localStorage.getItem('buildingsData');
							if (savedBuildings) {
								buildingsData = JSON.parse(savedBuildings);
								setCachedData('buildings', buildingsData);
							} else {
								buildingsData = { ...sampleBuildingsData };
								setCachedData('buildings', buildingsData);
							}
						}
					} else if (currentVersion === 'live') {
						if (isCacheValid('buildings')) {
							buildingsData = getCachedData('buildings') || {};
							console.log('üíæ Loaded buildings from cache:', Object.keys(buildingsData).length, 'buildings');
						} else {
							const sheetsBuildings = await loadBuildingsFromSheets();
							if (sheetsBuildings && Object.keys(sheetsBuildings).length > 0) {
								buildingsData = sheetsBuildings;
								setCachedData('buildings', buildingsData);
								console.log('‚úÖ Loaded buildings from Google Sheets:', Object.keys(buildingsData).length, 'buildings');
							} else {
								buildingsData = getCachedData('buildings') || { ...sampleBuildingsData };
							}
						}
					}
				} catch (error) {
					console.error('‚ùå Error loading buildings data:', error);
					buildingsData = getCachedData('buildings') || { ...sampleBuildingsData };
				}
			}

			
			
			// ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Google Sheets =======
			async function loadRoomsFromSheets() {
				try {
					console.log('üîÑ Loading rooms from Google Sheets...');
					
					// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° timeout ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ error
					const controller = new AbortController();
					const timeoutId = setTimeout(() => {
						controller.abort();
						console.log('‚è∞ Request timeout - aborting rooms loading');
					}, 15000); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
					
					const params = new URLSearchParams();
					params.append('action', 'getData');
					params.append('sheet', sheetsConfig.roomsSheet);
					
					const response = await fetch(sheetsConfig.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: params.toString(),
						signal: controller.signal
					});
					
					clearTimeout(timeoutId);
					
					if (!response.ok) {
						throw new Error(`HTTP ${response.status}: ${response.statusText}`);
					}
					
					const result = await response.json();
					console.log('üìä Rooms API response received');
					
					if (result.success && result.data && result.data.length > 0) {
						const rooms = {};
						
						// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö batch size ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô blocking
						const batchSize = 5; // ‡∏•‡∏î‡∏à‡∏≤‡∏Å 10 ‡πÄ‡∏õ‡πá‡∏ô 5
						let processedCount = 0;
						
						for (let i = 0; i < result.data.length; i += batchSize) {
							const batch = result.data.slice(i, i + batchSize);
							
							batch.forEach(row => {
								if (row.code && row.name) {
									rooms[row.code] = {
										code: row.code,
										name: row.name,
										building: row.building || '',
										location: row.location || row.floor || '',
										floor: parseInt(row.floor) || 1,
										type: row.type || 'classroom',
										description: row.description || '',
										hours: row.hours || '08:00 - 16:30',
										status: row.status || 'active',
										x: parseFloat(row.x) || 50,
										y: parseFloat(row.y) || 50,
										images: row.image_urls ? (Array.isArray(row.image_urls) ? row.image_urls : [row.image_urls]) : []
									};
									processedCount++;
								}
							});
							
							// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤
							if (i % (batchSize * 4) === 0) { // ‡∏ó‡∏∏‡∏Å 20 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
								console.log(`üìä Processing rooms: ${processedCount}/${result.data.length}`);
								showProgressiveStatus(`üìä ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á: ${processedCount}/${result.data.length}`, 'info');
							}
							
							// ‡πÉ‡∏´‡πâ browser ‡∏°‡∏µ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• UI
							if (i + batchSize < result.data.length) {
								await new Promise(resolve => setTimeout(resolve, 20)); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 20ms
							}
						}
						
						console.log(`‚úÖ Rooms processed successfully: ${Object.keys(rooms).length} rooms`);
						return rooms;
					}
					
					console.warn('‚ö†Ô∏è No room data received from sheets');
					return null;
					
				} catch (error) {
					if (error.name === 'AbortError') {
						console.error('‚è∞ Request timeout loading rooms from sheets');
						showProgressiveStatus('‚è∞ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ', 'warning');
					} else {
						console.error('‚ùå Failed to load rooms from sheets:', error);
						showProgressiveStatus(`‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ${error.message}`, 'error');
					}
					return null;
				}
			}
			
		 
			async function loadBuildingsFromSheets() {
				try {
					console.log('üîÑ Loading buildings from Google Sheets...');
					
					const controller = new AbortController();
					const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ timeout
					
					const params = new URLSearchParams();
					params.append('action', 'getData');
					params.append('sheet', sheetsConfig.buildingsSheet);
					
					const response = await fetch(sheetsConfig.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: params.toString(),
						signal: controller.signal
					});
					
					clearTimeout(timeoutId);
					
					if (!response.ok) {
						throw new Error(`HTTP ${response.status}: ${response.statusText}`);
					}
					
					const result = await response.json();
					console.log('üìä Buildings API response received');
					
					if (result.success && result.data && result.data.length > 0) {
						const buildings = {};
						result.data.forEach(row => {
							if (row.code && row.name) {
								buildings[row.code] = {
									code: row.code,
									name: row.name,
									floors: parseInt(row.floors) || 1,
									year: parseInt(row.year) || new Date().getFullYear(),
									description: row.description || '',
									status: row.status || 'active'
								};
							}
						});
						
						console.log('‚úÖ Buildings loaded successfully:', Object.keys(buildings).length, 'buildings');
						return buildings;
					}
					
					console.warn('‚ö†Ô∏è No building data received from sheets');
					return null;
					
				} catch (error) {
					if (error.name === 'AbortError') {
						console.error('‚è∞ Request timeout loading buildings from sheets');
					} else {
						console.error('‚ùå Failed to load buildings from sheets:', error);
					}
					return null;
				}
			}	

		// ======= Intelligent Cache Management =======
		function intelligentCacheManagement() {
			const maxCacheAge = {
				rooms: 15 * 60 * 1000,     // 15 ‡∏ô‡∏≤‡∏ó‡∏µ
				buildings: 30 * 60 * 1000,  // 30 ‡∏ô‡∏≤‡∏ó‡∏µ
				system: 60 * 60 * 1000      // 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
			};
			
			const now = Date.now();
			const keys = Object.keys(localStorage);
			
			keys.forEach(key => {
				if (key.includes('_timestamp_')) {
					const dataType = key.replace('_timestamp_', '').replace('_live', '').replace('_demo', '');
					const timestamp = localStorage.getItem(key);
					const maxAge = maxCacheAge[dataType] || 15 * 60 * 1000; // default 15 minutes
					
					if (timestamp && (now - parseInt(timestamp)) > maxAge) {
						const cacheKey = key.replace('_timestamp_', '_cache_');
						localStorage.removeItem(key);
						localStorage.removeItem(cacheKey);
						console.log(`üóëÔ∏è Expired cache removed: ${dataType}`);
					}
				}
			});
		}
		
		// ======= Connection Quality Detection =======
		let connectionQuality = 'unknown';
		let lastLatency = 0;

		async function detectConnectionQuality() {
			try {
				const start = performance.now();
				
				// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏î‡πâ‡∏ß‡∏¢ HEAD request ‡πÄ‡∏•‡πá‡∏Å ‡πÜ
				const response = await fetch(sheetsConfig.url, {
					method: 'HEAD',
					cache: 'no-cache'
				});
				
				const end = performance.now();
				lastLatency = end - start;
				
				if (lastLatency < 500) {
					connectionQuality = 'fast';
				} else if (lastLatency < 2000) {
					connectionQuality = 'medium';
				} else {
					connectionQuality = 'slow';
				}
				
				console.log(`üì∂ Connection quality: ${connectionQuality} (${Math.round(lastLatency)}ms)`);
				
				// ‡∏õ‡∏£‡∏±‡∏ö cache time ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏ô‡πá‡∏ï
				if (connectionQuality === 'slow') {
					// ‡πÄ‡∏ô‡πá‡∏ï‡∏ä‡πâ‡∏≤ = cache ‡∏ô‡∏≤‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô
					maxCacheAge.rooms = 30 * 60 * 1000;    // 30 ‡∏ô‡∏≤‡∏ó‡∏µ
					maxCacheAge.buildings = 60 * 60 * 1000; // 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
				}
				
			} catch (error) {
				connectionQuality = 'offline';
				console.log('üì∂ Connection: offline or error');
			}
		}
		
		// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö connection quality ‡∏ó‡∏∏‡∏Å 2 ‡∏ô‡∏≤‡∏ó‡∏µ
		//setInterval(detectConnectionQuality, 2 * 60 * 1000);


		// ======= ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Background Sync ‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏´‡πâ‡∏£‡∏ß‡∏°‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		async function backgroundSync() {
			if (currentVersion !== 'live' || connectionQuality === 'offline') {
				return;
			}
			
			console.log('üîÑ Background sync started...');
			
			try {
				// Sync ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
				if (!isCacheValid('rooms')) {
					const rooms = await loadRoomsFromSheets();
					if (rooms) {
						roomData = { ...roomData, ...rooms };
						safeSetCachedData('rooms', roomData);
						console.log('üîÑ Background sync: rooms updated');
					}
				}
				
				// ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô sync ‡∏ï‡πà‡∏≠
				await new Promise(resolve => setTimeout(resolve, 2000));
				
				// Sync ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
				if (!isCacheValid('buildings')) {
					const buildings = await loadBuildingsFromSheets();
					if (buildings) {
						buildingsData = { ...buildingsData, ...buildings };
						safeSetCachedData('buildings', buildingsData);
						console.log('üîÑ Background sync: buildings updated');
					}
				}
				
				// ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô sync ‡∏ï‡πà‡∏≠
				await new Promise(resolve => setTimeout(resolve, 2000));
				
				// ‚≠ê ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ - Sync ‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
				await backgroundSyncMapImages();
				
			} catch (error) {
				console.log('üîÑ Background sync encountered issues:', error.message);
			}
		}
		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á Debug ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Console =======

		window.debugMapImages = debugMapImages;
		window.retryLoadMapImages = retryLoadMapImages;
		


		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		function getMapStatus() {
			return {
				version: currentVersion,
				layout: currentMapLayout,
				hasFloorplan: !!mapData.floorplan,
				hasRealPhoto: !!mapData.realphoto,
				loaded: mapData.loaded,
				cacheValid: isCacheValid('mapImages'),
				sheetsConnected: sheetsConfig.connected
			};
		}

		window.getMapStatus = getMapStatus;

		// ======= ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Map Status ‡πÉ‡∏ô Console =======
		console.log('üó∫Ô∏è Map Images System Ready');
		console.log('üìã Available commands:');
		console.log('  - debugMapImages() - ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• debug');
		console.log('  - getMapStatus() - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞');
		console.log('  - retryLoadMapImages() - ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡∏°‡πà');
		
		 

		// ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
		setInterval(intelligentCacheManagement, 5 * 60 * 1000); // ‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ


		function showDataSourceStatus() {
			const roomCount = Object.keys(roomData).length;
			const buildingCount = Object.keys(buildingsData).length;
			
			let statusMessage = '';
			if (currentVersion === 'demo') {
				statusMessage = `üéÆ Demo Mode: ${roomCount} ‡∏´‡πâ‡∏≠‡∏á, ${buildingCount} ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£`;
			} else {
				const cacheStatus = isCacheValid('rooms') ? '(‡∏à‡∏≤‡∏Å Cache)' : '(‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà)';
				statusMessage = `üî¥ Live Mode: ${roomCount} ‡∏´‡πâ‡∏≠‡∏á, ${buildingCount} ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ ${cacheStatus}`;
			}
			
			setTimeout(() => {
				showNotification(statusMessage, 'info');
			}, 1000);
		}

        // =================== FIX 5: Building Filter System ===================
        /* / ======= ‡∏•‡∏ö Building Filter Functions =======
		async function extractBuildingsList() {
				// ‡πÇ‡∏´‡∏•‡∏î buildings data ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô live mode
				if (adminDataVersion === 'live') {
					const sheetsBuildings = await loadBuildingsFromSheets();
					if (sheetsBuildings) {
						console.log('‚úÖ Loaded buildings from Google Sheets:', Object.keys(sheetsBuildings).length, 'buildings');
					}
				}
				
				const buildings = new Set();
				Object.values(roomData).forEach(room => {
					if (room.building) {
						buildings.add(room.building);
					}
				});
				buildingsList = Array.from(buildings).sort();
				updateBuildingFilter();
			}

         function updateBuildingFilter() {
			const container = document.getElementById('buildingButtons');
			if (!container) return;
			
			const allText = currentLanguage === 'th' ? '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' : 'All';
			
			container.innerHTML = `
				<button class="building-btn ${currentBuildingFilter === 'all' ? 'active' : ''}" 
						onclick="filterByBuilding('all')">
					${allText}
				</button>
				${buildingsList.map(building => {
					// ‡πÉ‡∏ä‡πâ buildingsData ‡πÅ‡∏ó‡∏ô localStorage
					const buildingName = buildingsData[building]?.name || building;
					
					return `
						<button class="building-btn ${currentBuildingFilter === building ? 'active' : ''}" 
								onclick="filterByBuilding('${building}')">
							${buildingName}
						</button>
					`;
				}).join('')}
			`;
			
			console.log('üè¢ Building filter updated:', buildingsList.length, 'buildings');
		}

        function filterByBuilding(building) {
            currentBuildingFilter = building;
            updateBuildingFilter();
            updateRoomMarkers();
            
            const message = building === 'all' 
                ? (currentLanguage === 'th' ? 'üè¢ ‡πÅ‡∏™‡∏î‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' : 'üè¢ Showing all rooms')
                : (currentLanguage === 'th' ? `üè¢ ‡∏Å‡∏£‡∏≠‡∏á‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£: ${building}` : `üè¢ Filtered: ${building}`);
            
            showNotification(message, 'info');
        }
		*/

        // =================== Utility Functions ===================
        
        function getRoomIcon(roomName) {
            const lowerName = roomName.toLowerCase();
            if (lowerName.includes('computer') || lowerName.includes('‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå')) return 'üíª';
            if (lowerName.includes('library') || lowerName.includes('‡∏™‡∏°‡∏∏‡∏î')) return 'üìö';
            if (lowerName.includes('cafeteria') || lowerName.includes('‡∏≠‡∏≤‡∏´‡∏≤‡∏£')) return 'üçΩÔ∏è';
            if (lowerName.includes('music') || lowerName.includes('‡∏î‡∏ô‡∏ï‡∏£‡∏µ')) return 'üéµ';
            if (lowerName.includes('art') || lowerName.includes('‡∏®‡∏¥‡∏•‡∏õ‡∏∞')) return 'üé®';
            if (lowerName.includes('gym') || lowerName.includes('‡∏¢‡∏¥‡∏°')) return 'üèÉ';
            if (lowerName.includes('lab') || lowerName.includes('‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£') || lowerName.includes('‡πÄ‡∏Ñ‡∏°‡∏µ') || lowerName.includes('‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå')) return 'üß™';
            if (lowerName.includes('office') || lowerName.includes('‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô') || lowerName.includes('‡∏ú‡∏π‡πâ‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢‡∏Å‡∏≤‡∏£')) return 'üè¢';
            return 'üéì';
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            if (!notification) return;
            
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function openAdminInterface() {
            // Update this URL after deployment
            window.open('./admin.html', '_blank');
        }
		function openSystemPresentation() {
            // Update this URL after deployment
            window.open('./SystemPresentation.html', '_blank');
        }


	 
		// ===== 2. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Persistent Destination =====
		// v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô updateRouteControls()

		function saveDestination(roomCode) {
			if (!roomData[roomCode]) return;
			
			const room = roomData[roomCode];
			
			// üî• ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô destination
			if (persistentDestination.roomCode && persistentDestination.roomCode !== roomCode) {
				console.log('üóëÔ∏è Clearing route due to destination change in saveDestination');
				forceRouteCleanup();
				updateRouteControls(false);
			}
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å destination ‡πÉ‡∏´‡∏°‡πà
			persistentDestination = {
				roomCode: roomCode,
				roomName: room.name,
				timestamp: Date.now()
			};
			
			try {
				localStorage.setItem('persistentDestination', JSON.stringify(persistentDestination));
				console.log('üíæ Destination saved:', persistentDestination);
			} catch (error) {
				console.warn('‚ö†Ô∏è Could not save destination to localStorage:', error);
			}
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI
			updateDestinationDisplay();
		}

		function loadDestination() {
			try {
				const saved = localStorage.getItem('persistentDestination');
				if (saved) {
					const data = JSON.parse(saved);
					// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡πÄ‡∏Å‡πà‡∏≤‡πÄ‡∏Å‡∏¥‡∏ô 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
					if (data.timestamp && (Date.now() - data.timestamp) < 3600000) {
						if (roomData[data.roomCode]) {
							persistentDestination = data;
							selectedRoom = data.roomCode;
							console.log('üéØ Restored destination:', data.roomName);
							return true;
						}
					}
				}
			} catch (error) {
				console.error('Error loading destination:', error);
			}
			return false;
		}

		function clearDestination() {
			persistentDestination = { roomCode: null, roomName: null, timestamp: null };
			localStorage.removeItem('persistentDestination');
			selectedRoom = null;
			console.log('üóëÔ∏è Cleared destination');
		}

		function showDestinationStatus() {
			if (persistentDestination.roomCode && roomData[persistentDestination.roomCode]) {
				const statusMessage = currentLanguage === 'th' 
					? `üéØ ‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢: ${persistentDestination.roomName}`
					: `üéØ Destination: ${persistentDestination.roomName}`;
				
				showNotification(statusMessage, 'info');
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
				const showRouteBtn = document.getElementById('showRouteBtn');
				if (showRouteBtn) {
					showRouteBtn.disabled = false;
					showRouteBtn.style.background = 'var(--accent-color)';
				}
			}
		}

		// ===== 3. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô selectRoom() =====
		// v1.1 ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô selectRoom() ‡πÄ‡∏î‡∏¥‡∏°

		function selectRoom(roomCode) {
			if (!roomData[roomCode]) return;
			
			const room = roomData[roomCode];
			
			console.log('üéØ Selecting new room:', room.name);
			
			// üî• ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà)
			if (routeDisplayed) {
				console.log('üóëÔ∏è Clearing existing route due to room selection');
				
				// ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏ó‡∏∏‡∏Å visual elements ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
				const routeElements = document.querySelectorAll(`
					.route-line, .route-marker, .route-path, .route-animated, 
					.route-line-animated, .route-marker-enhanced, 
					path[stroke="#dc3545"], circle[fill="#28a745"], circle[fill="#dc3545"],
					svg.route-path, .route-step-marker, .navigation-marker, [data-route="true"]
				`);
				
				routeElements.forEach(el => {
					console.log('Removing route element:', el.tagName, el.className);
					el.remove();
				});
				
				// ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå routePath element
				const routePath = document.getElementById('routePath');
				if (routePath) {
					routePath.innerHTML = '';
					routePath.style.display = 'none';
					routePath.remove(); // ‡∏•‡∏ö‡∏ó‡∏¥‡πâ‡∏á‡πÄ‡∏•‡∏¢
				}
				
				// ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå SVG ‡πÉ‡∏ô map container
				const mapContainer = ensureMapContainer();
				if (mapContainer) {
					const svgElements = mapContainer.querySelectorAll('svg.route-path, .route-animated, .route-line-animated');
					svgElements.forEach(el => {
						console.log('Removing SVG from map:', el.tagName);
						el.remove();
					});
				}
				
				// ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï route state ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
				routeDisplayed = false;
				currentRoute = null;
				
				console.log('‚úÖ Route cleared completely before setting new destination');
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
			const isChangingDestination = selectedRoom && selectedRoom !== roomCode;
			
			if (isChangingDestination) {
				// ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß
				const changeMessage = currentLanguage === 'th' 
					? `üéØ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô: ${room.name}`
					: `üéØ Destination changed to: ${room.name}`;
				showNotification(changeMessage, 'info');
			}
			
			// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
			selectedRoom = roomCode;
			persistentDestination = {
				roomCode: roomCode,
				roomName: room.name,
				building: room.building || '',
				floor: room.floor || ''
			};
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage
			localStorage.setItem('persistentDestination', JSON.stringify(persistentDestination));
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI
			highlightSelectedRoom(roomCode);
			showRoomDetails(room);
			updatePersistentDestinationStatus();
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
			updateRouteControls();
			
			console.log('‚úÖ Room selected successfully:', {
				roomCode,
				roomName: room.name,
				hasStartPoint: !!startPoint,
				routeDisplayed
			});
		}
		
		// ===== v1.1  ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô updateRouteControls() =====
		/*
       function updateRouteControls(showRoute) {
			const showRouteBtn = document.getElementById('showRouteBtn');
			const clearRouteBtn = document.getElementById('clearRouteBtn');
			const voiceBtn = document.getElementById('voiceNavigationBtn');
			
			console.log('üéÆ Enhanced route controls update:', { 
				showRoute, 
				hasStartPoint: !!startPoint, 
				hasSelectedRoom: !!selectedRoom,
				routeDisplayed: routeDisplayed
			});
			
			if (showRouteBtn) {
				// üî• ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏° "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠:
				// 1. ‡∏°‡∏µ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
				// 2. ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà (routeDisplayed = false)
				const hasRequiredPoints = startPoint && selectedRoom && roomData[selectedRoom];
				const shouldShowBtn = hasRequiredPoints && !routeDisplayed;
				
				if (shouldShowBtn) {
					showRouteBtn.style.display = 'inline-block';
					showRouteBtn.disabled = false;
					showRouteBtn.style.background = 'var(--primary-color)';
					showRouteBtn.style.opacity = '1';
					showRouteBtn.style.cursor = 'pointer';
					
					// üÜï ‡πÄ‡∏û‡∏¥‡πà‡∏° animation ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏î‡∏π‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ô‡πÉ‡∏à
					showRouteBtn.style.animation = 'pulse 2s infinite';
					
					console.log('‚úÖ Show Route button is now visible and active');
				} else {
					showRouteBtn.style.display = 'none';
					showRouteBtn.style.animation = 'none';
					
					console.log('‚ùå Show Route button hidden - missing requirements');
				}
				
				console.log('ShowRouteBtn status:', {
					hasRequiredPoints,
					routeDisplayed,
					shouldShowBtn,
					display: showRouteBtn.style.display
				});
			}
			
			if (clearRouteBtn) {
				// ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏° "‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà
				if (routeDisplayed) {
					clearRouteBtn.style.display = 'inline-block';
					clearRouteBtn.style.background = '#dc3545';
					clearRouteBtn.style.opacity = '1';
				} else {
					clearRouteBtn.style.display = 'none';
				}
			}
			
			if (voiceBtn) {
				// ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏° voice navigation ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà
				voiceBtn.style.display = routeDisplayed ? 'inline-block' : 'none';
			}
		}*/
		
		// v1.1 ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô updateRouteControls() ‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏∏‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á
		function updateRouteControls() {
			const showRouteBtn = document.getElementById('showRouteBtn');
			const clearRouteBtn = document.getElementById('clearRouteBtn');
			const voiceBtn = document.getElementById('voiceNavigationBtn');
			
			console.log('üéÆ Updating route controls:', { 
				hasStartPoint: !!startPoint, 
				hasSelectedRoom: !!selectedRoom,
				routeDisplayed: routeDisplayed
			});
			
			if (showRouteBtn) {
				// üî• ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏° "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠:
				// 1. ‡∏°‡∏µ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
				// 2. ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà (routeDisplayed = false)
				const hasRequiredPoints = startPoint && selectedRoom && roomData[selectedRoom];
				const shouldShowBtn = hasRequiredPoints && !routeDisplayed;
				
				if (shouldShowBtn) {
					showRouteBtn.style.display = 'inline-block';
					showRouteBtn.disabled = false;
					showRouteBtn.style.background = 'var(--primary-color)';
					showRouteBtn.style.opacity = '1';
					showRouteBtn.style.cursor = 'pointer';
					showRouteBtn.style.color = '#fff';
				} else {
					// ‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
					showRouteBtn.style.display = 'none';
				}
				
				console.log('ShowRouteBtn status:', {
					hasRequiredPoints,
					routeDisplayed,
					shouldShowBtn,
					display: showRouteBtn.style.display
				});
			}
			
			if (clearRouteBtn) {
				// ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏° "‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà
				if (routeDisplayed) {
					clearRouteBtn.style.display = 'inline-block';
					clearRouteBtn.style.background = '#dc3545';
					clearRouteBtn.style.opacity = '1';
					clearRouteBtn.style.color = '#fff';
				} else {
					clearRouteBtn.style.display = 'none';
				}
			}
			
			if (voiceBtn) {
				// ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏° voice navigation ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà
				voiceBtn.style.display = routeDisplayed ? 'inline-block' : 'none';
			}
		}
		 
		
		// v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
		function forceRouteCleanup() {
			console.log('üßπ Ultimate route cleanup starting...');
			
			// ‡∏´‡∏¢‡∏∏‡∏î animations ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
			const animatedElements = document.querySelectorAll('[style*="animation"]');
			animatedElements.forEach(el => {
				if (el.style.animation.includes('dash') || el.style.animation.includes('pulse')) {
					el.style.animation = 'none';
				}
			});
			
			// ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ selectors ‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏∏‡∏Å‡∏Å‡∏£‡∏ì‡∏µ
			const routeSelectors = [
				'.route-line', '.route-marker', '.route-path', '.route-step-marker',
				'.navigation-marker', '[data-route="true"]', '.route-animated',
				'.route-line-animated', '.route-marker-enhanced', 'path[stroke="#dc3545"]',
				'circle[fill="#28a745"]', 'circle[fill="#dc3545"]', 'polygon[fill="#dc3545"]',
				'svg[class*="route"]', 'path[class*="route"]', 'circle[class*="route"]',
				'polygon[class*="route"]'
				// ‡∏•‡∏ö '[class*="route-"]' ‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏•‡∏ö‡∏õ‡∏∏‡πà‡∏° controls ‡∏î‡πâ‡∏ß‡∏¢
			];
			
			// ‡∏•‡∏ö‡∏ó‡∏∏‡∏Å element ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö route ‡∏à‡∏≤‡∏Å document ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
			routeSelectors.forEach(selector => {
				try {
					const elements = document.querySelectorAll(selector);
					elements.forEach(el => {
						console.log('Ultimate removing:', el.tagName, el.className || el.getAttribute('class'));
						if (el && el.parentNode) {
							el.parentNode.removeChild(el);
						}
					});
				} catch (e) {
					console.warn('Selector error:', selector, e);
				}
			});
			
			// ‡∏•‡∏ö routePath ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
			const existingRoutePath = document.getElementById('routePath');
			if (existingRoutePath) {
				existingRoutePath.remove();
				console.log('‚úÖ Removed existing routePath');
			}
			
			// ‡∏•‡∏ö‡∏ó‡∏∏‡∏Å SVG elements ‡∏ó‡∏µ‡πà‡∏°‡∏µ route properties ‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å container
			const allPossibleContainers = [
				document.getElementById('mapContainer'),
				document.getElementById('mapArea'),
				document.querySelector('.map-area'),
				document.querySelector('.map-container'),
				document.querySelector('#mapImage')?.parentElement,
				document.body
			].filter(Boolean);
			
			allPossibleContainers.forEach(container => {
				if (container && container.nodeType === 1) {
					// ‡∏•‡∏ö SVG ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô route ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
					const allSvgElements = container.querySelectorAll('svg, path, circle, polygon, line, polyline');
					allSvgElements.forEach(el => {
						const isRouteElement = 
							el.getAttribute('stroke') === '#dc3545' ||
							el.getAttribute('fill') === '#28a745' ||
							el.getAttribute('fill') === '#dc3545' ||
							el.className.baseVal?.includes('route') ||
							el.classList.contains('route-path') ||
							el.classList.contains('route-animated') ||
							el.getAttribute('data-route') === 'true';
						
						if (isRouteElement) {
							console.log('Removing route SVG:', el.tagName);
							if (el.parentNode) {
								el.parentNode.removeChild(el);
							}
						}
					});
				}
			});
			
			// ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï global states
			window.routeDisplayed = false;
			window.currentRoute = null;
			
		 
			// ‚≠ê ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠ restore ‡∏õ‡∏∏‡πà‡∏° controls ‡∏´‡∏•‡∏±‡∏á cleanup
			setTimeout(() => {
				updateRouteControls(); 
			}, 100);
		}

		// ===== v1.1 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô handleMapClick() =====
		function handleMapClick(event) {
			if (!event) return;
			
			console.log('üñ±Ô∏è Map clicked');
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà element ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
			if (event.target.closest('.room-marker') || 
				event.target.closest('.route-controls') ||
				event.target.closest('.search-container')) {
				return;
			}
			
			const rect = event.currentTarget.getBoundingClientRect();
			const x = ((event.clientX - rect.left) / rect.width) * 100;
			const y = ((event.clientY - rect.top) / rect.height) * 100;
			
			console.log('üìç Click coordinates:', { x: x.toFixed(2), y: y.toFixed(2) });
			
			// üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°
			if (startPoint) {
				console.log('üìç Updating existing start point (preserving destination)');
				
				// ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á ‡πÑ‡∏°‡πà‡∏•‡∏ö‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
				if (routeDisplayed) {
					console.log('üóëÔ∏è Clearing route for new start point');
					clearRoute(); // ‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°
				}
			} else {
				console.log('üìç Setting initial start point');
			}
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà
			startPoint = { x, y };
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage (‡∏Ñ‡∏á‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ)
			localStorage.setItem('startPoint', JSON.stringify(startPoint));
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï UI marker
			updateStartPointMarker(x, y);
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏õ‡∏∏‡πà‡∏°
			const hasDestination = selectedRoom && roomData[selectedRoom];
			
			if (hasDestination) {
				console.log('‚úÖ Both start point and destination available');
				
				// ‡πÅ‡∏™‡∏î‡∏á notification
				const statusMessage = currentLanguage === 'th' 
					? `üìç ‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà (‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢: ${persistentDestination.roomName})`
					: `üìç Start point updated (Destination: ${persistentDestination.roomName})`;
				
				showNotification(statusMessage, 'success');
				
				// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
				updateRouteControls();
			} else {
				const message = currentLanguage === 'th' 
					? 'üìç ‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢'
					: 'üìç Start point set. Please select destination';
				showNotification(message, 'info');
			}
			
			console.log('üìç Start point updated:', { 
				startPoint, 
				hasDestination,
				selectedRoom
			});
		}
		
		// v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô updateStartPointMarker() ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
		function updateStartPointMarker(x, y) {
			// ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏´‡πá‡∏ô - ‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ã‡πà‡∏≠‡∏ô‡∏≠‡∏¢‡∏π‡πà
			debugLog('üìç Start point updated (hidden from user)', { x: x.toFixed(2), y: y.toFixed(2) });
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï internal state ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á visual marker
			// ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debugging ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
			if (window.debugMode) {
				console.log('Hidden start point:', { x, y });
			}
		}

		// ===== ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤ state =====
		function validateRouteState() {
			console.log('üîç Validating route state...');
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö persistent destination
			if (persistentDestination.roomCode && !roomData[persistentDestination.roomCode]) {
				console.warn('‚ö†Ô∏è Persistent destination refers to non-existent room');
				clearDestination();
				return false;
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö selectedRoom
			if (selectedRoom && !roomData[selectedRoom]) {
				console.warn('‚ö†Ô∏è Selected room does not exist');
				selectedRoom = null;
				return false;
			}
			
			// ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á selectedRoom ‡πÅ‡∏•‡∏∞ persistentDestination
			if (persistentDestination.roomCode && selectedRoom !== persistentDestination.roomCode) {
				console.log('üîß Syncing selected room with persistent destination');
				selectedRoom = persistentDestination.roomCode;
			}
			
			return true;
		}

		// ===== ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Debug ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤ =====
		// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ debug function ‡∏ô‡∏µ‡πâ‡πÉ‡∏ô console ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤: debugRouteProblem()
		function debugRouteProblem() {
			console.group('üêõ Route State Debug');
			console.log('startPoint:', startPoint);
			console.log('selectedRoom:', selectedRoom);
			console.log('persistentDestination:', persistentDestination);
			console.log('Room data exists:', selectedRoom ? !!roomData[selectedRoom] : 'No room selected');
			console.log('Route displayed:', document.querySelector('.route-line') ? 'Yes' : 'No');
			console.log('LocalStorage persistent:', localStorage.getItem('persistentDestination'));
			console.log('LocalStorage startPoint:', localStorage.getItem('startPoint'));
			console.groupEnd();
		}



        // =================== Page Management ===================
		// ======= v1.1 ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô showPage ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		function showPage(pageId) {
		
		    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ body class ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö map page
		const body = document.body;
		
		// ‡∏•‡∏ö class ‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
		body.classList.remove('map-page', 'search-page', 'help-page');
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° class ‡∏ï‡∏≤‡∏° page ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
		if (pageId === 'map') {
			body.classList.add('map-page');
			body.setAttribute('data-current-page', 'map');
		} else if (pageId === 'search') {
			body.classList.add('search-page');
			body.setAttribute('data-current-page', 'search');
		} else if (pageId === 'help') {
			body.classList.add('help-page');
			body.setAttribute('data-current-page', 'help');
		}
	
			document.querySelectorAll('.page').forEach(page => {
				page.classList.remove('active');
			});
			
			document.querySelectorAll('.nav-item').forEach(item => {
				item.classList.remove('active');
			});
			
			const targetPage = document.getElementById(pageId + '-page');
			if (targetPage) {
				targetPage.classList.add('active');
			}
			
			if (pageId === 'search') {
				document.querySelector('.nav-item:nth-child(1)').classList.add('active');
			} else if (pageId === 'map') {
				document.querySelector('.nav-item:nth-child(2)').classList.add('active');
				
				// üî• ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤ map (‡∏Å‡∏£‡∏ì‡∏µ‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà)
				setTimeout(() => {
					console.log('üìç Loading map page...');
					
					// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
					const destinationLoaded = loadDestination();
					
					// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö state consistency
					validateRouteState();
					
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
					if (destinationLoaded && persistentDestination.roomCode) {
						console.log('üéØ Destination available:', persistentDestination.roomName);
						updateDestinationDisplay();
						
						// üî• ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤ map ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
						updateRouteControls(false);
						
					} else {
						console.log('üìç No destination set');
						updateRouteControls(false);
						
						setTimeout(() => {
							const selectMessage = currentLanguage === 'th' 
								? 'üè´ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á'
								: 'üè´ Please search and select a destination room';
							showNotification(selectMessage, 'info');
						}, 1000);
					}
				}, 100);
			}
		}
		 
		
		// ===== 7. ‡πÄ‡∏û‡∏¥‡πà‡∏° Error Handling ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û =====
		// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà:

		function handleImageLoadError(imgElement, roomName = '') {
			console.warn('‚ö†Ô∏è Image load failed:', imgElement.src);
			
			imgElement.style.display = 'none';
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á placeholder
			const placeholder = document.createElement('div');
			placeholder.style.cssText = `
				text-align: center; 
				padding: 40px; 
				background: #f8f9fa; 
				border-radius: 8px; 
				color: var(--text-secondary);
				border: 2px dashed #dee2e6;
			`;
			placeholder.innerHTML = `
				<i class="fas fa-image" style="font-size: 32px; opacity: 0.3; margin-bottom: 10px;"></i>
				<p>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ</p>
				${roomName ? `<small>‡∏´‡πâ‡∏≠‡∏á: ${roomName}</small>` : ''}
			`;
			
			imgElement.parentNode.insertBefore(placeholder, imgElement.nextSibling);
		}	
		
		window.debugRouteState = function() {
			console.log('üêõ Route Debug State:');
			console.log('selectedRoom:', selectedRoom);
			console.log('persistentDestination:', persistentDestination);
			console.log('startPoint:', startPoint);
			console.log('Room exists:', selectedRoom ? !!roomData[selectedRoom] : 'N/A');
			console.log('Route lines on page:', document.querySelectorAll('.route-line').length);
			console.log('Route markers on page:', document.querySelectorAll('.route-marker').length);
		};
		
		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Error ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		function handleMapImageError(event) {
			console.error('‚ùå Map image failed to load:', event.target.src);
			
			// ‡∏•‡∏≠‡∏á‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏†‡∏≤‡∏û‡∏≠‡∏∑‡πà‡∏ô‡∏Å‡πà‡∏≠‡∏ô
			if (currentMapLayout === 'photo' && mapData.floorplan) {
				console.log('üîÑ Photo failed, trying floorplan...');
				currentMapLayout = 'floorplan';
				updateMapDisplay();
				showNotification('‚ö†Ô∏è ‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á', 'warning');
				return;
			} else if (currentMapLayout === 'floorplan' && mapData.realphoto) {
				console.log('üîÑ Floorplan failed, trying photo...');
				currentMapLayout = 'photo';
				updateMapDisplay();
				showNotification('‚ö†Ô∏è ‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á', 'warning');
				return;
			}
			
			// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á ‡πÅ‡∏™‡∏î‡∏á fallback
			showFallbackMap();
			showNotification('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ', 'warning');
		}
		
		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏° Auto-retry ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		async function retryLoadMapImages(maxRetries = 3) {
			for (let i = 0; i < maxRetries; i++) {
				try {
					console.log(`üîÑ Retry loading map images: attempt ${i + 1}/${maxRetries}`);
					await loadMapDataFromSheets();
					
					if (mapData.floorplan || mapData.realphoto) {
						console.log('‚úÖ Map images loaded successfully on retry');
						return true;
					}
				} catch (error) {
					console.warn(`‚ö†Ô∏è Retry ${i + 1} failed:`, error.message);
					
					if (i < maxRetries - 1) {
						// ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
						await new Promise(resolve => setTimeout(resolve, 2000));
					}
				}
			}
			
			console.error('‚ùå All retry attempts failed');
			return false;
		}
		
		// ======= Background Sync ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		async function backgroundSyncMapImages() {
			if (currentVersion !== 'live') return;
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ cache ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
			if (!isCacheValid('mapImages', 60 * 60 * 1000)) { // 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
				console.log('üîÑ Background sync: Map images cache expired, refreshing...');
				
				try {
					await loadMapDataFromSheets();
					console.log('‚úÖ Background sync: Map images updated');
				} catch (error) {
					console.log('‚ö†Ô∏è Background sync: Map images failed -', error.message);
				}
			}
		}

		// ======= Cache Management Functions =======
		function clearDataCache() {
			// ‡∏•‡∏ö cache ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
			const keys = Object.keys(localStorage);
			keys.forEach(key => {
				if (key.includes('_cache_') || key.includes('_timestamp_')) {
					localStorage.removeItem(key);
				}
			});
			console.log('üóëÔ∏è Data cache cleared');
		}

		function getCacheInfo() {
			// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug - ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô cache
			const cacheInfo = {
				rooms: {
					cached: !!getCachedData('rooms'),
					timestamp: localStorage.getItem(getDataTimestampKey('rooms')),
					valid: isCacheValid('rooms')
				},
				buildings: {
					cached: !!getCachedData('buildings'),
					timestamp: localStorage.getItem(getDataTimestampKey('buildings')),
					valid: isCacheValid('buildings')
				}
			};
			console.log('üìä Cache Info:', cacheInfo);
			return cacheInfo;
		}

        // =================== Search Functions ===================
        
        function handleSearchKeyPress(event) {
            if (event.key === 'Enter') {
                searchRoom();
            }
        }

       
		// ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô liveSearch ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
		function liveSearch() {
			try {
				const searchInput = document.getElementById('liveSearchInput');
				const resultsContainer = document.getElementById('liveResults');
				
				if (!searchInput || !resultsContainer) return;
				
				const searchTerm = searchInput.value.trim();
				
				if (searchTerm.length === 0) {
					resultsContainer.innerHTML = '';
					return;
				}
				
				if (searchTerm.length < 2) {
					resultsContainer.innerHTML = `
						<div style="text-align: center; padding: 20px; color: var(--text-secondary);">
							‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£
						</div>
					`;
					return;
				}
				
				// ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
				const results = searchRooms(searchTerm);
				
				// ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
				const statsMessage = results.length > 0 
					? `üîç ‡∏û‡∏ö ${results.length} ‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö "${searchTerm}"`
					: `üîç ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö "${searchTerm}"`;
					
				// ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
				resultsContainer.innerHTML = `
					<div style="background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: var(--border-radius); margin-bottom: 15px; text-align: center; color: var(--primary-color); font-weight: 600;">
						${statsMessage}
					</div>
				`;
				
				if (results.length > 0) {
					displaySearchResults(results);
				} else {
					resultsContainer.innerHTML += `
						<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
							<div style="font-size: 48px; margin-bottom: 15px; opacity: 0.7;">üîç</div>
							<p style="margin-bottom: 10px; font-weight: 600;">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</p>
							<p style="font-size: 12px;">‡∏•‡∏≠‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏≠‡∏∑‡πà‡∏ô ‡πÄ‡∏ä‡πà‡∏ô "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå", "‡∏ä‡∏±‡πâ‡∏ô 1"</p>
						</div>
					`;
				}
				
			} catch (error) {
				console.error('Search error:', error);
				showNotification('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà', 'error');
			}
		}


        // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô searchRoom ‡∏´‡∏•‡∏±‡∏Å
		function searchRoom() {
			const searchInput = document.getElementById('searchInput');
			if (!searchInput) return;
			
			const searchTerm = searchInput.value.toLowerCase().trim();
			
			if (!searchTerm) {
				showNotification('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤', 'error');
				return;
			}
			
			try {
				// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° error handling ‡πÅ‡∏•‡∏∞ fallback
				let results = searchRooms(searchTerm);
				
				// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢ ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ advanced search
				if (results.length === 0) {
					results = searchRoomsAdvanced(searchTerm);
				}
				
				displaySearchResults(results);
				
				// ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
				const statsMessage = results.length > 0 
					? `üîç ‡∏û‡∏ö ${results.length} ‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö "${searchTerm}"`
					: `üîç ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö "${searchTerm}"`;
					
				setTimeout(() => {
					showNotification(statsMessage, results.length > 0 ? 'info' : 'warning');
				}, 500);
				
			} catch (error) {
				console.error('Main search error:', error);
				showNotification('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà', 'error');
			}
		}
		
		
		
		// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô debug ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
		function debugRoomData() {
			const rooms = Object.values(roomData);
			console.log('üîç Room Data Debug:');
			console.log(`Total rooms: ${rooms.length}`);
			
			const fieldsCheck = {
				name: 0,
				code: 0,
				location: 0,
				building: 0,
				description: 0,
				type: 0
			};
			
			rooms.forEach(room => {
				Object.keys(fieldsCheck).forEach(field => {
					if (room[field] && room[field].toString().trim().length > 0) {
						fieldsCheck[field]++;
					}
				});
			});
			
			console.log('Field completion:');
			Object.entries(fieldsCheck).forEach(([field, count]) => {
				console.log(`  ${field}: ${count}/${rooms.length} (${(count/rooms.length*100).toFixed(1)}%)`);
			});
			
			// ‡πÅ‡∏™‡∏î‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ location
			const roomsWithoutLocation = rooms.filter(room => !room.location || room.location.toString().trim().length === 0);
			if (roomsWithoutLocation.length > 0) {
				console.log(`‚ö†Ô∏è Rooms without location: ${roomsWithoutLocation.length}`);
				roomsWithoutLocation.slice(0, 5).forEach(room => {
					console.log(`  - ${room.code}: ${room.name} (floor: ${room.floor || 'N/A'})`);
				});
			}
		}

		console.log('‚úÖ Search functions fixed with error handling');
		console.log('üîß Available debug command: debugRoomData()');

		// ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô debug ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
		if (typeof roomData !== 'undefined' && Object.keys(roomData).length > 0) {
			debugRoomData();
		}
	 
		
		// ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô searchRooms ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
		function searchRooms(searchTerm) {
			const rooms = Object.values(roomData);
			return rooms.filter(room => {
				if (!room || room.status !== 'active') return false;
				
				try {
					// ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ safeToString ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
					const searchFields = [
						safeToString(room.name).toLowerCase(),
						safeToString(room.code).toLowerCase(),
						safeToString(room.location || room.floor).toLowerCase(),
						safeToString(room.building).toLowerCase(),
						safeToString(room.description).toLowerCase(),
						safeToString(room.type).toLowerCase()
					].filter(field => field.length > 0);
					
					return searchFields.some(field => field.includes(searchTerm.toLowerCase()));
					
				} catch (error) {
					console.warn('Basic search error for room:', room.code, error);
					return false;
				}
			});
		}
		
		
		// ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° type checking ‡πÅ‡∏•‡∏∞ error handling
		function searchRoomsAdvanced(searchTerm) {
			const rooms = Object.values(roomData);
			const normalizedTerm = searchTerm.toLowerCase().trim();
			
			return rooms.filter(room => {
				if (!room || room.status !== 'active') return false;
				
				try {
					// ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô string ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
					const basicFields = [
						safeToString(room.name).toLowerCase(),
						safeToString(room.code).toLowerCase(),
						safeToString(room.location).toLowerCase(),
						safeToString(room.building).toLowerCase(),
						safeToString(room.description).toLowerCase(),
						safeToString(room.type).toLowerCase()
					].filter(field => field.length > 0);
					
					const basicMatch = basicFields.some(field => field.includes(normalizedTerm));
					
					// ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á
					const advancedMatches = [
						// ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏≤‡∏°‡∏ä‡∏±‡πâ‡∏ô
						normalizedTerm.includes('‡∏ä‡∏±‡πâ‡∏ô') && safeToString(room.floor || room.location).includes(normalizedTerm.replace('‡∏ä‡∏±‡πâ‡∏ô', '').trim()),
						normalizedTerm.includes('floor') && safeToString(room.floor || room.location).includes(normalizedTerm.replace('floor', '').trim()),
						
						// ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏´‡πâ‡∏≠‡∏á
						normalizedTerm.includes('‡πÄ‡∏£‡∏µ‡∏¢‡∏ô') && safeToString(room.name).toLowerCase().includes('‡πÄ‡∏£‡∏µ‡∏¢‡∏ô'),
						normalizedTerm.includes('classroom') && safeToString(room.type).toLowerCase().includes('classroom'),
						normalizedTerm.includes('‡∏Ñ‡∏≠‡∏°') && safeToString(room.name).toLowerCase().includes('‡∏Ñ‡∏≠‡∏°'),
						normalizedTerm.includes('computer') && safeToString(room.name + room.type).toLowerCase().includes('computer'),
						normalizedTerm.includes('‡∏´‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≥') && safeToString(room.name).toLowerCase().includes('‡∏´‡πâ‡∏≠‡∏á‡∏ô‡πâ‡∏≥'),
						normalizedTerm.includes('toilet') && safeToString(room.name + room.type).toLowerCase().includes('toilet'),
						
						// ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ï‡∏≤‡∏°‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
						normalizedTerm.includes('‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£') && safeToString(room.building).toLowerCase().includes(normalizedTerm),
						normalizedTerm.includes('building') && safeToString(room.building).toLowerCase().includes(normalizedTerm)
					];
					
					return basicMatch || advancedMatches.some(match => match);
					
				} catch (error) {
					console.warn('Search error for room:', room.code, error);
					return false;
				}
			});
		}
		
		// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô helper ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô string ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
		function safeToString(value) {
			if (value === null || value === undefined) return '';
			if (typeof value === 'string') return value;
			if (typeof value === 'number') return value.toString();
			if (typeof value === 'boolean') return value.toString();
			if (typeof value === 'object') return JSON.stringify(value);
			return String(value);
		}
		

     // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° safety checks ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
		function displaySearchResults(results) {
			const resultsContainer = document.getElementById('liveResults');
			if (!resultsContainer) return;
			
			if (results.length > 0) {
				resultsContainer.innerHTML = results.map(room => {
					// ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° safety checks
					const buildingName = buildingsData[room.building]?.name || safeToString(room.building) || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£';
					const roomLocation = safeToString(room.location) || (room.floor ? `‡∏ä‡∏±‡πâ‡∏ô ${room.floor}` : '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á');
					const roomDescription = safeToString(room.description) || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î';
					const roomName = safeToString(room.name) || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠';
					const roomCode = safeToString(room.code) || '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏´‡∏±‡∏™';
					
					return `
						<div class="search-result-item" onclick="viewOnMap('${roomCode}')">
							<div class="search-result-header">
								<div class="search-result-title">
									${getRoomIcon(roomName)} ${roomName}
								</div>
								<div class="search-result-code">${roomCode}</div>
							</div>
							<div class="search-result-info">
								<div style="margin-bottom: 5px;">
									<i class="fas fa-building" style="color: var(--primary-color); margin-right: 5px;"></i>
									${buildingName} - ${roomLocation}
								</div>
								${room.type ? `
									<div style="margin-bottom: 5px;">
										<i class="fas fa-tag" style="color: var(--accent-color); margin-right: 5px;"></i>
										${safeToString(room.type)}
									</div>
								` : ''}
								${roomDescription !== '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î' ? `
									<div style="font-size: 12px; color: var(--text-secondary);">
										<i class="fas fa-info-circle" style="margin-right: 5px;"></i>
										${roomDescription}
									</div>
								` : ''}
							</div>
						</div>
					`;
				}).join('');
				
				// ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
				const hintMessage = currentLanguage === 'th' 
					? 'üí° ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà'
					: 'üí° Click search result to view location on map';
				
				resultsContainer.innerHTML += `
					<div style="text-align: center; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: var(--border-radius); margin-top: 10px; color: var(--primary-color); font-size: 12px;">
						${hintMessage}
					</div>
				`;
			} else {
				const noResultsText = currentLanguage === 'th' ? '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤' : 'No results found';
				const suggestionText = currentLanguage === 'th' 
					? '‡∏•‡∏≠‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏≠‡∏∑‡πà‡∏ô ‡πÄ‡∏ä‡πà‡∏ô "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô", "‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå", "‡∏ä‡∏±‡πâ‡∏ô 1"'
					: 'Try searching with other terms like "classroom", "computer", "floor 1"';
					
				resultsContainer.innerHTML = `
					<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
						<div style="font-size: 48px; margin-bottom: 15px; opacity: 0.7;">üîç</div>
						<p style="margin-bottom: 10px; font-weight: 600;">${noResultsText}</p>
						<p style="font-size: 12px; color: var(--text-secondary);">${suggestionText}</p>
					</div>
				`;
			}
		}

        function quickSearch(category) {
            let searchResults = [];
            
            switch(category) {
                case 'classroom':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô') || room.name.includes('Classroom') || room.name.includes('‡∏°.'))
                    );
                    break;
                case 'special':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå') || room.name.includes('Computer') ||
                        room.name.includes('‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£') || room.name.includes('Lab'))
                    );
                    break;
                case 'facilities':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('‡∏™‡∏°‡∏∏‡∏î') || room.name.includes('Library') ||
                        room.name.includes('‡∏≠‡∏≤‡∏´‡∏≤‡∏£') || room.name.includes('Cafeteria'))
                    );
                    break;
                case 'office':
                    searchResults = Object.values(roomData).filter(room => 
                        room.status === 'active' && (
                        room.name.includes('‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô') || room.name.includes('Office'))
                    );
                    break;
            }
            
            displaySearchResults(searchResults);
        }

        // =================== Map Functions ===================
		// ======= Updated Search Functions =======
		function viewOnMap(roomCode) {
			showPage('map');
			setTimeout(() => {
				// ‡πÄ‡∏ã‡πá‡∏ï‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á marker
				selectedRoom = roomCode;
				updateRoomMarkers();
				
				// ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
				showRoomInfoOverlay(roomCode);
				
				// ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
				if (!startPoint) {
					const message = currentLanguage === 'th' 
						? 'üí° ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏Ñ‡∏•‡∏¥‡∏Å "‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á'
						: 'üí° Click on map to set starting point, then click "Show Route" for navigation';
					
					setTimeout(() => {
						showNotification(message, 'info');
					}, 1000);
				}
			}, 300);
		}


        function highlightRoom(roomCode) {
            document.querySelectorAll('.room-marker').forEach(marker => {
                marker.classList.remove('highlighted');
            });
            
            const targetMarker = document.querySelector(`[data-room="${roomCode}"]`);
            if (targetMarker) {
                targetMarker.classList.add('highlighted');
                selectedRoom = roomCode;
                
                setTimeout(() => {
                    targetMarker.classList.remove('highlighted');
                }, 3000);
            }
        }

        // 1.1: Toggle map controls visibility
        function toggleMapControls() {
			const mapControls = document.getElementById('mapControls');
			const toggleBtn = document.getElementById('toggleControlsBtn');
			const showControlsBtn = document.getElementById('showControlsBtn');
			
			if (!mapControls || !toggleBtn) return;
			
			const isHidden = mapControls.classList.contains('hidden');
			
			if (isHidden) {
				// Show controls
				mapControls.classList.remove('hidden');
				toggleBtn.innerHTML = `<i class="fas fa-eye-slash"></i> <span data-translate="hide_controls">${currentLanguage === 'th' ? '‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°' : 'Hide Controls'}</span>`;
				if (showControlsBtn) {
					showControlsBtn.style.display = 'none';
				}
				showNotification(
					currentLanguage === 'th' ? 'üëÅÔ∏è ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°' : 'üëÅÔ∏è Controls shown',
					'info'
				);
			} else {
				// Hide controls
				mapControls.classList.add('hidden');
				toggleBtn.innerHTML = `<i class="fas fa-eye"></i> <span data-translate="show_controls">${currentLanguage === 'th' ? '‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°' : 'Show Controls'}</span>`;
				if (showControlsBtn) {
					showControlsBtn.style.display = 'block';
				}
				showNotification(
					currentLanguage === 'th' ? 'üôà ‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°' : 'üôà Controls hidden',
					'info'
				);
			}
		}
		
		function showAllControls() {
			const mapControls = document.getElementById('mapControls');
			const toggleBtn = document.getElementById('toggleControlsBtn');
			const showControlsBtn = document.getElementById('showControlsBtn');
			
			if (!mapControls || !toggleBtn) return;
			
			mapControls.classList.remove('hidden');
			toggleBtn.innerHTML = `<i class="fas fa-eye-slash"></i> <span data-translate="hide_controls">${currentLanguage === 'th' ? '‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°' : 'Hide Controls'}</span>`;
			if (showControlsBtn) {
				showControlsBtn.style.display = 'none';
			}
			showNotification(
				currentLanguage === 'th' ? 'üëÅÔ∏è ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' : 'üëÅÔ∏è All controls shown',
				'info'
			);
		}



        // 1.1: Set map layout (floorplan/photo)
        function setMapLayout(layout) {
            currentMapLayout = layout;
            
            document.querySelectorAll('.map-control-btn[data-layout]').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const targetBtn = document.querySelector(`[data-layout="${layout}"]`);
            if (targetBtn) {
                targetBtn.classList.add('active');
            }
            
            // In real implementation, would switch between different map images
            const mapImage = document.getElementById('mapImage');
            if (mapImage) {
                if (layout === 'photo') {
                    // Replace with actual photo map
                    showNotification(
                        currentLanguage === 'th' ? 'üì∏ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á' : 'üì∏ Switched to photo view',
                        'success'
                    );
                } else {
                    // Use floorplan
                    showNotification(
                        currentLanguage === 'th' ? 'üìê ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ún‡∏ú‡∏±‡∏á' : 'üìê Switched to floor plan',
                        'success'
                    );
                }
            }
        }
		

        // 1.1: Toggle fullscreen mode
		// üîß FIXED toggleFullscreen Function - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç DOM positioning issue
		  

		function toggleFullscreen() {
			const mapArea = document.getElementById('mapArea');
			const fullscreenBtn = document.getElementById('fullscreenBtn');
			const mapControls = document.getElementById('mapControls');
			const body = document.body;
			const mapContainer = document.querySelector('.map-container');
			
			if (!mapArea || !fullscreenBtn) {
				console.log('Required elements not found');
				return;
			}
			
			if (isFullscreen) {
				// ========== EXIT FULLSCREEN ==========
				console.log('Exiting fullscreen mode...');
				
				// Remove existing controls
				const existingControls = document.getElementById('fullscreenControls');
				if (existingControls) existingControls.remove();
				
				// Find map-section or create if missing
				let mapSection = document.querySelector('.map-section');
				if (!mapSection) {
					mapSection = document.createElement('div');
					mapSection.className = 'map-section';
					
					const pageActive = document.querySelector('.page.active');
					if (pageActive) {
						pageActive.appendChild(mapSection);
					}
				}
				
				// Move map-container back to map-section
				if (mapContainer && mapSection) {
					mapSection.appendChild(mapContainer);
				}
				
				// Reset map-container styles
				if (mapContainer) {
					mapContainer.removeAttribute('style');
				}
				
				// Move ORIGINAL buttons below map (not create new ones)
				moveOriginalButtonsBelowMap(mapSection);
				
				// Remove fullscreen class
				body.classList.remove('fullscreen-active');
				if (mapControls) {
					mapControls.classList.remove('fullscreen-controls');
				}
				
				// Update button
				fullscreenBtn.innerHTML = `<i class="fas fa-expand"></i> <span data-translate="fullscreen">${currentLanguage === 'th' ? '‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠' : 'Fullscreen'}</span>`;
				isFullscreen = false;
				
				// Show notification
				showNotification(
					currentLanguage === 'th' ? 'üì± ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠' : 'üì± Exited fullscreen mode',
					'info'
				);
				
			} else {
				// ========== ENTER FULLSCREEN ==========
				console.log('Entering fullscreen mode...');
				
				// Move map-container to body
				if (mapContainer) {
					document.body.appendChild(mapContainer);
				}
				
				body.classList.add('fullscreen-active');
				
				// Create Enhanced Fullscreen Controls (3 buttons)
				const controls = document.createElement('div');
				controls.id = 'fullscreenControls';
				controls.style.cssText = `
					position: fixed !important;
					top: 20px !important;
					right: 20px !important;
					z-index: 99999 !important;
					background: rgba(255,255,255,0.95) !important;
					padding: 12px !important;
					border-radius: 10px !important;
					box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
					backdrop-filter: blur(10px) !important;
					display: flex !important;
					gap: 8px !important;
					opacity: 1 !important;
					visibility: visible !important;
				`;
				
				// Exit Button (Primary)
				const exitBtn = document.createElement('button');
				exitBtn.innerHTML = 'üö™';
				exitBtn.title = '‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠';
				exitBtn.style.cssText = `
					padding: 8px 10px !important;
					background: linear-gradient(135deg, #667eea, #764ba2) !important;
					color: white !important;
					border: none !important;
					border-radius: 6px !important;
					cursor: pointer !important;
					font-size: 14px !important;
					font-weight: 600 !important;
					min-width: 40px !important;
					transition: background 0.2s ease !important;
				`;
				exitBtn.onmouseover = () => exitBtn.style.background = 'linear-gradient(135deg, #5a67d8, #667eea) !important';
				exitBtn.onmouseout = () => exitBtn.style.background = 'linear-gradient(135deg, #667eea, #764ba2) !important';
				exitBtn.onclick = () => toggleFullscreen();
				
				// Voice Control Button
				const voiceBtn = document.createElement('button');
				voiceBtn.innerHTML = 'üé§';
				voiceBtn.title = '‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏á‡∏á‡∏≤‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á';
				voiceBtn.style.cssText = `
					padding: 8px 10px !important;
					background: rgba(0,0,0,0.7) !important;
					color: white !important;
					border: none !important;
					border-radius: 6px !important;
					cursor: pointer !important;
					font-size: 14px !important;
					min-width: 40px !important;
					transition: background 0.2s ease !important;
				`;
				voiceBtn.onmouseover = () => voiceBtn.style.background = 'rgba(0,0,0,0.9) !important';
				voiceBtn.onmouseout = () => voiceBtn.style.background = 'rgba(0,0,0,0.7) !important';
				voiceBtn.onclick = () => {
					if (typeof toggleVoiceRecognition === 'function') {
						toggleVoiceRecognition();
					}
				};
				
				// Language Toggle Button
				const langBtn = document.createElement('button');
				langBtn.innerHTML = 'üåê';
				langBtn.title = '‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤';
				langBtn.style.cssText = `
					padding: 8px 10px !important;
					background: rgba(0,0,0,0.7) !important;
					color: white !important;
					border: none !important;
					border-radius: 6px !important;
					cursor: pointer !important;
					font-size: 14px !important;
					min-width: 40px !important;
					transition: background 0.2s ease !important;
				`;
				langBtn.onmouseover = () => langBtn.style.background = 'rgba(0,0,0,0.9) !important';
				langBtn.onmouseout = () => langBtn.style.background = 'rgba(0,0,0,0.7) !important';
				langBtn.onclick = () => {
					if (typeof toggleLanguage === 'function') {
						toggleLanguage();
					}
				};
				
				// Add all buttons to controls
				controls.appendChild(exitBtn);
				controls.appendChild(voiceBtn);
				controls.appendChild(langBtn);
				document.body.appendChild(controls);
				
				// Update button text
				fullscreenBtn.innerHTML = `<i class="fas fa-compress"></i> <span data-translate="exit_fullscreen">${currentLanguage === 'th' ? '‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠' : 'Exit Fullscreen'}</span>`;
				isFullscreen = true;
				
				// Show notification
				showNotification(
					currentLanguage === 'th' ? 'üñ•Ô∏è ‡πÄ‡∏Ç‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠' : 'üñ•Ô∏è Entered fullscreen mode',
					'info'
				);
			}
		}

		// Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏° (‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà)
		function moveOriginalButtonsBelowMap(mapSection) {
			   // ‡∏´‡∏≤‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏±‡πâ‡∏á 3 ‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á
			const showRouteBtn = document.querySelector('#showRouteBtn, [onclick*="showRoute"], .btn-primary') || 
							Array.from(document.querySelectorAll('button')).find(btn => 
								btn.textContent.includes('‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á') && btn.style.display !== 'none');
							
			const clearRouteBtn = document.querySelector('#clearRouteBtn, [onclick*="clearRoute"], .btn-danger') || 
								 Array.from(document.querySelectorAll('button')).find(btn => 
									 btn.textContent.includes('‡∏•‡πâ‡∏≤‡∏á') && btn.style.display !== 'none');

			const voiceNavBtn = document.querySelector('#voiceNavBtn, [onclick*="voice"], .btn-success') || 
							   Array.from(document.querySelectorAll('button')).find(btn => 
								   btn.textContent.includes('‡πÄ‡∏™‡∏µ‡∏¢‡∏á') && btn.style.display !== 'none');

			if (mapSection && (clearRouteBtn || voiceNavBtn)) {
				// ‡∏•‡∏ö container ‡πÄ‡∏Å‡πà‡∏≤‡∏ñ‡πâ‡∏≤‡∏°‡∏µ (‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏° copy)
				const oldContainer = document.getElementById('map-bottom-buttons');
				if (oldContainer) {
					oldContainer.remove();
				}
				
				// ‡∏™‡∏£‡πâ‡∏≤‡∏á container ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏°
				const buttonContainer = document.createElement('div');
				buttonContainer.id = 'map-bottom-buttons';
				buttonContainer.style.cssText = `
					display: flex !important;
					justify-content: center !important;
					gap: 15px !important;
					margin: 20px 0 !important;
					padding: 15px !important;
					background: transparent !important;
					flex-wrap: wrap !important; //‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏•‡∏ö‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏î‡πâ
				`;
				 
				
				mapSection.appendChild(buttonContainer);
				
				 // ‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô)
				if (showRouteBtn) {
					showRouteBtn.style.cssText += `
						margin: 0 !important;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
						transition: all 0.2s ease !important;
					`;
					buttonContainer.appendChild(showRouteBtn);
				}
				
				// ‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡πÅ‡∏î‡∏á)
				if (clearRouteBtn) {
					// ‡πÄ‡∏û‡∏¥‡πà‡∏° styling ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏°
					clearRouteBtn.style.cssText += `
						margin: 0 !important;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
						transition: all 0.2s ease !important;
					`;
					
					// ‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á container ‡πÉ‡∏´‡∏°‡πà
					buttonContainer.appendChild(clearRouteBtn);
				}
				
				// ‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
				if (voiceNavBtn) {
					// ‡πÄ‡∏û‡∏¥‡πà‡∏° styling ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏°
					voiceNavBtn.style.cssText += `
						margin: 0 !important;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
						transition: all 0.2s ease !important;
					`;
					
					// ‡∏¢‡πâ‡∏≤‡∏¢‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á container ‡πÉ‡∏´‡∏°‡πà
					buttonContainer.appendChild(voiceNavBtn);
				}
				
				console.log('Moved original buttons below map');
			}
		}

		// üéπ Keyboard shortcut - ESC key support
		document.addEventListener('keydown', function(event) {
			if (event.key === 'Escape' && isFullscreen) {
				toggleFullscreen();
			}
		});
		
		
		function createEnhancedFullscreenControlsPatch() {
			const controls = document.createElement('div');
			controls.id = 'fullscreenControls';
			controls.style.cssText = `
				position: fixed !important;
				top: 20px !important;
				right: 20px !important;
				z-index: 99999 !important;
				background: rgba(255,255,255,0.95) !important;
				padding: 12px !important;
				border-radius: 10px !important;
				box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
				backdrop-filter: blur(10px) !important;
				display: flex !important;
				gap: 8px !important;
				opacity: 1 !important;
				visibility: visible !important;
			`;
			
			// Exit Button
			const exitBtn = document.createElement('button');
			exitBtn.innerHTML = 'üö™';
			exitBtn.title = '‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠';
			exitBtn.style.cssText = `
				padding: 8px 10px !important;
				background: linear-gradient(135deg, #667eea, #764ba2) !important;
				color: white !important;
				border: none !important;
				border-radius: 6px !important;
				cursor: pointer !important;
				font-size: 14px !important;
				font-weight: 600 !important;
			`;
			exitBtn.onclick = () => toggleFullscreen();
			
			// Voice Button
			const voiceBtn = document.createElement('button');
			voiceBtn.innerHTML = 'üé§';
			voiceBtn.title = '‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏á‡∏á‡∏≤‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á';
			voiceBtn.style.cssText = `
				padding: 8px 10px !important;
				background: rgba(0,0,0,0.7) !important;
				color: white !important;
				border: none !important;
				border-radius: 6px !important;
				cursor: pointer !important;
				font-size: 14px !important;
			`;
			voiceBtn.onclick = () => {
				if (typeof toggleVoiceRecognition === 'function') {
					toggleVoiceRecognition();
				}
			};
			
			// Language Button
			const langBtn = document.createElement('button');
			langBtn.innerHTML = 'üåê';
			langBtn.title = '‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏†‡∏≤‡∏©‡∏≤';
			langBtn.style.cssText = `
				padding: 8px 10px !important;
				background: rgba(0,0,0,0.7) !important;
				color: white !important;
				border: none !important;
				border-radius: 6px !important;
				cursor: pointer !important;
				font-size: 14px !important;
			`;
			langBtn.onclick = () => {
				if (typeof toggleLanguage === 'function') {
					toggleLanguage();
				}
			};
			
			controls.appendChild(exitBtn);
			controls.appendChild(voiceBtn);
			controls.appendChild(langBtn);
			document.body.appendChild(controls);
			
			return controls;
		}

		// ========== PATCH 2: ‡πÄ‡∏û‡∏¥‡πà‡∏° .map-section ‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ ==========
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° function ‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏ô toggleFullscreen
		function ensureMapSectionExistsPatch() {
			let mapSection = document.querySelector('.map-section');
			if (!mapSection) {
				mapSection = document.createElement('div');
				mapSection.className = 'map-section';
				
				const mapContainer = document.querySelector('.map-container');
				if (mapContainer && mapContainer.parentElement) {
					mapContainer.parentElement.insertBefore(mapSection, mapContainer);
					mapSection.appendChild(mapContainer);
				}
			}
			return mapSection;
		}

		// ========== PATCH 3: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Exit Logic ‡πÉ‡∏´‡πâ‡∏¢‡πâ‡∏≤‡∏¢ DOM ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ==========
		// ‡πÄ‡∏û‡∏¥‡πà‡∏° function ‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö exit fullscreen
		function exitFullscreenPatch() {
			// Remove existing controls
			const existingControls = document.getElementById('fullscreenControls');
			if (existingControls) {
				existingControls.remove();
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏°‡∏µ map-section
			const mapSection = ensureMapSectionExistsPatch();
			const mapContainer = document.querySelector('.map-container');
			
			// ‡∏¢‡πâ‡∏≤‡∏¢ map-container ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà map-section
			if (mapContainer && mapSection && !mapSection.contains(mapContainer)) {
				mapSection.appendChild(mapContainer);
			}
			
			// Reset inline styles
			if (mapContainer) {
				mapContainer.style.position = '';
				mapContainer.style.top = '';
				mapContainer.style.left = '';
				mapContainer.style.width = '';
				mapContainer.style.height = '';
				mapContainer.style.zIndex = '';
			}
		}
		// ========== End of  PATCH =====================================
		
        // =================== FIX 2: Route Persistence Functions ===================
      // ===== 4. ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô showRouteToSelected() ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô =====
		function showRouteToSelected() {
			console.log('üõ£Ô∏è Showing route to selected room...');
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏à‡∏≤‡∏Å persistent storage ‡∏Å‡πà‡∏≠‡∏ô
			if (!selectedRoom && persistentDestination.roomCode) {
				selectedRoom = persistentDestination.roomCode;
				console.log('üéØ Using persistent destination:', persistentDestination.roomName);
			}
			
			if (!selectedRoom || !roomData[selectedRoom]) {
				const selectMessage = currentLanguage === 'th' 
					? '‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô'
					: '‚ùå Please select a destination room first';
				showNotification(selectMessage, 'error');
				return;
			}
			
			if (!startPoint || startPoint.x === null || startPoint.y === null) {
				const startMessage = currentLanguage === 'th' 
					? '‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô'
					: '‚ùå Please click on map to set starting point';
				showNotification(startMessage, 'error');
				return;
			}
			
			// ‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
			document.querySelectorAll('.route-line, .route-marker, .route-animated, .route-line-animated').forEach(el => el.remove());
			const routePath = document.getElementById('routePath');
			if (routePath) {
				routePath.innerHTML = '';
			}
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï persistent destination ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à
			if (selectedRoom !== persistentDestination.roomCode) {
				saveDestination(selectedRoom);
			}
			
			const room = roomData[selectedRoom];
			currentRoute = { start: startPoint, destination: room };
			
			console.log('üîç Creating route from:', startPoint, 'to:', room);
			
			// ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
			showStraightRoutePath(startPoint, room);
			routeBtn.disabled = false;
            routeBtn.innerHTML = `<i class="fas fa-route"></i> <span data-translate="route_navigation">${currentLanguage === 'th' ? '‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ô‡∏≥‡∏ó‡∏≤‡∏á' : 'Route Navigation'}</span>`;
			 
			
			// üî• ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï state ‡πÅ‡∏•‡∏∞ controls
			routeDisplayed = true;
			updateRouteControls(true);  // ‡∏™‡πà‡∏á true ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏•‡πâ‡∏ß
			updateRoomMarkers();
			
			// ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
			const message = currentLanguage === 'th' 
				? `üõ£Ô∏è ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á ${room.name}`
				: `üõ£Ô∏è Route shown to ${room.name}`;
			showNotification(message, 'success');
			
			console.log('‚úÖ Route displayed. New state:', {
				routeDisplayed,
				currentRoute: !!currentRoute,
				selectedRoom
			});
		}
		
		// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ensureRoutePath function
		 function ensureRoutePath() {
			let routePath = document.getElementById('routePath');
			
			if (!routePath) {
				const mapContainer = document.getElementById('mapArea') || 
								   document.querySelector('.map-area') ||
								   document.querySelector('.map-container');
				
				if (mapContainer) {
					routePath = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
					routePath.id = 'routePath';
					routePath.className = 'route-path';
					
					// üîß FIX: ‡πÉ‡∏ä‡πâ #mapImage ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÅ‡∏ó‡∏ô querySelector('img')
					const mapImage = document.getElementById('mapImage') || 
									document.querySelector('.map-image');
					
					let viewBoxWidth = 800;
					let viewBoxHeight = 600;
					
					if (mapImage) {
						viewBoxWidth = mapImage.naturalWidth || mapImage.offsetWidth || 800;
						viewBoxHeight = mapImage.naturalHeight || mapImage.offsetHeight || 600;
						console.log('üìê Using correct map image dimensions:', { viewBoxWidth, viewBoxHeight });
					} else {
						console.log('‚ö†Ô∏è Using default viewBox dimensions');
					}
					
					// üîß FIX: ‡πÄ‡∏û‡∏¥‡πà‡∏° viewBox ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
					routePath.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
					routePath.setAttribute('preserveAspectRatio', 'xMidYMid meet');
					
					routePath.style.position = 'absolute';
					routePath.style.top = '0';
					routePath.style.left = '0';
					routePath.style.width = '100%';
					routePath.style.height = '100%';
					routePath.style.pointerEvents = 'none';
					routePath.style.zIndex = '10';
					
					mapContainer.appendChild(routePath);
					
					console.log('‚úÖ Created routePath with viewBox:', routePath.getAttribute('viewBox'));
				}
			} else {
				// üîß FIX: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç routePath ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ viewBox
				if (!routePath.getAttribute('viewBox')) {
					const mapImage = document.getElementById('mapImage') || 
									document.querySelector('.map-image');
					
					const viewBoxWidth = mapImage?.naturalWidth || mapImage?.offsetWidth || 800;
					const viewBoxHeight = mapImage?.naturalHeight || mapImage?.offsetHeight || 600;
					
					routePath.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
					routePath.setAttribute('preserveAspectRatio', 'xMidYMid meet');
					
					console.log('üîß Fixed existing routePath viewBox:', routePath.getAttribute('viewBox'));
				}
			}
			
			return routePath;
		}

        // ========== 2. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç showStraightRoutePath function ==========
		function showStraightRoutePath(start, destination) {
			try {
				console.log('üé® Creating route with FIXED coordinate system...');
				console.log('üìç Input coordinates:', { start, destination });
				
				// ‡∏•‡πâ‡∏≤‡∏á route elements ‡πÄ‡∏Å‡πà‡∏≤
				document.querySelectorAll('.route-line, .route-marker, .route-line-border, .route-start-marker, .route-end-marker, .route-waypoint').forEach(el => el.remove());
				
				let routePath = ensureRoutePath();
				if (!routePath) {
					console.error('‚ùå Cannot create route path SVG');
					return;
				}
				
				// ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÄ‡∏î‡∏¥‡∏°
				routePath.innerHTML = '';
				routePath.style.display = 'block';
				
				// ‡πÉ‡∏ä‡πâ coordinates ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
				const startX = start.x;
				const startY = start.y;
				const endX = destination.x;
				const endY = destination.y;
				
				console.log('üéØ Final coordinates:', { startX, startY, endX, endY });
				console.log('üìê ViewBox:', routePath.getAttribute('viewBox'));
				
				// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏≤‡∏ß (background)
				const borderLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
				borderLine.className = 'route-line-border';
				borderLine.setAttribute('x1', startX);
				borderLine.setAttribute('y1', startY);
				borderLine.setAttribute('x2', endX);
				borderLine.setAttribute('y2', endY);
				borderLine.setAttribute('stroke', '#ffffff');
				borderLine.setAttribute('stroke-width', '6');
				borderLine.setAttribute('opacity', '0.8');
				borderLine.setAttribute('stroke-linecap', 'round');
				routePath.appendChild(borderLine);
				
				// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å
				const mainLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
				mainLine.className = 'route-line-animated';
				mainLine.setAttribute('x1', startX);
				mainLine.setAttribute('y1', startY);
				mainLine.setAttribute('x2', endX);
				mainLine.setAttribute('y2', endY);
				mainLine.setAttribute('stroke', '#dc3545');
				mainLine.setAttribute('stroke-width', '3');
				mainLine.setAttribute('stroke-dasharray', '8 4');
				mainLine.setAttribute('stroke-linecap', 'round');
				routePath.appendChild(mainLine);
				
				// ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
				const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				startMarker.className = 'route-start-marker';
				startMarker.setAttribute('cx', startX);
				startMarker.setAttribute('cy', startY);
				startMarker.setAttribute('r', '8');
				startMarker.setAttribute('fill', '#28a745');
				startMarker.setAttribute('stroke', '#ffffff');
				startMarker.setAttribute('stroke-width', '2');
				routePath.appendChild(startMarker);
				
				// ‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
				const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				endMarker.className = 'route-end-marker';
				endMarker.setAttribute('cx', endX);
				endMarker.setAttribute('cy', endY);
				endMarker.setAttribute('r', '10');
				endMarker.setAttribute('fill', '#dc3545');
				endMarker.setAttribute('stroke', '#ffffff');
				endMarker.setAttribute('stroke-width', '2');
				routePath.appendChild(endMarker);
				
				console.log('‚úÖ Fixed route created with', routePath.children.length, 'elements');
				
				// ‡πÅ‡∏™‡∏î‡∏á notification
				const routeMessage = typeof currentLanguage !== 'undefined' && currentLanguage === 'th' 
					? 'üõ£Ô∏è ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß' 
					: 'üõ£Ô∏è Route displayed successfully';
				
				if (typeof showNotification === 'function') {
					showNotification(routeMessage, 'success');
				}
				
				return true;
				
			} catch (error) {
				console.error('‚ùå Error creating fixed route:', error);
				
				const errorMessage = typeof currentLanguage !== 'undefined' && currentLanguage === 'th' 
					? '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á'
					: 'Error displaying route';
					
				if (typeof showNotification === 'function') {
					showNotification(errorMessage, 'error');
				}
				
				return false;
			}
		}
		
		// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô initializeSystem() ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å setMapLayout('floorplan');
		function ensureRouteAnimationCSS() {
			if (document.getElementById('route-animation-styles')) return;
			
			const style = document.createElement('style');
			style.id = 'route-animation-styles';
			style.textContent = `
				@keyframes route-dash {
					0% { stroke-dashoffset: 0; }
					100% { stroke-dashoffset: -24; }
				}
				
				.route-line-animated {
					animation: route-dash 2s linear infinite;
				}
				
				.route-start-marker, .route-end-marker {
					filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
					transition: all 0.3s ease;
				}
				
				.route-line-border {
					filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
				}
				
				.route-start-marker:hover, .route-end-marker:hover {
					transform: scale(1.2);
				}
			`;
			
			document.head.appendChild(style);
			console.log('‚úÖ Animation CSS added');
		}

		// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
		ensureRouteAnimationCSS();
		
		 
		
		// v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á CSS animation
		function ensureAnimationCSS() {
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ animation CSS ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
			if (document.head.querySelector('style[data-route-animation]')) {
				return;
			}
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á CSS animation
			const style = document.createElement('style');
			style.setAttribute('data-route-animation', 'true');
			style.textContent = `
				/* Route Animation Styles */
				@keyframes route-dash {
					0% { 
						stroke-dashoffset: 0; 
					}
					100% { 
						stroke-dashoffset: -30; 
					}
				}
				
				.route-line-animated {
					animation: route-dash 3s linear infinite;
				}
				
				/* Enhanced Route Styles */
				.route-path {
					position: absolute;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					pointer-events: none;
					z-index: 10;
				}
				
				.route-marker-enhanced {
					animation: route-marker-pulse 2s ease-in-out infinite;
				}
				
				@keyframes route-marker-pulse {
					0%, 100% { 
						opacity: 0.8;
						transform: scale(1);
					}
					50% { 
						opacity: 1;
						transform: scale(1.2);
					}
				}
			`;
			
			document.head.appendChild(style);
			console.log('‚úÖ Animation CSS added to document');
		}
		
		
		
		// v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á route markers
		// ‡∏ã‡πà‡∏≠‡∏ô start point ‡πÉ‡∏ô route markers ‡∏î‡πâ‡∏ß‡∏¢
		function addRouteMarkers(startPoint, endPoint) {
			const routePath = document.getElementById('routePath');
			if (!routePath) return;
			
			// ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ End marker (‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á)
			const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			endMarker.setAttribute('cx', endPoint.x);
			endMarker.setAttribute('cy', endPoint.y);
			endMarker.setAttribute('r', '1.2');
			endMarker.setAttribute('fill', '#dc3545');
			endMarker.setAttribute('stroke', '#fff');
			endMarker.setAttribute('stroke-width', '0.3');
			endMarker.setAttribute('class', 'route-marker route-marker-enhanced');
			routePath.appendChild(endMarker);
			
			// ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á start marker
			debugLog('üéØ Only destination marker shown, start point hidden');
		}
		
		// ========== 2. Fixed 6x6 Walkable Grid System ==========

		// Fixed walkable grid data structure
		const FIXED_WALKABLE_GRID = {
			// ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏´‡∏•‡∏±‡∏Å
			config: {
				gridSize: 6,           // 6x6 grid
				totalNodes: 36,        // 36 nodes ‡∏´‡∏•‡∏±‡∏Å
				extraNodes: 12,        // 12 nodes ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡∏Å‡∏•‡∏≤‡∏á, ‡∏°‡∏∏‡∏°, ‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô)
				connectionRadius: 35,  // 35% radius
				maxConnections: 5,     // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5 ‡∏à‡∏∏‡∏î
				minConnections: 3      // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ 3 ‡∏à‡∏∏‡∏î
			},
			
			// Fixed node positions - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
			nodePositions: null,
			edgeConnections: null,
			isGenerated: false
		};

		// ‡∏™‡∏£‡πâ‡∏≤‡∏á Fixed Grid Positions
		function generateFixedGridPositions() {
			if (FIXED_WALKABLE_GRID.isGenerated) {
				return FIXED_WALKABLE_GRID.nodePositions;
			}
			
			debugLog('üèóÔ∏è Generating fixed 6x6 walkable grid...');
			
			const positions = [];
			let nodeId = 1;
			
			// 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á Main Grid 6x6 (36 nodes)
			const gridSpacing = 80 / (FIXED_WALKABLE_GRID.config.gridSize - 1); // 16% spacing
			
			for (let row = 0; row < FIXED_WALKABLE_GRID.config.gridSize; row++) {
				for (let col = 0; col < FIXED_WALKABLE_GRID.config.gridSize; col++) {
					const x = 10 + (col * gridSpacing);  // 10% margin, then 16% spacing
					const y = 10 + (row * gridSpacing);  // 10% margin, then 16% spacing
					
					positions.push({
						id: nodeId.toString(),
						x: Math.round(x * 10) / 10,  // round to 1 decimal
						y: Math.round(y * 10) / 10,
						type: 'grid',
						gridRow: row,
						gridCol: col
					});
					nodeId++;
				}
			}
			
			// 2. ‡πÄ‡∏û‡∏¥‡πà‡∏° Strategic Nodes (12 nodes ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°)
			const strategicNodes = [
				// Center cluster (4 nodes)
				{x: 50, y: 50, type: 'center'},     // ‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á‡∏Å‡∏•‡∏≤‡∏á
				{x: 45, y: 50, type: 'center'},     // ‡∏Å‡∏•‡∏≤‡∏á-‡∏ã‡πâ‡∏≤‡∏¢
				{x: 55, y: 50, type: 'center'},     // ‡∏Å‡∏•‡∏≤‡∏á-‡∏Ç‡∏ß‡∏≤
				{x: 50, y: 45, type: 'center'},     // ‡∏Å‡∏•‡∏≤‡∏á-‡∏ö‡∏ô
				
				// Corridor nodes (4 nodes)
				{x: 25, y: 50, type: 'corridor'},   // ‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏ã‡πâ‡∏≤‡∏¢
				{x: 75, y: 50, type: 'corridor'},   // ‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏Ç‡∏ß‡∏≤
				{x: 50, y: 25, type: 'corridor'},   // ‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏ö‡∏ô
				{x: 50, y: 75, type: 'corridor'},   // ‡∏ó‡∏≤‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
				
				// Corner connectors (4 nodes)
				{x: 20, y: 20, type: 'corner'},     // ‡∏°‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô
				{x: 80, y: 20, type: 'corner'},     // ‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô
				{x: 20, y: 80, type: 'corner'},     // ‡∏°‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏á
				{x: 80, y: 80, type: 'corner'}      // ‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏•‡πà‡∏≤‡∏á
			];
			
			strategicNodes.forEach(node => {
				positions.push({
					id: nodeId.toString(),
					x: node.x,
					y: node.y,
					type: node.type
				});
				nodeId++;
			});
			
			FIXED_WALKABLE_GRID.nodePositions = positions;
			
			debugLog('‚úÖ Fixed grid positions generated:', {
				totalNodes: positions.length,
				gridNodes: positions.filter(n => n.type === 'grid').length,
				strategicNodes: positions.filter(n => n.type !== 'grid').length
			});
			
			return positions;
		}

		// ‡∏™‡∏£‡πâ‡∏≤‡∏á Fixed Edge Connections
		function generateFixedEdgeConnections(positions) {
			debugLog('üîó Generating fixed edge connections...');
			
			const edges = [];
			const config = FIXED_WALKABLE_GRID.config;
			
			for (let i = 0; i < positions.length; i++) {
				const nodeA = positions[i];
				const connections = [];
				
				// ‡∏´‡∏≤‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏±‡∏®‡∏°‡∏µ
				for (let j = 0; j < positions.length; j++) {
					if (i === j) continue;
					
					const nodeB = positions[j];
					const distance = distanceBetweenPoints(nodeA, nodeB);
					
					if (distance <= config.connectionRadius) {
						connections.push({
							targetNode: nodeB,
							distance: distance,
							weight: distance * walkableRoutingData.settings.metersPerPercent
						});
					}
				}
				
				// ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
				connections.sort((a, b) => a.distance - b.distance);
				
				// ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö 3-5 ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
				const connectCount = Math.min(
					Math.max(config.minConnections, connections.length),
					config.maxConnections
				);
				
				for (let k = 0; k < connectCount; k++) {
					const conn = connections[k];
					
					// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ edge ‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (bidirectional)
					const existingEdge = edges.find(edge => 
						(edge.from === nodeA.id && edge.to === conn.targetNode.id) ||
						(edge.from === conn.targetNode.id && edge.to === nodeA.id)
					);
					
					if (!existingEdge) {
						edges.push({
							from: nodeA.id,
							to: conn.targetNode.id,
							weight: conn.weight,
							distance: conn.distance,
							bidirectional: true,
							type: 'fixed'
						});
					}
				}
			}
			
			FIXED_WALKABLE_GRID.edgeConnections = edges;
			
			debugLog('‚úÖ Fixed edge connections generated:', {
				totalEdges: edges.length,
				avgConnectionsPerNode: (edges.length * 2 / positions.length).toFixed(1)
			});
			
			return edges;
		}
		
		// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô createRobustSampleWalkableData ‡πÄ‡∏î‡∏¥‡∏°
		function createFixedWalkableGrid() {
			debugLog('üèóÔ∏è Creating fixed walkable grid (preparing for Google Sheets integration)...');
			
			// Clear existing data
			walkableRoutingData.nodes = {};
			walkableRoutingData.edges = [];
			
			// Generate fixed positions
			const positions = generateFixedGridPositions();
			const edges = generateFixedEdgeConnections(positions);
			
			// Convert to walkableRoutingData format
			positions.forEach(pos => {
				walkableRoutingData.nodes[pos.id] = {
					id: pos.id,
					x: pos.x,
					y: pos.y,
					type: pos.type || 'grid',
					building: walkableRoutingData.currentBuilding,
					isFixed: true  // flag ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô fixed node
				};
			});
			
			walkableRoutingData.edges = edges.map(edge => ({
				from: edge.from,
				to: edge.to,
				weight: edge.weight,
				bidirectional: edge.bidirectional,
				type: edge.type,
				isFixed: true  // flag ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô fixed edge
			}));
			
			FIXED_WALKABLE_GRID.isGenerated = true;
			
			// Statistics
			const stats = {
				totalNodes: Object.keys(walkableRoutingData.nodes).length,
				totalEdges: walkableRoutingData.edges.length,
				gridNodes: positions.filter(n => n.type === 'grid').length,
				strategicNodes: positions.filter(n => n.type !== 'grid').length,
				avgConnections: (walkableRoutingData.edges.length * 2 / positions.length).toFixed(1),
				coverage: '100%'  // ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
			};
			
			debugLog('‚úÖ Fixed walkable grid created:', stats);
			
			// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ
			try {
				const building = getCurrentBuilding();
				const storageKey = `walkableData_${building}`;
				const dataToSave = {
					nodes: walkableRoutingData.nodes,
					edges: walkableRoutingData.edges,
					settings: walkableRoutingData.settings,
					gridInfo: {
						type: 'fixed_grid',
						version: '1.0',
						generated: new Date().toISOString(),
						stats: stats
					},
					timestamp: new Date().toISOString()
				};
				localStorage.setItem(storageKey, JSON.stringify(dataToSave));
				debugLog('üíæ Fixed grid data saved to localStorage');
			} catch (error) {
				console.warn('‚ö†Ô∏è Could not save fixed grid to localStorage:', error);
			}
			
			return stats;
		}
		 

		// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
		function addDirectionArrow(startX, startY, endX, endY, svgElement) {
			try {
				// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
				const midX = (startX + endX) / 2;
				const midY = (startY + endY) / 2;
				
				// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°
				const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
				
				// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏π‡∏Å‡∏®‡∏£
				const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
				arrow.setAttribute('points', '-1.5,0 1.5,-1 1.5,1');
				arrow.setAttribute('fill', '#dc3545');
				arrow.setAttribute('stroke', '#fff');
				arrow.setAttribute('stroke-width', '0.5');
				arrow.setAttribute('transform', `translate(${midX}, ${midY}) rotate(${angle})`);
				arrow.className = 'route-marker route-marker-enhanced';
				
				svgElement.appendChild(arrow);
				
			} catch (error) {
				console.warn('‚ö†Ô∏è Could not add direction arrow:', error);
			}
		}
		
		// ===== 7. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢ =====
		function updateDestinationDisplay() {
			const statusElement = document.getElementById('destinationStatus');
			const textElement = document.getElementById('destinationText');
			
			if (!statusElement || !textElement) return;
			
			if (persistentDestination.roomCode && roomData[persistentDestination.roomCode]) {
				const displayText = currentLanguage === 'th' 
					? `‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢: ${persistentDestination.roomName}`
					: `Destination: ${persistentDestination.roomName}`;
				
				textElement.textContent = displayText;
				statusElement.style.display = 'block';
			} else {
				statusElement.style.display = 'none';
			}
		}
		
		
		// v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö map container
		function ensureMapContainer() {
			let mapContainer = document.getElementById('mapContainer');
			
			if (!mapContainer) {
				// ‡∏•‡∏≠‡∏á‡∏´‡∏≤ container ‡∏≠‡∏∑‡πà‡∏ô
				mapContainer = document.querySelector('.map-area') || 
							  document.querySelector('.map-container') ||
							  document.querySelector('#mapArea');
			}
			
			if (!mapContainer) {
				console.error('‚ùå No map container found in DOM');
				return null;
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ container ‡∏°‡∏µ style ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
			if (!mapContainer.style.position || mapContainer.style.position === 'static') {
				mapContainer.style.position = 'relative';
			}
			
			return mapContainer;
		}
		
		 

       // ===== v1.1 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç clearRoute() ‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô =====
		function clearRoute() {
			console.log('üóëÔ∏è Clearing route...');
			
			// ‡∏•‡∏ö‡∏ó‡∏∏‡∏Å element ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
			const routeSelectors = [
				'.route-line', 
				'.route-marker', 
				'.route-path',
				'.route-step-marker',
				'.navigation-marker',
				'[data-route="true"]',
				'.route-animated',
				'.route-line-animated',
				'.route-marker-enhanced',
				'.destination-marker',              // ‡πÄ‡∏û‡∏¥‡πà‡∏°
				'.destination-label',               // ‡πÄ‡∏û‡∏¥‡πà‡∏°
				'.waypoint-group',                  // ‡πÄ‡∏û‡∏¥‡πà‡∏°
				'.route-line-glow',                 // ‡πÄ‡∏û‡∏¥‡πà‡∏°
				'[data-marker-type="destination"]', // ‡πÄ‡∏û‡∏¥‡πà‡∏°
				'path[stroke="#dc3545"]',
				'circle[fill="#28a745"]',
				'circle[fill="#dc3545"]'
			];
			
			let removedCount = 0;
			routeSelectors.forEach(selector => {
				document.querySelectorAll(selector).forEach(el => {
					el.remove();
					removedCount++;
				});
			});
			
			// ‡∏•‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡∏ã‡πà‡∏≠‡∏ô routePath
			const routePath = document.getElementById('routePath');
			if (routePath) {
				routePath.innerHTML = '';
				routePath.style.display = 'none';
			}
			
			// ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï route state
			routeDisplayed = false;
			currentRoute = null;
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó UI controls
			setTimeout(() => {
				updateRouteControls(); 
			}, 100);
			
			console.log(`‚úÖ Route cleared completely (${removedCount} elements removed)`);
			
			const clearMessage = currentLanguage === 'th' 
				? 'üóëÔ∏è ‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß (‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏≠‡∏¢‡∏π‡πà)'
				: 'üóëÔ∏è Route cleared (destination preserved)';
			showNotification(clearMessage, 'info');
		}		
		
		
		// ===== 6. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç state =====
		function validateAndFixRouteState() {
			console.log('üîç Validating route state...');
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö localStorage
			try {
				const savedDestination = localStorage.getItem('persistentDestination');
				const savedStartPoint = localStorage.getItem('startPoint');
				
				if (savedDestination) {
					const parsed = JSON.parse(savedDestination);
					if (parsed.roomCode && roomData[parsed.roomCode]) {
						persistentDestination = parsed;
						selectedRoom = parsed.roomCode;
						console.log('‚úÖ Restored destination from localStorage:', parsed.roomName);
					} else {
						// ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ‡∏•‡πâ‡∏≤‡∏á‡∏≠‡∏≠‡∏Å
						localStorage.removeItem('persistentDestination');
						clearDestination();
					}
				}
				
				if (savedStartPoint) {
					const parsed = JSON.parse(savedStartPoint);
					if (parsed.x !== null && parsed.y !== null) {
						startPoint = parsed;
						console.log('‚úÖ Restored start point from localStorage:', parsed);
					}
				}
				
			} catch (error) {
				console.error('‚ùå Error validating state:', error);
				// ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢
				localStorage.removeItem('persistentDestination');
				localStorage.removeItem('startPoint');
				clearDestination();
				startPoint = null;
			}
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI
			updateDestinationDisplay();
			updateRouteControls(routeDisplayed);
			
			console.log('üéØ Final state:', {
				selectedRoom,
				persistentDestination: persistentDestination.roomCode,
				startPoint: startPoint ? `(${Math.round(startPoint.x)}, ${Math.round(startPoint.y)})` : null
			});
		}

        function generateCompleteRoute() {
            showRouteToSelected();
        }

        // Remove old curved path and replace with simple straight line
        function showModernRoutePath(start, destination) {
            // Use the new straight path function
            showStraightRoutePath(start, destination);
        }

        function hideRoutePath() {
            const routePath = document.getElementById('routePath');
            if (routePath) {
                routePath.style.display = 'none';
                routePath.innerHTML = '';
            }
        }

        // =================== FIX 3: Continuous Voice Navigation ===================
        
        function startContinuousVoiceNavigation() {
            if (!currentRoute) {
                const message = currentLanguage === 'th' 
                    ? '‚ùå ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á' 
                    : '‚ùå No route available for navigation';
                showNotification(message, 'error');
                return;
            }
            
            if (isVoiceNavigating) {
                stopVoiceNavigation();
                return;
            }
            
            if (!('speechSynthesis' in window)) {
                const message = currentLanguage === 'th' 
                    ? '‚ùå ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á' 
                    : '‚ùå Browser does not support speech synthesis';
                showNotification(message, 'error');
                return;
            }
            
            generateVoiceQueue();
            startVoiceSequence();
        }

        function generateVoiceQueue() {
            voiceQueue = [];
            
            if (!currentRoute) return;
            
            const { start, destination } = currentRoute;
            const deltaX = destination.x - start.x;
            const deltaY = destination.y - start.y;
            const distance = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 2);
            
            let direction = '';
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                direction = deltaX > 0 
                    ? (currentLanguage === 'th' ? '‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤' : 'to the right')
                    : (currentLanguage === 'th' ? '‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢' : 'to the left');
            } else {
                direction = deltaY > 0 
                    ? (currentLanguage === 'th' ? '‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á' : 'downward')
                    : (currentLanguage === 'th' ? '‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô' : 'upward');
            }
            
            if (currentLanguage === 'th') {
                voiceQueue = [
                    '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á',
                    `‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏õ${direction} ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì ${distance} ‡πÄ‡∏°‡∏ï‡∏£`,
                    `‡∏°‡∏≠‡∏á‡∏´‡∏≤‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ ${destination.building}`,
                    `‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà ${destination.name}`,
                    '‡∏ñ‡∏∂‡∏á‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô'
                ];
            } else {
                voiceQueue = [
                    'Starting navigation',
                    `Walk ${direction} approximately ${distance} meters`,
                    `Look for building ${destination.building}`,
                    `Enter ${destination.name}`,
                    'Destination reached. Navigation complete'
                ];
            }
        }

        function startVoiceSequence() {
            if (voiceQueue.length === 0) return;
            
            isVoiceNavigating = true;
            updateVoiceButton(true);
            
            const message = currentLanguage === 'th' 
                ? 'üîä ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á' 
                : 'üîä Starting voice navigation';
            showNotification(message, 'success');
            
            speakNextInQueue();
        }

        function speakNextInQueue() {
            if (voiceQueue.length === 0 || !isVoiceNavigating) {
                finishVoiceNavigation();
                return;
            }
            
            const text = voiceQueue.shift();
            
            if (currentSpeech) {
                speechSynthesis.cancel();
            }
            
            currentSpeech = new SpeechSynthesisUtterance(text);
            currentSpeech.lang = currentLanguage === 'th' ? 'th-TH' : 'en-US';
            currentSpeech.rate = 0.8;
            currentSpeech.pitch = 1.0;
            
            currentSpeech.onend = () => {
                if (isVoiceNavigating) {
                    // Wait 2 seconds before next instruction
                    voiceTimeout = setTimeout(() => {
                        speakNextInQueue();
                    }, 2000);
                }
            };
            
            currentSpeech.onerror = () => {
                finishVoiceNavigation();
            };
            
            speechSynthesis.speak(currentSpeech);
        }

        function stopVoiceNavigation() {
            isVoiceNavigating = false;
            voiceQueue = [];
            
            if (voiceTimeout) {
                clearTimeout(voiceTimeout);
                voiceTimeout = null;
            }
            
            if (currentSpeech) {
                speechSynthesis.cancel();
                currentSpeech = null;
            }
            
            updateVoiceButton(false);
            
            const message = currentLanguage === 'th' 
                ? 'üîá ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á' 
                : 'üîá Voice navigation stopped';
            showNotification(message, 'warning');
        }

        function finishVoiceNavigation() {
            isVoiceNavigating = false;
            updateVoiceButton(false);
            
            const message = currentLanguage === 'th' 
                ? '‚úÖ ‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô' 
                : '‚úÖ Voice navigation completed';
            showNotification(message, 'success');
        }

        function updateVoiceButton(isActive) {
            const voiceBtn = document.getElementById('voiceNavigationBtn');
            if (!voiceBtn) return;
            
            if (isActive) {
                voiceBtn.classList.add('speaking');
                voiceBtn.innerHTML = `
                    <i class="fas fa-stop"></i> 
                    <span>${currentLanguage === 'th' ? '‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á' : 'Stop Voice'}</span>
                `;
            } else {
                voiceBtn.classList.remove('speaking');
                voiceBtn.innerHTML = `
                    <i class="fas fa-volume-up"></i> 
                    <span data-translate="voice_nav">${currentLanguage === 'th' ? '‡∏ô‡∏≥‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á' : 'Voice Navigation'}</span>
                `;
            }
        }

        // Legacy voice functions for compatibility
        function toggleVoiceNavigation() {
            if (isVoiceNavigating) {
                stopVoiceNavigation();
            } else {
                startContinuousVoiceNavigation();
            }
        }

        function speakStep(text) {
            if (!('speechSynthesis' in window)) {
                const message = currentLanguage === 'th' 
                    ? '‚ùå ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á' 
                    : '‚ùå Browser does not support speech synthesis';
                showNotification(message, 'error');
                return;
            }
            
            if (currentSpeech) {
                speechSynthesis.cancel();
            }
            
            currentSpeech = new SpeechSynthesisUtterance(text);
            currentSpeech.lang = currentLanguage === 'th' ? 'th-TH' : 'en-US';
            currentSpeech.rate = 0.8;
            currentSpeech.pitch = 1.0;
            
            speechSynthesis.speak(currentSpeech);
        }

        function speakText(text) {
            speakStep(text);
        }

        // =================== Room Markers ===================
        
        let selectedRoomForAction = null;
		// ======= Updated Room Markers - ‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á Pin ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î =======
		function updateRoomMarkers() {
			const markersContainer = document.getElementById('roomMarkers');
			if (!markersContainer) return;
			
			// ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
			let markersHTML = '';
			
			// ‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
			if (startPoint) {
				markersHTML += `
					<div class="room-marker start-point-marker" 
						 style="top: ${startPoint.y}%; left: ${startPoint.x}%;"
						 title="${currentLanguage === 'th' ? '‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô' : 'Starting Point'}"
						 onclick="showStartPointInfo()">
						üö©
					</div>
				`;
			}
			
			// ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
			if (selectedRoom && roomData[selectedRoom]) {
				const room = roomData[selectedRoom];
				markersHTML += `
					<div class="room-marker highlighted" 
						 data-room="${room.code}" 
						 style="top: ${room.y}%; left: ${room.x}%;"
						 title="${room.name}"
						 onclick="showRoomActionOverlay('${room.code}', event)">
						üéØ
					</div>
				`;
			}
			
			markersContainer.innerHTML = markersHTML;
		}
        // ======= Updated Room Markers - version ‡πÄ‡∏Å‡πà‡∏≤‡πÅ‡∏™‡∏î‡∏á Pin ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î =======
        function updateRoomMarkers_Old_ShowAllPinPoint() {
            const markersContainer = document.getElementById('roomMarkers');
            if (!markersContainer) return;
            
            let activeRooms = Object.values(roomData).filter(room => room.status === 'active');
            
            // FIX 5: Apply building filter
            if (currentBuildingFilter !== 'all') {
                activeRooms = activeRooms.filter(room => room.building === currentBuildingFilter);
            }
            
            markersContainer.innerHTML = activeRooms.map(room => {
                return `
                    <div class="room-marker" 
                         data-room="${room.code}" 
                         onclick="showRoomActionOverlay('${room.code}', event)" 
                         style="top: ${room.y}%; left: ${room.x}%;"
                         title="${room.name}">
                        ${getRoomIcon(room.name)}
                    </div>
                `;
            }).join('') + (startPoint ? `
                <div class="room-marker start-point-marker" 
                     style="top: ${startPoint.y}%; left: ${startPoint.x}%;"
                     title="${currentLanguage === 'th' ? '‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô' : 'Starting Point'}"
                     onclick="showStartPointInfo()">
                    üö©
                </div>
            ` : '');
        }

        // 1.2: Show action overlay when clicking room marker
        // ======= Room Action Overlay Functions - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Å‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà =======
		function showRoomActionOverlay(roomCode, event) {
			const room = roomData[roomCode];
			if (!room) return;
			
			selectedRoom = roomCode;
			
			const overlay = document.getElementById('roomActionOverlay');
			const header = document.getElementById('roomActionHeader');
			
			if (!overlay || !header) return;
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï header ‡∏î‡πâ‡∏ß‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏´‡πâ‡∏≠‡∏á
			header.textContent = `${room.name} - ${currentLanguage === 'th' ? '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£' : 'Select Action'}`;
			
			overlay.style.display = 'block';
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏ô overlay
			updateActionOverlayTranslations();
			
			// ‡∏ã‡πà‡∏≠‡∏ô overlay ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Ç‡πâ‡∏≤‡∏á‡∏ô‡∏≠‡∏Å
			setTimeout(() => {
				document.addEventListener('click', hideRoomActionOverlayOnClickOutside, { once: true });
			}, 100);
		}

        function hideRoomActionOverlayOnClickOutside(event) {
            const overlay = document.getElementById('roomActionOverlay');
            if (overlay && !overlay.contains(event.target) && !event.target.classList.contains('room-marker')) {
                overlay.style.display = 'none';
            }
        }

        function updateActionOverlayTranslations() {
            const buttons = document.querySelectorAll('#roomActionOverlay [data-translate]');
            buttons.forEach(button => {
                const key = button.getAttribute('data-translate');
                if (translations[currentLanguage] && translations[currentLanguage][key]) {
                    button.textContent = translations[currentLanguage][key];
                }
            });
        }

        // V1.1: Action functions
        function showRoomDetails() {
		
			 if (isFullscreen) {
				alert(currentLanguage === 'th' ? 
					'‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠ ‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î' : 
					'Please exit fullscreen mode first');
				return;
			}
	
            // üîß ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ selectedRoom ‡πÅ‡∏ó‡∏ô selectedRoomForAction
			if (!selectedRoom) return;
            
            // Hide action overlay
            const overlay = document.getElementById('roomActionOverlay');
            if (overlay) overlay.style.display = 'none';
            
            // Show room info overlay
            showRoomInfoOverlay(selectedRoom);
        }

       function showRouteDirectly() {
			if (!selectedRoom) return;
			
			// ‡∏ã‡πà‡∏≠‡∏ô action overlay
			const overlay = document.getElementById('roomActionOverlay');
			if (overlay) overlay.style.display = 'none';
			
			if (!startPoint) {
				const message = currentLanguage === 'th' 
					? 'üí° ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô' 
					: 'üí° Click on map to set starting point first';
				showNotification(message, 'info');
				return;
			}
			
			// ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
			showRouteToSelected();
		}

        function showStartPointInfo() {
            if (!startPoint) return;
            const message = currentLanguage === 'th' 
                ? `üö© ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á` 
                : `üö© Navigation starting point`;
            showNotification(message, 'info');
        }

        // =================== Room Info Functions ===================
        
        function getRoomTypeText(type) {
            const types = {
                'classroom': currentLanguage === 'th' ? '‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô' : 'Classroom',
                'computer': currentLanguage === 'th' ? '‡∏´‡πâ‡∏≠‡∏á‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå' : 'Computer Lab',
                'lab': currentLanguage === 'th' ? '‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£' : 'Laboratory',
                'library': currentLanguage === 'th' ? '‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏°‡∏∏‡∏î' : 'Library',
                'office': currentLanguage === 'th' ? '‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô' : 'Office',
                'facility': currentLanguage === 'th' ? '‡∏™‡∏¥‡πà‡∏á‡∏≠‡∏≥‡∏ô‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å' : 'Facility',
                'special': currentLanguage === 'th' ? '‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©' : 'Special Room'
            };
            return types[type] || type;
        }
        
        function showRoomInfoOverlay(roomCode) {
            const room = roomData[roomCode];
            if (!room) return;

            selectedRoom = roomCode;
            updateRouteControls(false);
            
            const overlay = document.getElementById('roomInfoOverlay');
            if (!overlay) return;
            
            const roomName = document.getElementById('overlayRoomName');
            const roomLocation = document.getElementById('overlayRoomLocation');
            const roomBuilding = document.getElementById('overlayRoomBuilding');
            const roomFloor = document.getElementById('overlayRoomFloor');
            const roomType = document.getElementById('overlayRoomType');
            const roomDescription = document.getElementById('overlayRoomDescription');
            const routeBtn = document.getElementById('routeBtn');
            
            if (roomName) roomName.innerHTML = `${getRoomIcon(room.name)} ${room.name}`;
            if (roomLocation) roomLocation.textContent = room.location || room.floor || 'N/A';
            
            // 1.3: Enhanced room information display (removed status)
            // Get building name from admin data
            const buildingData = JSON.parse(localStorage.getItem('buildingsData') || '{}');
            const buildingName = buildingData[room.building]?.name || room.building;
            if (roomBuilding) roomBuilding.textContent = buildingName;
            
            // Display floor information
            if (roomFloor) {
                const floorText = room.floor 
                    ? (currentLanguage === 'th' ? `‡∏ä‡∏±‡πâ‡∏ô ${room.floor}` : `Floor ${room.floor}`)
                    : (currentLanguage === 'th' ? '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏' : 'Not specified');
                roomFloor.textContent = floorText;
            }
            
            // Display room type
            if (roomType) roomType.textContent = getRoomTypeText(room.type || 'classroom');
            
            // 1.3: Remove status display - no longer shown
            
            if (roomDescription) roomDescription.textContent = room.description || (currentLanguage === 'th' ? '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î' : 'No description available');
            
            // Update route button state
            if (routeBtn) {
                if (!startPoint) {
                    routeBtn.disabled = true;
                    routeBtn.innerHTML = `<i class="fas fa-exclamation-triangle"></i> <span>${currentLanguage === 'th' ? '‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô' : 'Set start point first'}</span>`;
                } else {
                    routeBtn.disabled = false;
                    routeBtn.innerHTML = `<i class="fas fa-route"></i> <span data-translate="route_navigation">${currentLanguage === 'th' ? '‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ô‡∏≥‡∏ó‡∏≤‡∏á' : 'Route Navigation'}</span>`;
                }
            }
            
            // Display all images 
			updateOverlayImageGallery(room); // v1.1 ‡∏™‡πà‡∏á room object ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            generateOverlayNavigationSteps(room);
            
            overlay.style.display = 'flex';
        }

        function closeRoomInfoOverlay() {
            const overlay = document.getElementById('roomInfoOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            selectedRoom = null;
            updateRouteControls(false);
        }

        function generateOverlayNavigationSteps(room) {
            const routeSteps = document.getElementById('overlayRouteSteps');
            if (!routeSteps) return;
            
            if (!startPoint) {
                const noStartText = currentLanguage === 'th' 
                    ? '‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô'
                    : 'Click on map to set starting point first';
                    
                routeSteps.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: #fff3cd; border-radius: var(--border-radius); color: #856404;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p style="margin: 8px 0 0 0; font-size: 14px;">
                            ${noStartText}
                        </p>
                    </div>
                `;
                return;
            }
            
            const deltaX = room.x - startPoint.x;
            const deltaY = room.y - startPoint.y;
            const distance = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 2);
            
            let direction = '';
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                direction = deltaX > 0 
                    ? (currentLanguage === 'th' ? '‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤' : 'to the right')
                    : (currentLanguage === 'th' ? '‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢' : 'to the left');
            } else {
                direction = deltaY > 0 
                    ? (currentLanguage === 'th' ? '‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á' : 'downward')
                    : (currentLanguage === 'th' ? '‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô' : 'upward');
            }
            
            const steps = currentLanguage === 'th' ? [
                {
                    step: 1,
                    text: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô',
                    distance: '0m'
                },
                {
                    step: 2,
                    text: `‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏õ${direction} ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì ${distance} ‡πÄ‡∏°‡∏ï‡∏£`,
                    distance: `${distance}m`
                },
                {
                    step: 3,
                    text: `‡∏°‡∏≠‡∏á‡∏´‡∏≤ ${room.building}`,
                    distance: '10m'
                },
                {
                    step: 4,
                    text: `‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà ${room.name}`,
                    distance: '0m'
                }
            ] : [
                {
                    step: 1,
                    text: 'Start from starting point',
                    distance: '0m'
                },
                {
                    step: 2,
                    text: `Walk ${direction} approximately ${distance} meters`,
                    distance: `${distance}m`
                },
                {
                    step: 3,
                    text: `Look for ${room.building}`,
                    distance: '10m'
                },
                {
                    step: 4,
                    text: `Enter ${room.name}`,
                    distance: '0m'
                }
            ];
            
            const stepsTitle = currentLanguage === 'th' ? '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á' : 'Navigation Steps';
            
            routeSteps.innerHTML = `
                <div class="route-steps">
                    <h4 style="margin: 0 0 15px 0; font-size: 16px; color: var(--primary-color);">
                        <i class="fas fa-route"></i> ${stepsTitle}
                    </h4>
                    ${steps.map(step => `
                        <div class="route-step">
                            <div class="step-number">${step.step}</div>
                            <div class="step-content">${step.text}</div>
                            <div class="step-distance">${step.distance}</div>
                            <button class="step-voice-btn" onclick="speakStep('${step.text}')">
                                <i class="fas fa-volume-up"></i>
                            </button>
                        </div>
                    `).join('')}
                </div>
            `;
        }
		
		// üîß v1.1 ‡πÄ‡∏û‡∏¥‡πà‡∏° ensureRouteConsistency function ‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
		function ensureRouteConsistency() {
			console.log('üîÑ ensureRouteConsistency called');
			
			   // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ routing
			if (typeof window.routeState === 'undefined') {
				window.routeState = {
					showRoute: false,
					hasStartPoint: false,
					hasSelectedRoom: false,
					startPoint: null,
					selectedRoom: null
				};
			}
			
			// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó UI controls ‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
			/*
			const routeControls = document.querySelector('.route-controls');
			if (routeControls) {
				const showRouteBtn = routeControls.querySelector('#showRouteBtn');
				const clearRouteBtn = routeControls.querySelector('#clearRouteBtn');
				
				if (showRouteBtn) {
					showRouteBtn.style.display = window.routeState.hasStartPoint && window.routeState.hasSelectedRoom ? 'inline-block' : 'none';
				}
				
				if (clearRouteBtn) {
					clearRouteBtn.style.display = window.routeState.showRoute ? 'inline-block' : 'none';
				}
			}
			console.log('‚úÖ Route consistency ensured:', window.routeState);
			*/
		}
		
		
		// üîß v1.1 ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á gallery elements ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ
		function ensureGalleryElements() {
			console.log('üîç Checking gallery elements...');
			
			let galleryContainer = document.getElementById('overlayRoomGallery');
			let gallery = document.getElementById('roomGalleryImages');
			
			// ‡∏´‡∏≤‡∏Å overlayRoomGallery ‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
			if (!galleryContainer) {
				console.log('üî® Creating overlayRoomGallery element...');
				
				// ‡∏´‡∏≤ roomDetails container ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° gallery
				const roomDetails = document.getElementById('roomDetails');
				if (roomDetails) {
					galleryContainer = document.createElement('div');
					galleryContainer.id = 'overlayRoomGallery';
					galleryContainer.style.cssText = `
						max-height: 400px;
						overflow-y: auto;
						border: 1px solid var(--border-color, #ddd);
						border-radius: 8px;
						padding: 15px;
						background: var(--background-color, #fff);
						margin-top: 15px;
						display: none;
					`;
					roomDetails.appendChild(galleryContainer);
					console.log('‚úÖ Created overlayRoomGallery');
				}
			}
			
			// ‡∏´‡∏≤‡∏Å roomGalleryImages ‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
			if (!gallery && galleryContainer) {
				console.log('üî® Creating roomGalleryImages element...');
				
				gallery = document.createElement('div');
				gallery.id = 'roomGalleryImages';
				gallery.style.cssText = `
					display: block;
					width: 100%;
				`;
				galleryContainer.appendChild(gallery);
				console.log('‚úÖ Created roomGalleryImages');
			}
			
			return { galleryContainer, gallery };
		}

     // üîß v1.1 ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô updateOverlayImageGallery  
		function updateOverlayImageGallery(room) {
			console.log(`üñºÔ∏è Processing images for room ${room.code}:`, room);
			
			// ‚úÖ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ gallery elements ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
			let gallery = document.getElementById('overlayImageGallery');
			let galleryContainer = document.getElementById('overlayRoomGallery');
			
			// ‡∏´‡∏≤‡∏Å overlayImageGallery ‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ roomGalleryImages ‡πÅ‡∏ó‡∏ô
			if (!gallery) {
				gallery = document.getElementById('roomGalleryImages');
				console.log('üîç Using roomGalleryImages as fallback gallery');
			}
			
			// ‡∏´‡∏≤‡∏Å galleryContainer ‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á
			if (!galleryContainer) {
				console.log('üî® Creating overlayRoomGallery element...');
				
				// ‡∏´‡∏≤ roomDetails container ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° gallery
				const roomDetails = document.getElementById('roomDetails') || 
								   document.getElementById('overlayContent') ||
								   document.querySelector('.room-info-content');
				
				if (roomDetails) {
					galleryContainer = document.createElement('div');
					galleryContainer.id = 'overlayRoomGallery';
					galleryContainer.style.cssText = `
						max-height: 400px;
						overflow-y: auto;
						border: 1px solid var(--border-color, #ddd);
						border-radius: 8px;
						padding: 15px;
						background: var(--background-color, #fff);
						margin-top: 15px;
						display: block !important;
						visibility: visible !important;
					`;
					roomDetails.appendChild(galleryContainer);
					console.log('‚úÖ Created overlayRoomGallery');
				}
			}
			
			// ‡∏´‡∏≤‡∏Å gallery ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á
			if (!gallery && galleryContainer) {
				console.log('üî® Creating gallery element...');
				gallery = document.createElement('div');
				gallery.id = 'overlayImageGallery';
				gallery.style.cssText = 'display: block !important; width: 100%; visibility: visible !important;';
				galleryContainer.appendChild(gallery);
				console.log('‚úÖ Created overlayImageGallery');
			}
			
			if (!gallery || !galleryContainer) {
				console.error('‚ùå Cannot create gallery elements');
				return;
			}

			// üîç Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• room structure 
			console.log('üè† Room data structure:', {
				code: room.code,
				name: room.name,
				images: room.images,
				image_urls: room.image_urls,
				images_type: typeof room.images,
				images_length: Array.isArray(room.images) ? room.images.length : 'not array'
			});

			// ‚úÖ Fixed: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ images array ‡∏ó‡∏µ‡πà‡∏°‡∏µ JSON string
			let imageUrls = [];
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö room.images ‡∏Å‡πà‡∏≠‡∏ô (‡∏à‡∏≤‡∏Å log ‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ images)
			if (room.images && Array.isArray(room.images)) {
				console.log('üîç Processing room.images array:', room.images);
				
				room.images.forEach((item, index) => {
					console.log(`üîç Processing images[${index}]:`, item, 'type:', typeof item);
					
					if (typeof item === 'string' && item.trim()) {
						// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô JSON array string ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
						if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
							try {
								const parsed = JSON.parse(item.trim());
								if (Array.isArray(parsed)) {
									const validUrls = parsed.filter(url => url && typeof url === 'string' && url.trim());
									imageUrls.push(...validUrls);
									console.log(`‚úÖ Parsed JSON array from images[${index}], found ${validUrls.length} URLs:`, validUrls);
								}
							} catch (e) {
								console.warn(`‚ö†Ô∏è Failed to parse JSON from images[${index}]:`, e.message);
								// ‡∏ñ‡πâ‡∏≤ parse ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô URL ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
								if (isValidImageUrl(item.trim())) {
									imageUrls.push(item.trim());
								}
							}
						} else if (isValidImageUrl(item.trim())) {
							// URL ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
							imageUrls.push(item.trim());
						}
					}
				});
			}
			
			// Fallback: ‡∏•‡∏≠‡∏á room.image_urls ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ images
			if (imageUrls.length === 0 && room.image_urls) {
				console.log('üîç Fallback to room.image_urls:', room.image_urls);
				// ‡πÉ‡∏ä‡πâ logic ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
				if (Array.isArray(room.image_urls)) {
					room.image_urls.forEach((item, index) => {
						if (typeof item === 'string' && item.trim()) {
							if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
								try {
									const parsed = JSON.parse(item.trim());
									if (Array.isArray(parsed)) {
										imageUrls.push(...parsed.filter(url => url && typeof url === 'string' && url.trim()));
									}
								} catch (e) {
									if (isValidImageUrl(item.trim())) {
										imageUrls.push(item.trim());
									}
								}
							} else if (isValidImageUrl(item.trim())) {
								imageUrls.push(item.trim());
							}
						}
					});
				}
			}

			console.log(`üñºÔ∏è Total imageUrls parsed: ${imageUrls.length}`);
			imageUrls.forEach((url, index) => {
				console.log(`üñºÔ∏è URL ${index + 1}:`, url);
			});

			if (!imageUrls || imageUrls.length === 0) {
				galleryContainer.style.display = 'none';
				gallery.innerHTML = '';
				console.log('üì∑ No images to display - hiding gallery');
				return;
			}

			// ‚úÖ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ï‡πà‡∏•‡∏∞ URL ‡πÅ‡∏¢‡∏Å‡∏Å‡∏±‡∏ô
			const processedImages = [];
			
			imageUrls.forEach((url, index) => {
				console.log(`üîÑ Processing individual URL ${index + 1}:`, url);
				
				if (!url || typeof url !== 'string') {
					console.log(`‚ö†Ô∏è Skipping invalid URL at index ${index}:`, url);
					return;
				}
				
				// ‡∏™‡πà‡∏á URL ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÑ‡∏õ‡∏¢‡∏±‡∏á processImageUrl (‡∏´‡∏≤‡∏Å‡∏°‡∏µ function ‡∏ô‡∏µ‡πâ)
				let processedUrl = url; // fallback ‡πÉ‡∏ä‡πâ original URL
				if (typeof processImageUrl === 'function') {
					processedUrl = processImageUrl(url);
					console.log(`üîÑ processImageUrl result for "${url}":`, processedUrl);
				} else {
					console.log(`‚ö†Ô∏è processImageUrl function not found, using original URL`);
				}
				
				if (processedUrl) {
					processedImages.push({
						original: url,
						processed: processedUrl,
						index: processedImages.length
					});
					console.log(`‚úÖ Added processed image ${processedImages.length}: "${url}" -> "${processedUrl}"`);
				} else {
					console.log(`‚ùå Rejected URL ${index + 1}: "${url}"`);
				}
			});

			console.log(`üìä Final processed images: ${processedImages.length} out of ${imageUrls.length} URLs`);

			if (processedImages.length === 0) {
				galleryContainer.style.display = 'block';
				gallery.innerHTML = `
					<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
						<i class="fas fa-exclamation-triangle" style="font-size: 48px; opacity: 0.3; margin-bottom: 15px; color: orange;"></i>
						<p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ</p>
						<small style="display: block; margin-top: 10px; opacity: 0.7; font-family: monospace;">
							Raw images: ${JSON.stringify(room.images)}<br>
							Parsed URLs: ${imageUrls.length}<br>
							Room: ${room.code}
						</small>
					</div>
				`;
				return;
			}

			// üé® ‡∏™‡∏£‡πâ‡∏≤‡∏á HTML ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Gallery - ‡πÑ‡∏°‡πà‡∏°‡∏µ crossorigin ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° referrerpolicy
			galleryContainer.style.display = 'block';
			galleryContainer.style.visibility = 'visible';
			
			const galleryHTML = processedImages.map((imageData, index) => {
				const imgId = `gallery-img-${room.code}-${index}`;
				const escapedProcessed = imageData.processed.replace(/'/g, "\\'");
				const escapedRoomName = room.name.replace(/'/g, "\\'");
				const escapedOriginal = imageData.original.replace(/'/g, "\\'");
				
				return `
				<div class="gallery-item" style="position: relative; margin-bottom: 15px; display: block !important; visibility: visible !important;">
					<img id="${imgId}"
						 src="${imageData.processed}" 
						 alt="Room image ${index + 1}" 
						 style="width: 100%; border-radius: 8px; cursor: pointer; display: block !important; visibility: visible !important;"
						 referrerpolicy="no-referrer-when-downgrade"
						 onclick="openImageModal && openImageModal('${escapedProcessed}', '${escapedRoomName}')"
						 onerror="handleImageError(this, '${escapedOriginal}', ${imageData.index})"
						 onload="handleImageSuccess(this, ${imageData.index})">
					<div class="image-error-fallback" style="display: none; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; color: var(--text-secondary);">
						<i class="fas fa-broken-image"></i>
						<p>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ</p>
						<small style="font-family: monospace; font-size: 11px; opacity: 0.7;">
							Original: ${imageData.original}<br>
							Processed: ${imageData.processed}<br>
							Index: ${imageData.index}
						</small>
					</div>
				</div>`;
			}).join('');
			
			gallery.innerHTML = galleryHTML;
			gallery.style.display = 'block';
			gallery.style.visibility = 'visible';
			
			console.log(`‚úÖ Gallery HTML created with ${processedImages.length} images`);
			console.log(`‚úÖ Displayed ${processedImages.length}/${imageUrls.length} valid images in overlay gallery`);
			
			// üîß Debug gallery visibility
			setTimeout(() => {
				const galleryItems = gallery.querySelectorAll('.gallery-item');
				console.log(`üîç Gallery Debug:`, {
					galleryDisplay: galleryContainer.style.display,
					galleryVisible: galleryContainer.style.visibility,
					itemsCount: galleryItems.length,
					firstItemVisible: galleryItems[0] ? galleryItems[0].style.display : 'no items',
					containerInDOM: !!document.getElementById('overlayRoomGallery')
				});
			}, 1000);
		}
		
		// V1.1 üîß ‡πÄ‡∏û‡∏¥‡πà‡∏° Missing Image Handler Functions
		function handleImageSuccess(imgElement, index) {
			console.log(`‚úÖ Image ${index + 1} loaded successfully:`, {
				src: imgElement.src,
				naturalWidth: imgElement.naturalWidth,
				naturalHeight: imgElement.naturalHeight,
				display: imgElement.style.display,
				visibility: imgElement.style.visibility,
				parentVisible: imgElement.parentElement ? imgElement.parentElement.style.display : 'unknown'
			});
			
			// üîß Force image to be visible
			imgElement.style.display = 'block';
			imgElement.style.visibility = 'visible';
			imgElement.style.opacity = '1';
			
			// ‡∏ã‡πà‡∏≠‡∏ô loading indicator ‡∏´‡∏≤‡∏Å‡∏°‡∏µ
			const container = imgElement.closest('.gallery-item');
			if (container) {
				const loadingIndicator = container.querySelector('.loading-indicator');
				if (loadingIndicator) {
					loadingIndicator.style.display = 'none';
				}
				
				// üîß Force container to be visible
				container.style.display = 'block';
				container.style.visibility = 'visible';
			}
			
			// üîß Force gallery container to be visible
			const galleryContainer = document.getElementById('overlayRoomGallery') || 
									document.getElementById('overlayImageGallery');
			if (galleryContainer) {
				galleryContainer.style.display = 'block';
				galleryContainer.style.visibility = 'visible';
				console.log('üîß Forced gallery container to be visible');
			}
		}

		// V1.1
		function handleImageError(imgElement, originalUrl, index) {
			console.error(`‚ùå Image ${index + 1} failed to load:`, originalUrl);
			
			// üîß Check if this is a CORS error and if retry mechanism exists
			if (originalUrl.includes('retry=')) {
				console.log('‚ö†Ô∏è Image failed even after retry, showing fallback');
				
				// ‡πÅ‡∏™‡∏î‡∏á error fallback
				const container = imgElement.closest('.gallery-item');
				if (container) {
					const errorFallback = container.querySelector('.image-error-fallback');
					if (errorFallback) {
						imgElement.style.display = 'none';
						errorFallback.style.display = 'block';
					} else {
						// ‡∏™‡∏£‡πâ‡∏≤‡∏á fallback ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ
						container.innerHTML = `
							<div style="text-align: center; padding: 20px; border: 2px dashed #dc3545; 
										border-radius: 8px; background: rgba(220, 53, 69, 0.1);">
								<i class="fas fa-broken-image" style="font-size: 24px; color: #dc3545; margin-bottom: 8px;"></i>
								<p style="color: #dc3545; margin: 0; font-size: 12px;">‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ</p>
								<small style="color: #666;">CORS Policy ‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï</small>
							</div>
						`;
					}
				}
			} else {
				// üîß Let existing retry mechanism handle first failure
				console.log('üîÑ Letting existing retry mechanism handle this error');
			}
		}

       // üîß v1.1 . Enhanced Image Modal Function
		function openImageModal(imageUrl, roomName) {
			const modal = document.createElement('div');
			modal.style.cssText = `
				position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
				background: rgba(0,0,0,0.9); display: flex; align-items: center; 
				justify-content: center; z-index: 10000; cursor: pointer;
			`;
			
			modal.innerHTML = `
				<div style="position: relative; max-width: 90%; max-height: 90%;" onclick="event.stopPropagation()">
					<img src="${imageUrl}" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 8px;"
						 onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
					<div style="display: none; text-align: center; padding: 40px; background: #fff; border-radius: 8px; color: #333;">
						<i class="fas fa-broken-image" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
						<p>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ</p>
					</div>
					<div style="text-align: center; color: white; margin-top: 10px; font-size: 14px;">
						${roomName} - ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏´‡πâ‡∏≠‡∏á
					</div>
					<button onclick="this.closest('div').parentElement.remove()" 
							style="position: absolute; top: -10px; right: -10px; background: #dc3545; color: white; 
								   border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">√ó</button>
				</div>
			`;
			
			modal.onclick = () => modal.remove();
			document.body.appendChild(modal);
		}

        // =================== Event Setup ===================
        
       // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô setupMapEvents ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡πÑ‡∏ß‡πâ
		function setupMapEvents() {
			const mapArea = document.getElementById('mapArea');
			if (!mapArea) return;
			
			mapArea.addEventListener('click', function(event) {
				// ‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà room markers ‡∏´‡∏£‡∏∑‡∏≠ action overlay
				if (event.target.classList.contains('room-marker') || 
					event.target.closest('.room-action-overlay')) {
					return;
				}
				
				// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
				const rect = mapArea.getBoundingClientRect();
				const x = ((event.clientX - rect.left) / rect.width) * 100;
				const y = ((event.clientY - rect.top) / rect.height) * 100;
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï
				if (x >= 0 && x <= 100 && y >= 0 && y <= 100) {
					// ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
					if (routeDisplayed) {
						clearRoute();
					}
					
					// ‡∏ï‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô selectedRoom)
					const oldStartPoint = startPoint;
					startPoint = {
						name: currentLanguage === 'th' ? '‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô' : 'Starting Point',
						x: x,
						y: y
					};
					
					localStorage.setItem('startPoint', JSON.stringify(startPoint));
					
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï markers ‡πÇ‡∏î‡∏¢‡∏£‡∏±‡∏Å‡∏©‡∏≤ selectedRoom ‡πÑ‡∏ß‡πâ
					updateRoomMarkers(); 
					updateRouteControls(false);
					
					const message = currentLanguage === 'th' 
						? `üéØ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà (${Math.round(x)}, ${Math.round(y)})`
						: `üéØ Start point updated (${Math.round(x)}, ${Math.round(y)})`;
					showNotification(message, 'success');
					
					// ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß
					if (selectedRoom && roomData[selectedRoom]) {
						setTimeout(() => {
							showRouteToSelected();
							
							// ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ß‡πà‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß
							const routeMessage = currentLanguage === 'th' 
								? `üõ£Ô∏è ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡∏¢‡∏±‡∏á ${roomData[selectedRoom].name}`
								: `üõ£Ô∏è New route to ${roomData[selectedRoom].name}`;
							setTimeout(() => {
								showNotification(routeMessage, 'info');
							}, 1000);
						}, 500);
					} else {
						// ‡πÅ‡∏à‡πâ‡∏á‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô
						setTimeout(() => {
							const searchMessage = currentLanguage === 'th' 
								? 'üí° ‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏î‡∏π‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á'
								: 'üí° Go to search page to select destination room, then return to view route';
							showNotification(searchMessage, 'info');
						}, 1000);
					}
				}
			});
		}
		
		
		

        function setupWindowEvents() {
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    updateRoomMarkers();
                }, 500);
            });

            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateRoomMarkers();
                }, 250);
            });

            window.addEventListener('beforeunload', function(e) {
                if (startPoint) {
                    localStorage.setItem('startPoint', JSON.stringify(startPoint));
                }
            });

            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                    e.preventDefault();
                    const searchInput = document.getElementById('searchInput');
                    if (searchInput) {
                        searchInput.focus();
                    }
                }
                
                if (e.key === 'Escape') {
                    closeRoomInfoOverlay();
                    
                    const imageModal = document.querySelector('div[style*="position: fixed"][style*="background: rgba(0,0,0,0.9)"]');
                    if (imageModal) {
                        imageModal.remove();
                    }
                    
                    if (isVoiceNavigating) {
                        stopVoiceNavigation();
                    }
                }
                
                if (e.key === ' ' && isVoiceNavigating) {
                    e.preventDefault();
                    stopVoiceNavigation();
                }
            });
        }


		// ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		async function loadMapDataFromSheets() {
			if (currentVersion !== 'live' || !sheetsConfig.url) {
				console.log('üó∫Ô∏è Not loading map images (Demo mode or no sheets URL)');
				return;
			}
			
			try {
				console.log('üó∫Ô∏è Loading map images from Google Sheets...');
				showProgressiveStatus('üó∫Ô∏è ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà...', 'info');
				
				// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° timeout ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö map images
				const controller = new AbortController();
				const timeoutId = setTimeout(() => {
					controller.abort();
					console.log('‚è∞ Map images request timeout');
				}, 20000); // 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û
				
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', sheetsConfig.mapImagesSheet);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString(),
					signal: controller.signal
				});
				
				clearTimeout(timeoutId);
				
				if (response.ok) {
					const result = await response.json();
					console.log('üó∫Ô∏è Map images response received');
					
					if (result.success && result.data && result.data.length > 0) {
						let sheetMapData = result.data.find(item => 
							item.id === 'main_map' || item.id === 'maps'
						);
						
						if (!sheetMapData && result.data.length > 0) {
							sheetMapData = result.data[0];
						}
						
						if (sheetMapData) {
							// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
							if (sheetMapData.floorplan) {
								mapData.floorplan = sheetMapData.floorplan;
								console.log('‚úÖ Floorplan loaded from sheets');
							}
							if (sheetMapData.realphoto) {
								mapData.realphoto = sheetMapData.realphoto;
								console.log('‚úÖ Real photo loaded from sheets');
							}
							if (sheetMapData.notes) {
								mapData.notes = sheetMapData.notes;
							}
							
							mapData.loaded = true;
							
							// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ö‡∏µ‡∏ö‡∏≠‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà
							const cacheSuccess = safeSetCachedData('mapImages', mapData);
							if (!cacheSuccess) {
								console.warn('‚ö†Ô∏è Map images too large to cache, using session storage');
							}
							
							updateMapDisplay();
							showProgressiveStatus('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
							
							console.log('‚úÖ Map images loaded successfully');
						} else {
							console.log('‚ö†Ô∏è No map data found in sheets');
							showProgressiveStatus('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà', 'warning');
						}
					} else {
						console.log('‚ö†Ô∏è No map images data in response');
						showProgressiveStatus('‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà', 'warning');
					}
				} else {
					console.error('‚ùå Failed to fetch map images:', response.status);
					showProgressiveStatus('‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß', 'error');
				}
			} catch (error) {
				if (error.name === 'AbortError') {
					console.error('‚è∞ Map images request timeout');
					showProgressiveStatus('‚è∞ ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ', 'warning');
				} else {
					console.error('‚ùå Error loading map images:', error);
					showProgressiveStatus('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà', 'error');
				}
			}
		}

		// ======= ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		function updateMapDisplay() {
			const mapImage = document.getElementById('mapImage');
			if (!mapImage) return;
			
			let imageToShow = null;
			
			// ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏û‡∏ï‡∏≤‡∏° layout ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
			if (currentMapLayout === 'photo' && mapData.realphoto) {
				imageToShow = mapData.realphoto;
				console.log('üó∫Ô∏è Displaying real photo');
			} else if (currentMapLayout === 'floorplan' && mapData.floorplan) {
				imageToShow = mapData.floorplan;
				console.log('üó∫Ô∏è Displaying floorplan');
			}
			
			if (imageToShow) {
				mapImage.src = imageToShow;
				mapImage.onerror = function() {
					console.error('‚ùå Failed to load map image:', imageToShow);
					showFallbackMap();
				};
				mapImage.onload = function() {
					console.log('‚úÖ Map image loaded successfully');
				};
			} else {
				// ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà default ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
				showFallbackMap();
			}
		}

		// ======= ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà default ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏†‡∏≤‡∏û =======
		function showFallbackMap() {
			const mapImage = document.getElementById('mapImage');
			if (!mapImage) return;
			
			const fallbackText = currentMapLayout === 'photo' ? '‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á' : '‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á';
			const missingText = currentLanguage === 'th' 
				? `‡πÑ‡∏°‡πà‡∏°‡∏µ${fallbackText}` 
				: `No ${currentMapLayout} available`;
			
			mapImage.src = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='600' viewBox='0 0 800 600'%3E%3Crect width='800' height='600' fill='%23f0f8ff'/%3E%3Ctext x='400' y='280' text-anchor='middle' font-family='Arial' font-size='28' fill='%23667eea' font-weight='bold'%3Eüè´ ${encodeURIComponent('‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞')}%3C/text%3E%3Ctext x='400' y='320' text-anchor='middle' font-family='Arial' font-size='16' fill='%23999'%3E${encodeURIComponent(missingText)}%3C/text%3E%3Ctext x='400' y='350' text-anchor='middle' font-family='Arial' font-size='14' fill='%23667eea'%3Eüìç ${encodeURIComponent('‡∏Ñ‡∏•‡∏¥‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á')}%3C/text%3E%3C/svg%3E`;
		}

		// ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô setMapLayout ‡πÄ‡∏î‡∏¥‡∏° =======
		function setMapLayout(layout) {
			currentMapLayout = layout;
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI ‡∏õ‡∏∏‡πà‡∏°
			document.querySelectorAll('.map-control-btn[data-layout]').forEach(btn => {
				btn.classList.remove('active');
			});
			
			const targetBtn = document.querySelector(`[data-layout="${layout}"]`);
			if (targetBtn) {
				targetBtn.classList.add('active');
			}
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
			updateMapDisplay();
			
			// ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
			const layoutName = layout === 'photo' 
				? (currentLanguage === 'th' ? '‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á' : 'Real Photo')
				: (currentLanguage === 'th' ? '‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á' : 'Floor Plan');
			
			showNotification(
				currentLanguage === 'th' ? `üó∫Ô∏è ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô${layoutName}` : `üó∫Ô∏è Switched to ${layoutName}`,
				'info'
			);
		}
		
		// ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Session Storage ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Map Images =======
		function loadMapFromSessionStorage() {
			try {
				const floorplan = sessionStorage.getItem('temp_floorplan');
				const realphoto = sessionStorage.getItem('temp_realphoto');
				
				if (floorplan) {
					mapData.floorplan = floorplan;
				}
				if (realphoto) {
					mapData.realphoto = realphoto;
				}
				
				if (floorplan || realphoto) {
					mapData.loaded = true;
					updateMapDisplay();
					console.log('üó∫Ô∏è Map images loaded from session storage');
				}
			} catch (error) {
				console.warn('‚ö†Ô∏è Could not load map images from session storage:', error);
			}
		}

		// ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ session storage ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏∞‡∏ö‡∏ö =======
		async function initializeMapImages() {
			console.log('üó∫Ô∏è Initializing map images...');
			
			// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å session storage ‡∏Å‡πà‡∏≠‡∏ô
			loadMapFromSessionStorage();
			
			// ‡∏ñ‡πâ‡∏≤ session storage ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å cache/sheets
			if (mapData.loaded && (mapData.floorplan || mapData.realphoto)) {
				console.log('üíæ Map images available from session storage');
				return;
			}
			
			// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å cache
			if (isCacheValid('mapImages', 60 * 60 * 1000)) { // 1 hour cache
				const cachedMapData = getCachedData('mapImages');
				if (cachedMapData && !cachedMapData.compressed) {
					mapData = { ...mapData, ...cachedMapData };
					updateMapDisplay();
					console.log('üíæ Map images loaded from cache');
					return;
				} else if (cachedMapData && cachedMapData.compressed) {
					console.log('üóúÔ∏è Found compressed cache, loading from session storage');
					loadMapFromSessionStorage();
					return;
				}
			}
			
			// ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å Google Sheets (Live mode ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)
			if (currentVersion === 'live') {
				await loadMapDataFromSheets();
			} else {
				console.log('üéÆ Demo mode: Using default map images');
				showFallbackMap();
			}
		}

		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£ Debug ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà =======
		function debugMapImages() {
			console.log('üîç === MAP IMAGES DEBUG ===');
			console.log('Current version:', currentVersion);
			console.log('Current layout:', currentMapLayout);
			console.log('Map data:', {
				hasFloorplan: !!mapData.floorplan,
				hasRealPhoto: !!mapData.realphoto,
				loaded: mapData.loaded,
				floorplanLength: mapData.floorplan ? mapData.floorplan.length : 0,
				realPhotoLength: mapData.realphoto ? mapData.realphoto.length : 0
			});
			console.log('Sheets config:', {
				url: sheetsConfig.url ? 'SET' : 'NOT SET',
				mapImagesSheet: sheetsConfig.mapImagesSheet
			});
			
			const mapImage = document.getElementById('mapImage');
			if (mapImage) {
				console.log('Map image element:', {
					src: mapImage.src.substring(0, 100) + '...',
					naturalWidth: mapImage.naturalWidth,
					naturalHeight: mapImage.naturalHeight
				});
			}
		}
		// ===== 8. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô debug ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤ =====
		// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏ô console: debugCurrentState()
			function debugCurrentState() {
				console.group('üêõ Current Route State Debug');
				console.log('üìç startPoint:', startPoint);
				console.log('üéØ selectedRoom:', selectedRoom);
				console.log('üíæ persistentDestination:', persistentDestination);
				console.log('üõ£Ô∏è routeDisplayed:', routeDisplayed);
				console.log('üì± currentRoute:', currentRoute);
				console.log('üóÉÔ∏è localStorage destination:', localStorage.getItem('persistentDestination'));
				console.log('üóÉÔ∏è localStorage startPoint:', localStorage.getItem('startPoint'));
				console.log('üîç Route elements on page:', document.querySelectorAll('.route-line, .route-marker').length);
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏ï‡πà‡∏≤‡∏á‡πÜ
				const showBtn = document.getElementById('showRouteBtn');
				const clearBtn = document.getElementById('clearRouteBtn');
				console.log('üéÆ Show button:', showBtn ? { disabled: showBtn.disabled, display: showBtn.style.display } : 'Not found');
				console.log('üéÆ Clear button:', clearBtn ? { display: clearBtn.style.display } : 'Not found');
				
				console.groupEnd();
			}



		// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Toggle Usage Guide
		function toggleUsageGuide() {
			const content = document.getElementById('usageGuideContent');
			const toggleText = document.getElementById('usageGuideToggleText');
			const chevron = document.getElementById('usageGuideChevron');
			
			if (!content || !toggleText || !chevron) return;
			
			const isHidden = content.style.display === 'none';
			
			if (isHidden) {
				// Show content
				content.style.display = 'block';
				toggleText.innerHTML = `<span data-translate="hide_usage_guide">‡∏ã‡πà‡∏≠‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>`;
				chevron.style.transform = 'rotate(180deg)';
				
				// Update translation
				const hideText = currentLanguage === 'th' ? '‡∏ã‡πà‡∏≠‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : 'Hide Usage Guide';
				toggleText.textContent = hideText;
				
				showNotification(
					currentLanguage === 'th' ? 'üìñ ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : 'üìñ Usage guide shown',
					'info'
				);
			} else {
				// Hide content
				content.style.display = 'none';
				toggleText.innerHTML = `<span data-translate="show_usage_guide">‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>`;
				chevron.style.transform = 'rotate(0deg)';
				
				// Update translation
				const showText = currentLanguage === 'th' ? '‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : 'Show Usage Guide';
				toggleText.textContent = showText;
				
				showNotification(
					currentLanguage === 'th' ? 'üìñ ‡∏ã‡πà‡∏≠‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô' : 'üìñ Usage guide hidden',
					'info'
				);
			}
		}
		
		
		// üîß V1.1  Enhanced Image URL Validation Function
		function isValidImageUrl(url) {
			if (!url || typeof url !== 'string') return false;
			
			const trimmedUrl = url.trim();
			if (trimmedUrl === '') return false;
			
			// ‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡πà‡∏≤ placeholder
			const invalidValues = ['available', 'none', 'null', 'undefined', 'error', 'pending', '[]', '{}', 'N/A'];
			if (invalidValues.includes(trimmedUrl.toLowerCase())) {
				return false;
			}
			
			// Data URLs ‡πÅ‡∏•‡∏∞ HTTP/HTTPS URLs
			if (trimmedUrl.startsWith('data:image/') || 
				trimmedUrl.startsWith('http://') || 
				trimmedUrl.startsWith('https://')) {
				return true;
			}
			
			// Web Server - relative paths ‡πÅ‡∏•‡∏∞ extensions
			if (Environment.isWebServer) {
				if (trimmedUrl.startsWith('./') || 
					trimmedUrl.startsWith('../') || 
					trimmedUrl.startsWith('/') ||
					trimmedUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
					return true;
				}
			}
			
			return false;
		}
			
		// üîß v1.1  Enhanced Image URL Processing Function
		function processImageUrl(url) {
			console.log('üîÑ processImageUrl input:', url);
			
			if (!url || typeof url !== 'string') {
				console.log('‚ùå processImageUrl: Invalid input');
				return null;
			}
			
			// ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î URL
			let cleanedUrl = url.trim()
				.replace(/^["'\[\]]+|["'\[\]]+$/g, '')
				.replace(/\\"/g, '"')
				.trim();
			
			console.log('üßπ Cleaned URL:', cleanedUrl);
			
			if (!isValidImageUrl(cleanedUrl)) {
				console.log('‚ùå processImageUrl: URL validation failed');
				return null;
			}
			
			// HTTP/HTTPS URLs ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
			if (cleanedUrl.startsWith('http://') || cleanedUrl.startsWith('https://')) {
				console.log('‚úÖ processImageUrl: HTTP/HTTPS URL accepted');
				return cleanedUrl;
			}
			
			// Data URLs
			if (cleanedUrl.startsWith('data:')) {
				console.log('‚úÖ processImageUrl: Data URL accepted');
				return cleanedUrl;
			}
			
			// Web Server - relative paths
			if (Environment.isWebServer) {
				if (cleanedUrl.startsWith('./') || cleanedUrl.startsWith('../')) {
					console.log('‚úÖ processImageUrl: Relative path accepted');
					return cleanedUrl;
				}
				if (cleanedUrl.startsWith('/')) {
					console.log('‚úÖ processImageUrl: Absolute path accepted');
					return cleanedUrl;
				}
				if (cleanedUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
					const result = './' + cleanedUrl;
					console.log('‚úÖ processImageUrl: Added relative path prefix:', result);
					return result;
				}
			}
			
			console.log('‚úÖ processImageUrl: Using original URL');
			return cleanedUrl;
		}
	
		// v1.1üîß Enhanced parseImageUrls Function - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£ parse JSON array
		function parseImageUrls(input) {
			console.log('üîç parseImageUrls input:', input, 'type:', typeof input);
			
			if (!input) {
				console.log('‚ùå parseImageUrls: No input provided');
				return [];
			}
			
			let result = [];
			
			// ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô Array ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
			if (Array.isArray(input)) {
				// üÜï ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ element ‡πÉ‡∏ô array ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô JSON string ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
				const flattenedUrls = [];
				
				input.forEach((item, index) => {
					console.log(`üîç Processing array item ${index}:`, item, 'type:', typeof item);
					
					if (typeof item === 'string' && item.trim()) {
						// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô JSON array string ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
						if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
							try {
								const parsed = JSON.parse(item.trim());
								if (Array.isArray(parsed)) {
									flattenedUrls.push(...parsed.filter(url => url && typeof url === 'string' && url.trim()));
									console.log(`‚úÖ parseImageUrls: Parsed nested JSON from item ${index}, found ${parsed.length} URLs`);
								}
							} catch (e) {
								console.warn(`‚ö†Ô∏è parseImageUrls: Failed to parse JSON from item ${index}:`, e.message);
								// ‡∏ñ‡πâ‡∏≤ parse ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô URL ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
								flattenedUrls.push(item.trim());
							}
						} else {
							// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà JSON ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô URL ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
							flattenedUrls.push(item.trim());
						}
					}
				});
				
				result = flattenedUrls.filter(url => url && typeof url === 'string' && url.trim());
				console.log('‚úÖ parseImageUrls: Array processed, flattened to', result.length, 'URLs');
				return result;
			}
			
			// ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô String
			if (typeof input === 'string') {
				const trimmed = input.trim();
				
				if (!trimmed) {
					console.log('‚ùå parseImageUrls: Empty string input');
					return [];
				}
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô JSON array ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
				if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
					try {
						const parsed = JSON.parse(trimmed);
						if (Array.isArray(parsed)) {
							result = parsed.filter(url => url && typeof url === 'string' && url.trim());
							console.log('‚úÖ parseImageUrls: JSON array parsed, found', result.length, 'URLs');
							return result;
						}
					} catch (e) {
						console.warn('‚ö†Ô∏è parseImageUrls: JSON parse failed, trying alternative methods:', e.message);
						
						// ‡∏•‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç JSON ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢
						try {
							let fixedJson = trimmed
								.replace(/^[\[\s]*"?/, '["')  // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
								.replace(/"?\s*\]$/, '"]')    // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
								.replace(/",\s*"/g, '","')   // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç spacing ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á URLs
								.replace(/"\s*,\s*"/g, '","'); // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç spacing ‡∏≠‡∏µ‡∏Å‡∏£‡∏≠‡∏ö
							
							const parsed = JSON.parse(fixedJson);
							if (Array.isArray(parsed)) {
								result = parsed.filter(url => url && typeof url === 'string' && url.trim());
								console.log('‚úÖ parseImageUrls: Fixed JSON parsed, found', result.length, 'URLs');
								return result;
							}
						} catch (e2) {
							console.warn('‚ö†Ô∏è parseImageUrls: JSON fix failed:', e2.message);
						}
					}
				}
				
				// ‡∏•‡∏≠‡∏á‡πÅ‡∏¢‡∏Å‡∏î‡πâ‡∏ß‡∏¢ comma ‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
				if (trimmed.includes(',')) {
					result = trimmed
						.split(',')
						.map(url => url.trim().replace(/^["'\[\]]+|["'\[\]]+$/g, ''))
						.filter(url => url && isValidImageUrl(url));
					
					console.log('‚úÖ parseImageUrls: Comma-separated parsed, found', result.length, 'URLs');
					return result;
				}
				
				// URL ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
				if (isValidImageUrl(trimmed)) {
					console.log('‚úÖ parseImageUrls: Single URL detected');
					return [trimmed];
				}
			}
			
			console.log('‚ùå parseImageUrls: Could not parse input');
			return [];
		}
		
		// v1.1
        function isValidImageUrl(url) {
			if (!url || typeof url !== 'string') return false;
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö HTTP/HTTPS URLs
			if (url.match(/^https?:\/\/.+\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
				return true;
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Data URLs
			if (url.startsWith('data:image/')) {
				return true;
			}
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö relative paths
			if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
				return true;
			}
			
			return false;
		}   
		
	
		// v1.1üîß ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç showRoomGallery Function
		function showRoomGallery(room) {
			console.log('üéØ showRoomGallery called with room:', room);
			
			// ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á elements ‡∏´‡∏≤‡∏Å‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
			const { galleryContainer, gallery } = ensureGalleryElements();
			
			if (!galleryContainer || !gallery) {
				console.error('‚ùå Cannot create gallery elements');
				return;
			}

			// üîç Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• room structure 
			console.log('üè† Room data structure:', {
				code: room.code,
				name: room.name,
				images: room.images,
				image_urls: room.image_urls,
				images_type: typeof room.images,
				images_length: Array.isArray(room.images) ? room.images.length : 'not array'
			});

			// ‚úÖ Fixed: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ images array ‡∏ó‡∏µ‡πà‡∏°‡∏µ JSON string
			let imageUrls = [];
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö room.images ‡∏Å‡πà‡∏≠‡∏ô (‡∏à‡∏≤‡∏Å log ‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ images)
			if (room.images && Array.isArray(room.images)) {
				console.log('üîç Processing room.images array:', room.images);
				
				room.images.forEach((item, index) => {
					console.log(`üîç Processing images[${index}]:`, item, 'type:', typeof item);
					
					if (typeof item === 'string' && item.trim()) {
						// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô JSON array string ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
						if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
							try {
								const parsed = JSON.parse(item.trim());
								if (Array.isArray(parsed)) {
									const validUrls = parsed.filter(url => url && typeof url === 'string' && url.trim());
									imageUrls.push(...validUrls);
									console.log(`‚úÖ Parsed JSON array from images[${index}], found ${validUrls.length} URLs:`, validUrls);
								}
							} catch (e) {
								console.warn(`‚ö†Ô∏è Failed to parse JSON from images[${index}]:`, e.message);
								// ‡∏ñ‡πâ‡∏≤ parse ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô URL ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
								if (isValidImageUrl && isValidImageUrl(item.trim())) {
									imageUrls.push(item.trim());
								}
							}
						} else if (isValidImageUrl && isValidImageUrl(item.trim())) {
							// URL ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
							imageUrls.push(item.trim());
						}
					}
				});
			}
			
			// Fallback: ‡∏•‡∏≠‡∏á room.image_urls ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ images
			if (imageUrls.length === 0 && room.image_urls) {
				console.log('üîç Fallback to room.image_urls:', room.image_urls);
				// ‡πÉ‡∏ä‡πâ logic ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
				if (Array.isArray(room.image_urls)) {
					room.image_urls.forEach((item, index) => {
						if (typeof item === 'string' && item.trim()) {
							if (item.trim().startsWith('[') && item.trim().endsWith(']')) {
								try {
									const parsed = JSON.parse(item.trim());
									if (Array.isArray(parsed)) {
										imageUrls.push(...parsed.filter(url => url && typeof url === 'string' && url.trim()));
									}
								} catch (e) {
									if (isValidImageUrl && isValidImageUrl(item.trim())) {
										imageUrls.push(item.trim());
									}
								}
							} else if (isValidImageUrl && isValidImageUrl(item.trim())) {
								imageUrls.push(item.trim());
							}
						}
					});
				}
			}

			console.log(`üñºÔ∏è Total imageUrls parsed: ${imageUrls.length}`);
			imageUrls.forEach((url, index) => {
				console.log(`üñºÔ∏è URL ${index + 1}:`, url);
			});

			if (!imageUrls || imageUrls.length === 0) {
				galleryContainer.style.display = 'none';
				gallery.innerHTML = '';
				console.log('üì∑ No images to display - hiding gallery');
				return;
			}

			// ‚úÖ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ï‡πà‡∏•‡∏∞ URL ‡πÅ‡∏¢‡∏Å‡∏Å‡∏±‡∏ô
			const processedImages = [];
			
			imageUrls.forEach((url, index) => {
				console.log(`üîÑ Processing individual URL ${index + 1}:`, url);
				
				if (!url || typeof url !== 'string') {
					console.log(`‚ö†Ô∏è Skipping invalid URL at index ${index}:`, url);
					return;
				}
				
				// ‡∏™‡πà‡∏á URL ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÑ‡∏õ‡∏¢‡∏±‡∏á processImageUrl (‡∏´‡∏≤‡∏Å‡∏°‡∏µ function ‡∏ô‡∏µ‡πâ)
				let processedUrl = url; // fallback ‡πÉ‡∏ä‡πâ original URL
				if (typeof processImageUrl === 'function') {
					processedUrl = processImageUrl(url);
					console.log(`üîÑ processImageUrl result for "${url}":`, processedUrl);
				} else {
					console.log(`‚ö†Ô∏è processImageUrl function not found, using original URL`);
				}
				
				if (processedUrl) {
					processedImages.push({
						original: url,
						processed: processedUrl,
						index: processedImages.length
					});
					console.log(`‚úÖ Added processed image ${processedImages.length}: "${url}" -> "${processedUrl}"`);
				} else {
					console.log(`‚ùå Rejected URL ${index + 1}: "${url}"`);
				}
			});

			console.log(`üìä Final processed images: ${processedImages.length} out of ${imageUrls.length} URLs`);

			if (processedImages.length === 0) {
				galleryContainer.style.display = 'block';
				gallery.innerHTML = `
					<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
						<i class="fas fa-exclamation-triangle" style="font-size: 48px; opacity: 0.3; margin-bottom: 15px; color: orange;"></i>
						<p>‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ</p>
						<small style="display: block; margin-top: 10px; opacity: 0.7; font-family: monospace;">
							Raw images: ${JSON.stringify(room.images)}<br>
							Parsed URLs: ${imageUrls.length}<br>
							Room: ${room.code}
						</small>
					</div>
				`;
				return;
			}

			// üé® ‡∏™‡∏£‡πâ‡∏≤‡∏á HTML ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Gallery
			galleryContainer.style.display = 'block';
			
			const galleryHTML = processedImages.map((imageData, index) => {
				const imgId = `gallery-img-${room.code}-${index}`;
				return `
				<div class="gallery-item" style="position: relative; margin-bottom: 15px;">
					<img id="${imgId}"
						 src="${imageData.processed}" 
						 alt="Room image ${index + 1}" 
						 style="width: 100%; border-radius: 8px; cursor: pointer; display: block;"
						 onclick="openImageModal && openImageModal('${imageData.processed.replace(/'/g, "\\'")}', '${room.name.replace(/'/g, "\\'")}')"
						 onerror="handleImageError && handleImageError(this, '${imageData.original.replace(/'/g, "\\'")}', ${imageData.index})"
						 onload="handleImageSuccess && handleImageSuccess(this, ${imageData.index})"
						 crossorigin="anonymous">
					<div class="image-error-fallback" style="display: none; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; color: var(--text-secondary);">
						<i class="fas fa-broken-image"></i>
						<p>‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ</p>
						<small style="font-family: monospace; font-size: 11px; opacity: 0.7;">
							Original: ${imageData.original}<br>
							Processed: ${imageData.processed}<br>
							Index: ${imageData.index}
						</small>
					</div>
				</div>`;
			}).join('');
			
			gallery.innerHTML = galleryHTML;
			
			console.log(`‚úÖ Gallery HTML created with ${processedImages.length} images`);
			console.log(`‚úÖ Displayed ${processedImages.length}/${imageUrls.length} valid images in overlay gallery`);
		}

		// üîß ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç 4: ‡πÄ‡∏û‡∏¥‡πà‡∏° isValidImageUrl function ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ
		if (typeof isValidImageUrl === 'undefined') {
			function isValidImageUrl(url) {
				if (!url || typeof url !== 'string') return false;
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö HTTP/HTTPS URLs
				if (url.match(/^https?:\/\/.+\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
					return true;
				}
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Data URLs
				if (url.startsWith('data:image/')) {
					return true;
				}
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö relative paths
				if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i)) {
					return true;
				}
				
				return false;
			}
			
			// ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô global function
			window.isValidImageUrl = isValidImageUrl;
		}

        // =================== Initialization ===================
        
			 // ======= ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô - Sync ‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß =======
		async function loadInitialData() {
			const savedLang = localStorage.getItem('preferredLanguage') || 'th';
			currentLanguage = savedLang;
			updateLanguageButton();
			
			// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö caching ‡πÉ‡∏´‡∏°‡πà (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏∞‡∏ö‡∏ö)
			console.log('üöÄ Starting one-time data sync...');
			await loadRoomDataFromAdmin();
			
			// ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)
			await initializeMapImages();
			
			const savedStartPoint = localStorage.getItem('startPoint');
			if (savedStartPoint) {
				try {
					startPoint = JSON.parse(savedStartPoint);
				} catch (error) {
					console.error('Error loading start point:', error);
				}
			}
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï UI
			updateRoomMarkers();
			//updateRouteControls(false);
			updateAllTranslations();
			updateSearchPlaceholder();
			//updateGlobalVersionIndicator(currentVersion);
			loadDestination();
			updateDestinationDisplay();
			
			console.log('‚úÖ One-time sync completed');
			showProgressiveStatus('‚úÖ ‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô', 'success');
		}

		// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏° Debug Command ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Console =======
		window.debugMapImages = debugMapImages;

		
				// ======= ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Performance =======
		function optimizePerformance() {
			// ‡∏•‡πâ‡∏≤‡∏á cache ‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô 24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
			const keys = Object.keys(localStorage);
			const now = Date.now();
			const maxAge = 24 * 60 * 60 * 1000; // 24 hours
			
			keys.forEach(key => {
				if (key.includes('_timestamp_')) {
					const timestamp = localStorage.getItem(key);
					if (timestamp && (now - parseInt(timestamp)) > maxAge) {
						const cacheKey = key.replace('_timestamp_', '_cache_');
						localStorage.removeItem(key);
						localStorage.removeItem(cacheKey);
						console.log(`üóëÔ∏è Removed expired cache: ${cacheKey}`);
					}
				}
			});
			
			// ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ memory
			if (performance.memory) {
				const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
				console.log(`üìä Memory usage: ${used}MB`);
			}
		}

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô Environment detection
			Environment.init();
			
			console.log('üöÄ Gallery system initialized for', Environment.getType());
			
			// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ global error handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö images
			window.addEventListener('error', function(e) {
				if (e.target && e.target.tagName === 'IMG') {
					console.warn('üñºÔ∏è Global image error caught:', e.target.src);
				}
			}, true);
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö gallery (‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ)
			if (!document.getElementById('gallery-styles')) {
				const style = document.createElement('style');
				style.id = 'gallery-styles';
				style.textContent = `
					#overlayRoomGallery {
						max-height: 300px;
						overflow-y: auto;
						border: 1px solid var(--border-color);
						border-radius: 8px;
						padding: 15px;
						background: var(--background-color);
						margin-top: 15px;
					}
					
					.gallery-item img {
						transition: transform 0.2s ease;
					}
					
					.gallery-item img:hover {
						transform: scale(1.02);
					}
					
					.image-error-fallback {
						border: 2px dashed #ddd;
						background: #f8f9fa;
					}
					
					/* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç lazy loading warnings */
					img[loading="eager"] {
						/* Force eager loading */
					}
				`;
				document.head.appendChild(style);
			}
			
			initializeSystem();
			
			 // ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ
			setTimeout(() => {
				loadDestination();
				updateDestinationDisplay();
			}, 1000);	
 
			setTimeout(() => {
                debugLog('üöÄ Starting safe routing system initialization...');                
                try {
                    replaceFunctionsWithSafeVersions();
                    initializeEnhancedRouting();
                    
                    // Reset routing lock
                    routingLock = {
                        isProcessing: false,
                        lastUpdate: 0,
                        minInterval: 500,
                        maxRetries: 3,
                        currentRetries: 0
                    };                    
                     
                                    
                } catch (error) {
                    debugLog('‚ùå Error initializing safe routing system', error);
                }                
            }, 4000); // ‡∏£‡∏≠‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å systems ‡∏≠‡∏∑‡πà‡∏ô‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à 				 
        });
		
 
		
		// üîß Export functions ‡πÉ‡∏´‡πâ global scope
		window.isValidImageUrl = isValidImageUrl;
		window.ensureRouteConsistency = ensureRouteConsistency;
		window.updateOverlayImageGallery = updateOverlayImageGallery;
		window.showRoomGallery = showRoomGallery;
		window.openImageModal = openImageModal;
		window.handleImageError = handleImageError;
		window.handleImageSuccess = handleImageSuccess;
		window.Environment = Environment;
		
		

 

        // Performance monitoring
        function getMemoryUsage() {
            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                const limit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
                console.log(`Memory: ${used}MB / ${limit}MB`);
                
                if (used > limit * 0.8) {
                    console.warn('‚ö†Ô∏è Memory usage high, consider optimization');
                }
            }
        }
		

		// ========== Phase 2.1: Storage Key Separation + Complete Data Bridge ==========
		// üéØ Mission: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç storage conflicts ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á complete data conversion bridge
		// üîß Target: admin.html + index.html ‡πÉ‡∏ä‡πâ storage keys ‡πÅ‡∏¢‡∏Å‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡∏∞ sync ‡πÑ‡∏î‡πâ

		

		// ========== 2. Safe Storage Key Functions ==========

		// ‡∏î‡∏∂‡∏á storage key ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏° environment
		function getSafeStorageKey(building, forceMode = null) {
			if (!building) building = getCurrentBuildingName();
			
			let mode;
			if (forceMode) {
				mode = forceMode;
			} else if (ADMIN_INDEX_BRIDGE.isAdminMode()) {
				mode = 'admin';
			} else if (ADMIN_INDEX_BRIDGE.isIndexMode()) {
				mode = 'index';
			} else {
				mode = 'unknown';
			}
			
			return ADMIN_INDEX_BRIDGE.getStorageKey(building, mode);
		}

		// ‡∏´‡∏≤ building name ‡∏à‡∏≤‡∏Å environment
		function getCurrentBuildingName() {
			// ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡∏à‡∏≤‡∏Å global variables
			if (typeof walkablePointsData !== 'undefined' && walkablePointsData.currentBuilding) {
				return walkablePointsData.currentBuilding;
			}
			if (typeof walkableRoutingData !== 'undefined' && walkableRoutingData.currentBuilding) {
				return walkableRoutingData.currentBuilding;
			}
			if (typeof currentBuilding !== 'undefined') {
				return currentBuilding;
			}
			
			// ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡∏à‡∏≤‡∏Å DOM elements
			const buildingSelect = document.getElementById('buildingSelect') || 
								  document.querySelector('[data-building]') ||
								  document.querySelector('.building-selector');
			
			if (buildingSelect && buildingSelect.value) {
				return buildingSelect.value;
			}
			
			// Default fallback
			return 'Main Building';
		}

		// ========== 3. Complete Data Format Converters ==========

		// ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å admin format ‡πÄ‡∏õ‡πá‡∏ô index format (COMPLETE VERSION)
		function convertAdminToIndexFormat(adminData) {
			if (!adminData || typeof adminData !== 'object') {
				debugLog('‚ùå Invalid admin data for conversion');
				return null;
			}
			
			try {
				ADMIN_INDEX_BRIDGE.conversionCount++;
				debugLog('üîÑ Converting admin data to index format...', {
					adminNodes: Object.keys(adminData.nodes || {}).length,
					adminEdges: (adminData.edges || []).length,
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				});
				
				const indexData = {
					// Core structure for index.html
					nodes: {},
					edges: [],
					settings: {
						metersPerPercent: adminData.settings?.metersPerPercent || 1.2,
						maxSearchRadius: adminData.settings?.maxConnectionDistance || 25,
						gridSize: adminData.settings?.gridSize || 5,
						autoConnect: adminData.settings?.autoConnect !== false,
						snapToGrid: adminData.settings?.snapToGrid || false
					},
					
					// Metadata
					currentBuilding: adminData.currentBuilding || adminData.building,
					lastPath: null,
					isInitialized: true,
					
					// Bridge metadata
					dataSource: 'admin',
					syncTime: new Date().toISOString(),
					originalFormat: 'admin',
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				};
				
				// ‡πÅ‡∏õ‡∏•‡∏á nodes
				if (adminData.nodes && typeof adminData.nodes === 'object') {
					for (const nodeId in adminData.nodes) {
						const adminNode = adminData.nodes[nodeId];
						if (adminNode && typeof adminNode === 'object') {
							indexData.nodes[nodeId] = {
								id: nodeId,
								x: parseFloat(adminNode.x) || 0,
								y: parseFloat(adminNode.y) || 0,
								type: adminNode.type || 'grid',
								building: adminNode.building || indexData.currentBuilding,
								isActive: adminNode.isActive !== false,
								source: 'admin'
							};
						}
					}
				}
				
				// ‡πÅ‡∏õ‡∏•‡∏á edges
				if (adminData.edges && Array.isArray(adminData.edges)) {
					adminData.edges.forEach((adminEdge, index) => {
						if (adminEdge && typeof adminEdge === 'object') {
							indexData.edges.push({
								from: adminEdge.from,
								to: adminEdge.to,
								weight: parseFloat(adminEdge.weight) || 0,
								bidirectional: adminEdge.bidirectional !== false,
								building: adminEdge.building || indexData.currentBuilding,
								isActive: adminEdge.isActive !== false,
								edgeId: adminEdge.edgeId || `E${index + 1}`,
								source: 'admin'
							});
						}
					});
				}
				
				debugLog('‚úÖ Admin to index conversion completed:', {
					convertedNodes: Object.keys(indexData.nodes).length,
					convertedEdges: indexData.edges.length,
					building: indexData.currentBuilding
				});
				
				ADMIN_INDEX_BRIDGE.lastConversionError = null;
				return indexData;
				
			} catch (error) {
				debugLog('‚ùå Error in admin to index conversion:', error);
				ADMIN_INDEX_BRIDGE.lastConversionError = error.message;
				return null;
			}
		}

		// ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å index format ‡πÄ‡∏õ‡πá‡∏ô admin format (COMPLETE VERSION)
		function convertIndexToAdminFormat(indexData) {
			if (!indexData || typeof indexData !== 'object') {
				debugLog('‚ùå Invalid index data for conversion');
				return null;
			}
			
			try {
				ADMIN_INDEX_BRIDGE.conversionCount++;
				debugLog('üîÑ Converting index data to admin format...', {
					indexNodes: Object.keys(indexData.nodes || {}).length,
					indexEdges: (indexData.edges || []).length,
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				});
				
				const adminData = {
					// Core structure for admin.html
					currentBuilding: indexData.currentBuilding || indexData.building,
					building: indexData.currentBuilding || indexData.building,
					nodes: {},
					edges: [],
					settings: {
						maxConnectionDistance: indexData.settings?.maxSearchRadius || 25,
						metersPerPercent: indexData.settings?.metersPerPercent || 1.2,
						autoConnect: indexData.settings?.autoConnect !== false,
						snapToGrid: indexData.settings?.snapToGrid || false,
						gridSize: indexData.settings?.gridSize || 5
					},
					
					// Admin-specific properties
					selectedNodes: new Set(),
					isDragging: false,
					dragNode: null,
					
					// Bridge metadata
					dataSource: 'index',
					syncTime: new Date().toISOString(),
					originalFormat: 'index',
					conversionId: ADMIN_INDEX_BRIDGE.conversionCount
				};
				
				// ‡πÅ‡∏õ‡∏•‡∏á nodes
				if (indexData.nodes && typeof indexData.nodes === 'object') {
					for (const nodeId in indexData.nodes) {
						const indexNode = indexData.nodes[nodeId];
						if (indexNode && typeof indexNode === 'object') {
							adminData.nodes[nodeId] = {
								id: nodeId,
								x: parseFloat(indexNode.x) || 0,
								y: parseFloat(indexNode.y) || 0,
								type: indexNode.type || 'grid',
								building: indexNode.building || adminData.currentBuilding,
								isActive: indexNode.isActive !== false,
								source: 'index'
							};
						}
					}
				}
				
				// ‡πÅ‡∏õ‡∏•‡∏á edges
				if (indexData.edges && Array.isArray(indexData.edges)) {
					indexData.edges.forEach((indexEdge, edgeIndex) => {
						if (indexEdge && typeof indexEdge === 'object') {
							adminData.edges.push({
								from: indexEdge.from,
								to: indexEdge.to,
								weight: parseFloat(indexEdge.weight) || 0,
								bidirectional: indexEdge.bidirectional !== false,
								building: indexEdge.building || adminData.currentBuilding,
								isActive: indexEdge.isActive !== false,
								edgeId: indexEdge.edgeId || `E${edgeIndex + 1}`,
								source: 'index'
							});
						}
					});
				}
				
				debugLog('‚úÖ Index to admin conversion completed:', {
					convertedNodes: Object.keys(adminData.nodes).length,
					convertedEdges: adminData.edges.length,
					building: adminData.currentBuilding
				});
				
				ADMIN_INDEX_BRIDGE.lastConversionError = null;
				return adminData;
				
			} catch (error) {
				debugLog('‚ùå Error in index to admin conversion:', error);
				ADMIN_INDEX_BRIDGE.lastConversionError = error.message;
				return null;
			}
		}

		// ========== 4. Safe Data Sync Functions ==========

		// Sync admin data ‡πÑ‡∏õ index (SAFE VERSION)
		function syncAdminDataToIndex(building) {
			if (!ADMIN_INDEX_BRIDGE.isIndexMode()) {
				debugLog('‚ö†Ô∏è Not in index mode, sync skipped');
				return false;
			}
			
			debugLog('üî• Syncing admin data to index...', { building });
			
			try {
				// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å admin storage
				const adminKey = getSafeStorageKey(building, 'admin');
				const adminDataString = localStorage.getItem(adminKey);
				
				if (!adminDataString) {
					debugLog('‚ÑπÔ∏è No admin data found in storage');
					return false;
				}
				
				const adminData = JSON.parse(adminDataString);
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å admin ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô circular sync)
				if (adminData.dataSource === 'index') {
					debugLog('üîÑ Data source is index, avoiding circular sync');
					return false;
				}
				
				// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô index format
				const indexData = convertAdminToIndexFormat(adminData);
				if (!indexData) {
					debugLog('‚ùå Failed to convert admin data to index format');
					return false;
				}
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkableRoutingData ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					debugLog('‚úÖ walkableRoutingData updated from admin');
				}
				
				// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô index storage
				const indexKey = getSafeStorageKey(building, 'index');
				localStorage.setItem(indexKey, JSON.stringify(indexData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('‚úÖ Admin data synced to index successfully', {
					adminKey,
					indexKey,
					nodes: Object.keys(indexData.nodes).length,
					edges: indexData.edges.length
				});
				
				return true;
				
			} catch (error) {
				debugLog('‚ùå Error syncing admin data to index:', error);
				return false;
			}
		}

		// Sync index data ‡πÑ‡∏õ admin (SAFE VERSION)  
		function syncIndexDataToAdmin(building) {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) {
				debugLog('‚ö†Ô∏è Not in admin mode, sync skipped');
				return false;
			}
			
			debugLog('üî§ Syncing index data to admin...', { building });
			
			try {
				// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å index storage
				const indexKey = getSafeStorageKey(building, 'index');
				const indexDataString = localStorage.getItem(indexKey);
				
				if (!indexDataString) {
					debugLog('‚ÑπÔ∏è No index data found in storage');
					return false;
				}
				
				const indexData = JSON.parse(indexDataString);
				
				// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å index ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
				if (indexData.dataSource === 'admin') {
					debugLog('üîÑ Data source is admin, avoiding circular sync');
					return false;
				}
				
				// ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô admin format
				const adminData = convertIndexToAdminFormat(indexData);
				if (!adminData) {
					debugLog('‚ùå Failed to convert index data to admin format');
					return false;
				}
				
				// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkablePointsData ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
				if (typeof walkablePointsData !== 'undefined') {
					Object.assign(walkablePointsData, adminData);
					
					// Render ‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
					
					debugLog('‚úÖ walkablePointsData updated from index');
				}
				
				// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô admin storage
				const adminKey = getSafeStorageKey(building, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(adminData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('‚úÖ Index data synced to admin successfully', {
					indexKey,
					adminKey,
					nodes: Object.keys(adminData.nodes).length,
					edges: adminData.edges.length
				});
				
				return true;
				
			} catch (error) {
				debugLog('‚ùå Error syncing index data to admin:', error);
				return false;
			}
		}

		// ========== 5. Enhanced Data Loading Functions ==========

		// Load data ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö admin.html (‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà loadWalkableDataForBuilding ‡πÄ‡∏î‡∏¥‡∏°)
		function loadWalkableDataForBuildingV2(building) {
			building = building || getCurrentBuildingName();
			debugLog('üìÇ Loading walkable data for building (v2)...', { building });
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï current building
			if (typeof walkablePointsData !== 'undefined') {
				walkablePointsData.currentBuilding = building;
			}
			
			try {
				// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å admin storage ‡∏Å‡πà‡∏≠‡∏ô
				const adminKey = getSafeStorageKey(building, 'admin');
				const adminDataString = localStorage.getItem(adminKey);
				
				if (adminDataString) {
					const adminData = JSON.parse(adminDataString);
					
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkablePointsData
					if (typeof walkablePointsData !== 'undefined') {
						Object.assign(walkablePointsData, adminData);
						
						// Render ‡πÉ‡∏´‡∏°‡πà
						if (typeof renderWalkablePoints === 'function') {
							renderWalkablePoints();
						}
						if (typeof updateWalkableStats === 'function') {
							updateWalkableStats();
						}
						if (typeof loadWalkableSettings === 'function') {
							loadWalkableSettings();
						}
					}
					
					debugLog('‚úÖ Loaded admin walkable data', {
						nodes: Object.keys(adminData.nodes || {}).length,
						edges: (adminData.edges || []).length
					});
					return;
				}
				
				// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin ‡∏•‡∏≠‡∏á‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏°‡∏µ index data ‡πÑ‡∏´‡∏°
				const synced = syncIndexDataToAdmin(building);
				if (synced) {
					debugLog('‚úÖ Synced index data to admin');
					return;
				}
				
				// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏î‡πÜ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
				debugLog('üìã No existing data, creating fresh admin data');
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.nodes = {};
					walkablePointsData.edges = [];
					walkablePointsData.currentBuilding = building;
					
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
				}
				
			} catch (error) {
				debugLog('‚ùå Error loading walkable data for building:', error);
				
				// Error fallback
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.nodes = {};
					walkablePointsData.edges = [];
					walkablePointsData.currentBuilding = building;
				}
			}
		}

		// Load data ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index.html (‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà loadWalkableData ‡πÄ‡∏î‡∏¥‡∏°)
		function loadWalkableDataWithAdminSyncV2(building) {
			building = building || getCurrentBuildingName();
			debugLog('üìÇ Loading walkable data with admin sync (v2)...', { building });
			
			// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï current building
			if (typeof walkableRoutingData !== 'undefined') {
				walkableRoutingData.currentBuilding = building;
			}
			
			try {
				// ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å admin ‡∏Å‡πà‡∏≠‡∏ô (admin has priority)
				const adminSynced = syncAdminDataToIndex(building);
				if (adminSynced) {
					debugLog('‚úÖ Loaded admin-created walkable data');
					return;
				}
				
				// ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• admin ‡∏•‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å index cache
				const indexKey = getSafeStorageKey(building, 'index');
				const indexDataString = localStorage.getItem(indexKey);
				
				if (indexDataString) {
					const indexData = JSON.parse(indexDataString);
					
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï walkableRoutingData
					if (typeof walkableRoutingData !== 'undefined') {
						Object.assign(walkableRoutingData, indexData);
					}
					
					debugLog('üìã Loaded cached index walkable data', {
						nodes: Object.keys(indexData.nodes || {}).length,
						edges: (indexData.edges || []).length
					});
					return;
				}
				
				// ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏î‡πÜ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á fixed grid
				debugLog('üóèÔ∏è No existing data, creating fixed grid');
				if (typeof createFixedWalkableGrid === 'function') {
					createFixedWalkableGrid();
				} else if (typeof walkableRoutingData !== 'undefined') {
					// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
					walkableRoutingData.nodes = {};
					walkableRoutingData.edges = [];
					walkableRoutingData.isInitialized = true;
				}
				
			} catch (error) {
				debugLog('‚ùå Error loading walkable data with admin sync:', error);
				
				// Error fallback
				if (typeof walkableRoutingData !== 'undefined') {
					walkableRoutingData.nodes = {};
					walkableRoutingData.edges = [];
					walkableRoutingData.isInitialized = false;
				}
			}
		}

		// ========== 6. Enhanced Save Functions ==========

		// Save data ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö admin.html (‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà saveWalkableData ‡πÄ‡∏î‡∏¥‡∏°)
		function saveWalkableDataV2() {
			const building = getCurrentBuildingName();
			debugLog('üíæ Saving walkable data (v2)...', { building });
			
			try {
				if (typeof walkablePointsData === 'undefined') {
					throw new Error('walkablePointsData not found');
				}
				
				// ‡πÄ‡∏û‡∏¥‡πà‡∏° metadata
				const dataToSave = {
					...walkablePointsData,
					building: building,
					currentBuilding: building,
					dataSource: 'admin',
					syncTime: new Date().toISOString(),
					timestamp: new Date().toISOString()
				};
				
				// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô admin storage
				const adminKey = getSafeStorageKey(building, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(dataToSave));
				
				debugLog('‚úÖ Admin data saved successfully', {
					adminKey,
					nodes: Object.keys(dataToSave.nodes || {}).length,
					edges: (dataToSave.edges || []).length
				});
				
				// Auto-sync to index ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
				if (ADMIN_INDEX_BRIDGE.autoSyncOnChange) {
					const indexData = convertAdminToIndexFormat(dataToSave);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						debugLog('üîÑ Auto-synced to index format');
					}
				}
				
				// ‡πÅ‡∏™‡∏î‡∏á notification ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
				if (typeof showNotification === 'function') {
					showNotification('üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß', 'success');
				}
				
			} catch (error) {
				debugLog('‚ùå Error saving walkable data:', error);
				
				if (typeof showNotification === 'function') {
					showNotification('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å', 'error');
				}
			}
		}

		// Save data ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö index.html
		function saveWalkableDataV2ForIndex() {
			const building = getCurrentBuildingName();
			debugLog('üíæ Saving walkable data for index (v2)...', { building });
			
			try {
				if (typeof walkableRoutingData === 'undefined') {
					throw new Error('walkableRoutingData not found');
				}
				
				// ‡πÄ‡∏û‡∏¥‡πà‡∏° metadata
				const dataToSave = {
					...walkableRoutingData,
					currentBuilding: building,
					dataSource: 'index',
					syncTime: new Date().toISOString()
				};
				
				// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô index storage
				const indexKey = getSafeStorageKey(building, 'index');
				localStorage.setItem(indexKey, JSON.stringify(dataToSave));
				
				debugLog('‚úÖ Index data saved successfully', {
					indexKey,
					nodes: Object.keys(dataToSave.nodes || {}).length,
					edges: (dataToSave.edges || []).length
				});
				
			} catch (error) {
				debugLog('‚ùå Error saving index walkable data:', error);
			}
		}

		// ========== 7. Debug and Status Functions ==========

		// ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ bridge system
		function debugBridgeStatus() {
			const building = getCurrentBuildingName();
			
			console.group('üîç Bridge System Status');
			console.log('Environment:', {
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode(),
				building: building
			});
			
			console.log('Storage Keys:', {
				admin: getSafeStorageKey(building, 'admin'),
				index: getSafeStorageKey(building, 'index')
			});
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô localStorage
			const adminKey = getSafeStorageKey(building, 'admin');
			const indexKey = getSafeStorageKey(building, 'index');
			
			const adminData = localStorage.getItem(adminKey);
			const indexData = localStorage.getItem(indexKey);
			
			console.log('Storage Status:', {
				adminData: adminData ? 'EXISTS' : 'NOT FOUND',
				indexData: indexData ? 'EXISTS' : 'NOT FOUND'
			});
			
			if (adminData) {
				try {
					const parsed = JSON.parse(adminData);
					console.log('Admin Data:', {
						nodes: Object.keys(parsed.nodes || {}).length,
						edges: (parsed.edges || []).length,
						source: parsed.dataSource,
						syncTime: parsed.syncTime
					});
				} catch (e) {
					console.warn('‚ö†Ô∏è Admin data parsing error:', e);
				}
			}
			
			if (indexData) {
				try {
					const parsed = JSON.parse(indexData);
					console.log('Index Data:', {
						nodes: Object.keys(parsed.nodes || {}).length,
						edges: (parsed.edges || []).length,
						source: parsed.dataSource,
						syncTime: parsed.syncTime
					});
				} catch (e) {
					console.warn('‚ö†Ô∏è Index data parsing error:', e);
				}
			}
			
			console.log('Bridge Status:', {
				lastSync: ADMIN_INDEX_BRIDGE.lastSyncTime,
				conversionCount: ADMIN_INDEX_BRIDGE.conversionCount,
				lastError: ADMIN_INDEX_BRIDGE.lastConversionError
			});
			
			console.groupEnd();
		}

		// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
		function testDataConversion() {
			const building = getCurrentBuildingName();
			console.group('üß™ Testing Data Conversion');
			
			// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö
			const testAdminData = {
				currentBuilding: building,
				nodes: {
					'test1': { id: 'test1', x: 10, y: 20, type: 'center' },
					'test2': { id: 'test2', x: 30, y: 40, type: 'grid' }
				},
				edges: [
					{ from: 'test1', to: 'test2', weight: 25.5, bidirectional: true }
				],
				settings: { maxConnectionDistance: 30, metersPerPercent: 1.5 }
			};
			
			// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö admin ‚Üí index
			console.log('Testing admin ‚Üí index conversion...');
			const indexResult = convertAdminToIndexFormat(testAdminData);
			console.log('Result:', indexResult);
			
			// ‡∏ó‡∏î‡∏™‡∏≠‡∏ö index ‚Üí admin
			if (indexResult) {
				console.log('Testing index ‚Üí admin conversion...');
				const adminResult = convertIndexToAdminFormat(indexResult);
				console.log('Result:', adminResult);
			}
			
			console.groupEnd();
		}

		// ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug)
		function clearAllWalkableData(building) {
			building = building || getCurrentBuildingName();
			
			const adminKey = getSafeStorageKey(building, 'admin');
			const indexKey = getSafeStorageKey(building, 'index');
			
			localStorage.removeItem(adminKey);
			localStorage.removeItem(indexKey);
			
			// ‡∏•‡πâ‡∏≤‡∏á old format data ‡∏î‡πâ‡∏ß‡∏¢ (migration)
			const oldKey = `walkableData_${building}`;
			localStorage.removeItem(oldKey);
			
			console.log('üóëÔ∏è Cleared all walkable data for building:', building);
			debugBridgeStatus();
		}

		// ========== 8. Initialization and Integration ==========

		// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠ DOM ready
		function initializeBridgeSystem() {
			debugLog('üöÄ Initializing Bridge System...');
			
			// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö environment
			if (!ADMIN_INDEX_BRIDGE.isAdminMode() && !ADMIN_INDEX_BRIDGE.isIndexMode()) {
				debugLog('‚ö†Ô∏è Unknown environment, bridge system inactive');
				return;
			}
			
			// ‡πÄ‡∏û‡∏¥‡πà‡∏° debug commands ‡πÉ‡∏ô window
			if (ADMIN_INDEX_BRIDGE.debugMode) {
				window.debugBridgeStatus = debugBridgeStatus;
				window.testDataConversion = testDataConversion;
				window.clearAllWalkableData = clearAllWalkableData;
				window.ADMIN_INDEX_BRIDGE = ADMIN_INDEX_BRIDGE;
			}
			
			debugLog('‚úÖ Bridge System initialized successfully');
			debugLog('üîß Available debug commands: debugBridgeStatus(), testDataConversion(), clearAllWalkableData()');
		}

		// Auto-initialize ‡πÄ‡∏°‡∏∑‡πà‡∏≠ script load
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initializeBridgeSystem);
		} else {
			initializeBridgeSystem();
		}

		// ========== 9. Helper Functions ==========

		function debugLog(message, data = null) {
			if (!ADMIN_INDEX_BRIDGE.debugMode) return;
			
			const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
			const prefix = `[${timestamp}] Bridge:`;
			
			if (data) {
				console.log(prefix, message, data);
			} else {
				console.log(prefix, message);
			}
		}

		// Export functions for global use
		window.PHASE_2_1_FUNCTIONS = {
			// Storage
			getSafeStorageKey,
			getCurrentBuildingName,
			
			// Conversion
			convertAdminToIndexFormat,
			convertIndexToAdminFormat,
			
			// Sync
			syncAdminDataToIndex,
			syncIndexDataToAdmin,
			
			// Loading
			loadWalkableDataForBuildingV2,
			loadWalkableDataWithAdminSyncV2,
			
			// Saving
			saveWalkableDataV2,
			saveWalkableDataV2ForIndex,
			
			// Debug
			debugBridgeStatus,
			testDataConversion,
			clearAllWalkableData
		};
		 
		// ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô loadWalkableData ‡πÄ‡∏î‡∏¥‡∏°
		window.loadWalkableData = loadWalkableDataWithAdminSyncV2;

		// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£ save index data
		window.saveWalkableDataForIndex = saveWalkableDataV2ForIndex;		 
		// ========== End Phase 2.1: Storage Key Separation + Complete Data Bridge ==========
	

        // ******************‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ *********************
		setInterval(optimizePerformance, 5 * 60 * 1000);
				
		// ***************** Start: initializeSystem ******************************
		async function initializeSystem() {
			try {
			 				
				clearDestination()
				showLoadingOverlay()
				await connectToGoogleSheets();
		 				
				// ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô		
				await loadInitialData();
				
				// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Event Handlers
				//setupMapEvents();
				setupWindowEvents();
				
				// Initialize map controls
				setMapLayout('floorplan');
				
				 // üîß ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
				ensureRouteAnimationCSS();
		 
				hideLoadingOverlay();
				
				// ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö
				setTimeout(() => {
					const welcomeMessage = currentLanguage === 'th' 
						? 'üéâ ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞!' 
						: 'üéâ Welcome to Smart School Map System!';
					showNotification(welcomeMessage, 'success');
				}, 1000);
				
				 
	
			} catch (error) {
				console.error('System initialization error:', error);
				const errorMessage = currentLanguage === 'th' 
					? '‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏î‡πâ' 
					: '‚ùå System initialization failed';
				showProgressiveStatus(errorMessage, 'error');
				
				// ‡πÅ‡∏°‡πâ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡πá‡∏¢‡∏±‡∏á‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á
				try {
					await loadFallbackData();
					setupMapEvents();
					setupWindowEvents();
					showProgressiveStatus('‚ö†Ô∏è ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á', 'warning');
				} catch (fallbackError) {
					console.error('Fallback initialization failed:', fallbackError);
					showProgressiveStatus('‚ùå ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ', 'error');
				}
			}
		}	
		
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° landscape ‡πÉ‡∏ô globalVersionIndicator
function showLandscapeMessage() {
    const indicator = document.getElementById('globalVersionIndicator');
    if (!indicator) return;
    
    // ‡πÄ‡∏Å‡πá‡∏ö content ‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ
    const originalContent = indicator.innerHTML;
    const originalClass = indicator.className;
    const originalStyle = indicator.style.cssText;
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
    indicator.innerHTML = '‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡πÄ‡∏°‡∏ô‡∏π';
    indicator.className = 'status-indicator status-error';
    indicator.style.cssText = `
        position: absolute !important;
        top: 5px !important;
        right: 10px !important;
        z-index: 9999 !important;
        font-size: 10px !important;
        padding: 4px 8px !important;
        background: rgba(220, 53, 69, 0.9) !important;
        color: white !important;
        border-radius: 15px !important;
        animation: landscapePulse 1.5s ease-in-out infinite !important;
        cursor: pointer !important;
        max-width: 180px !important;
        text-align: center !important;
        line-height: 1.2 !important;
    `;
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° animation CSS ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
    if (!document.getElementById('landscape-animation')) {
        const style = document.createElement('style');
        style.id = 'landscape-animation';
        style.textContent = `
            @keyframes landscapePulse {
                0%, 100% { 
                    opacity: 0.8;
                    transform: scale(1);
                }
                50% { 
                    opacity: 1;
                    transform: scale(1.05);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Auto hide ‡∏´‡∏•‡∏±‡∏á 4 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    setTimeout(() => {
        if (indicator) {
            indicator.innerHTML = originalContent;
            indicator.className = originalClass;
            indicator.style.cssText = originalStyle;
        }
    }, 4000);
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ã‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° landscape
function hideLandscapeMessage() {
    const indicator = document.getElementById('globalVersionIndicator');
    if (!indicator) return;
    
    // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    indicator.innerHTML = '';
    indicator.className = 'status-indicator status-connected';
    indicator.style.cssText = `
        position: absolute;
        top: 2px;
        right: 10px;
        z-index: 200;
        font-size: 8px;
        padding: 1px 6px;
        border-radius: 8px;
    `;
}

// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö orientation ‡πÅ‡∏•‡∏∞ page
function checkLandscapeConditions() {
    const isLandscape = window.matchMedia('(orientation: landscape)').matches;
    const isMaxHeight500 = window.matchMedia('(max-height: 500px)').matches;
    const isMapPage = document.body.classList.contains('map-page') || 
                     document.body.getAttribute('data-current-page') === 'map';
    
    return isLandscape && isMaxHeight500 && isMapPage;
}

// Event listeners ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö orientation change
function setupLandscapeMessageListener() {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
    if (checkLandscapeConditions()) {
        setTimeout(showLandscapeMessage, 500); // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ UI settle
    }
    
    // ‡∏ü‡∏±‡∏á orientation changes
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (checkLandscapeConditions()) {
                showLandscapeMessage();
            } else {
                hideLandscapeMessage();
            }
        }, 300); // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÉ‡∏´‡πâ orientation change ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô
    });
    
    // ‡∏ü‡∏±‡∏á resize events (backup)
    window.addEventListener('resize', () => {
        setTimeout(() => {
            if (checkLandscapeConditions()) {
                showLandscapeMessage();
            } else {
                hideLandscapeMessage();
            }
        }, 100);
    });
    
    // ‡∏ü‡∏±‡∏á page changes
    const originalShowPage = window.showPage;
    if (originalShowPage) {
        window.showPage = function(pageId) {
            const result = originalShowPage.apply(this, arguments);
            
            setTimeout(() => {
                if (checkLandscapeConditions()) {
                    showLandscapeMessage();
                } else {
                    hideLandscapeMessage();
                }
            }, 100);
            
            return result;
        };
    }
}

// CSS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ã‡πà‡∏≠‡∏ô header-top ‡πÅ‡∏•‡∏∞ bottom-navigation ‡πÉ‡∏ô landscape
function addLandscapeCSS() {
    if (document.getElementById('landscape-css')) return;
    
    const style = document.createElement('style');
    style.id = 'landscape-css';
    style.textContent = `
        /* ========== Mobile Landscape: ‡∏ã‡πà‡∏≠‡∏ô UI elements ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ========== */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            /* ‡∏ã‡πà‡∏≠‡∏ô header-top ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
            body.map-page .header-top,
            body[data-current-page="map"] .header-top {
                display: none !important;
				
			/* ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î landscape */
			body.map-page .map-area,
			body[data-current-page="map"] .map-area {
				max-height: calc(100vh - 20px) !important;
				max-width: calc(100vw - 20px) !important;
				overflow: hidden !important;
				margin: 10px auto !important;
				box-sizing: border-box !important;
			}
			
			/* ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
			body.map-page .map-image,
			body[data-current-page="map"] .map-image {
				max-height: calc(100vh - 40px) !important;
				max-width: calc(100vw - 40px) !important;
				width: auto !important;
				height: auto !important;
				object-fit: contain !important;
				object-position: center !important;
			}
			
			/* ‡∏õ‡∏£‡∏±‡∏ö map container */
			body.map-page .map-container,
			body[data-current-page="map"] .map-container {
				max-height: 100vh !important;
				overflow: hidden !important;
			}
            }
            
            /* ‡∏ã‡πà‡∏≠‡∏ô bottom navigation ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
            body.map-page .bottom-navigation,
            body[data-current-page="map"] .bottom-navigation {
                display: none !important;
            }
            
            /* ‡∏õ‡∏£‡∏±‡∏ö body padding ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
            body.map-page,
            body[data-current-page="map"] {
                padding-bottom: 0 !important;
            }
            
            /* ‡∏•‡∏î header size ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà */
            body.map-page .header,
            body[data-current-page="map"] .header {
                padding: 5px 20px !important;
                margin-bottom: 5px !important;
            }
        }
        
        /* ========== Portrait Reset ========== */
        @media screen and (orientation: portrait) {
            .header-top {
                display: flex !important;
            }
            
            .bottom-navigation {
                display: flex !important;
            }
            
            body {
                padding-bottom: var(--content-padding-bottom) !important;
            }
            
            .header {
                padding: 15px 20px !important;
                margin-bottom: 15px !important;
            }
        }
    `;
    document.head.appendChild(style);
}

// ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
function initializeLandscapeMessage() {
    console.log('üîÑ Initializing landscape message system...');
    
    addLandscapeCSS();
    setupLandscapeMessageListener();
    
    console.log('‚úÖ Landscape message system initialized');
}

// Auto initialize
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeLandscapeMessage);
} else {
    initializeLandscapeMessage();
}		
		
		
		// *****************  End: initializeSystem ******************************
        console.log('üéâ ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏£‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞ Version1.3 Enhanced: Dikstra Admin-Index Integrtaion Bridge LATEST UPDATE!');
     
    </script>
</body>
</html>