<<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ระบบแผนที่โรงเรียนอัจฉริยะ V1.3 - Admin Interface</title>
    
    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <style>
        /* =================== CSS Variables =================== */
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --dark-color: #343a40;
            
            --admin-bg: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            --card-background: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-light: #ffffff;
            --border-color: #e0e6ff;
            
            --border-radius: 15px;
            --box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
            
            --sidebar-width: 280px;
            --header-height: 70px;
            --mobile-nav-height: 70px;
        }

        /* =================== Base Styles =================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--admin-bg);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* =================== Login Screen =================== */
        .login-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--admin-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .login-card {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 40px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            max-width: 400px;
            width: 100%;
            margin: 20px;
            text-align: center;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .login-header {
            margin-bottom: 30px;
        }

        .login-logo {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .login-title {
            font-size: 24px;
            font-weight: 600;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .login-subtitle {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .login-form {
            text-align: left;
        }

        .login-form-group {
            margin-bottom: 20px;
        }

        .login-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .login-input {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            transition: var(--transition);
            background: var(--card-background);
        }

        .login-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .login-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: var(--transition);
            margin-top: 10px;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .login-error {
            background: rgba(220, 53, 69, 0.1);
            color: var(--danger-color);
            padding: 12px;
            border-radius: var(--border-radius);
            margin-top: 15px;
            font-size: 14px;
            display: none;
        }

        .login-info {
            background: rgba(23, 162, 184, 0.1);
            color: var(--info-color);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            font-size: 13px;
        }

        /* =================== Layout =================== */
        .admin-container {
            display: flex;
            min-height: 100vh;
            padding-bottom: 0;
        }

        /* Desktop Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-color);
            position: fixed;
            height: 100vh;
            left: 0;
            top: 0;
            transition: var(--transition);
            z-index: 1000;
            overflow-y: auto;
        }

        .sidebar.collapsed {
            width: 70px;
        }

        /* Mobile Bottom Navigation */
        .mobile-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--mobile-nav-height);
            background: rgba(255,255,255,0.95);
            border-top: 1px solid var(--border-color);
            display: none;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
        }

        .mobile-nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            padding: 8px 4px;
            color: var(--text-secondary);
            text-decoration: none;
        }

        .mobile-nav-item.active {
            color: var(--primary-color);
        }

        .mobile-nav-item:hover {
            color: var(--primary-color);
            transform: translateY(-2px);
        }

        .mobile-nav-item i {
            font-size: 18px;
            margin-bottom: 4px;
        }

        .mobile-nav-item span {
            font-size: 10px;
            font-weight: 600;
        }

        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            transition: var(--transition);
            min-height: 100vh;
        }

        .main-content.expanded {
            margin-left: 70px;
        }

        /* =================== Responsive Design =================== */
        @media (max-width: 768px) {
            .admin-container {
                padding-bottom: var(--mobile-nav-height);
            }
            
            .sidebar {
                transform: translateX(-100%);
                width: 100%;
            }
            
            .sidebar.show {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .mobile-nav {
                display: flex;
            }
            
            .form-row, .form-row-3 {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .modal-content {
                margin: 10px;
                max-width: none;
            }
            
            .login-card {
                margin: 10px;
                padding: 30px 20px;
            }
        }

        /* =================== Sidebar =================== */
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--text-light);
        }

        .sidebar-header h2 {
            font-size: 18px;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 12px;
            opacity: 0.9;
        }

        .sidebar-toggle {
            position: absolute;
            top: 20px;
            right: 15px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            transition: var(--transition);
        }

        .sidebar-toggle:hover {
            background: rgba(255,255,255,0.3);
        }

        .sidebar-menu {
            padding: 20px 0;
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            transition: var(--transition);
            border-left: 4px solid transparent;
            color: var(--text-primary);
            text-decoration: none;
        }

        .menu-item:hover {
            background: rgba(102, 126, 234, 0.1);
            border-left-color: var(--primary-color);
        }

        .menu-item.active {
            background: rgba(102, 126, 234, 0.15);
            border-left-color: var(--primary-color);
            color: var(--primary-color);
            font-weight: 600;
        }

        .menu-item i {
            width: 20px;
            margin-right: 15px;
            font-size: 16px;
        }

        .menu-text {
            transition: var(--transition);
        }

        .sidebar.collapsed .menu-text {
            opacity: 0;
            width: 0;
        }

        /* =================== Header =================== */
        .main-header {
            height: var(--header-height);
            background: var(--card-background);
            box-shadow: var(--box-shadow);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .header-actions {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .header-btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-btn.primary {
            background: var(--primary-color);
            color: white;
        }

        .header-btn.secondary {
            background: var(--card-background);
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }

        .header-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--box-shadow);
        }

        .logout-btn {
            background: var(--danger-color);
            color: white;
        }

        /* =================== Content Area =================== */
        .content-area {
            padding: 30px;
            min-height: calc(100vh - var(--header-height));
        }

        .page-section {
            display: none;
            animation: fadeInUp 0.4s ease-out;
        }

        .page-section.active {
            display: block;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* =================== Cards =================== */
        .admin-card {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            margin-bottom: 25px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        .card-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* =================== Forms =================== */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            transition: var(--transition);
            background: var(--card-background);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .form-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }

        /* =================== Buttons =================== */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            text-align: center;
            justify-content: center;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--box-shadow);
        }

        .btn-primary { background: var(--primary-color); color: white; }
        .btn-success { background: var(--accent-color); color: white; }
        .btn-danger { background: var(--danger-color); color: white; }
        .btn-warning { background: var(--warning-color); color: var(--dark-color); }
        .btn-info { background: var(--info-color); color: white; }
        .btn-secondary { 
            background: var(--card-background); 
            color: var(--text-primary); 
            border: 2px solid var(--border-color); 
        }

        .btn-sm {
            padding: 8px 16px;
            font-size: 12px;
        }

        /* =================== Tables =================== */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card-background);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .data-table th {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
            font-size: 14px;
        }

        .data-table td {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .data-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .data-table tr:last-child td {
            border-bottom: none;
        }

        /* =================== Stats Cards =================== */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 20px;
            text-align: center;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-icon {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* =================== Status Indicators =================== */
        .status-indicator {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: rgba(40, 167, 69, 0.1);
            color: var(--accent-color);
        }

        .status-inactive {
            background: rgba(108, 117, 125, 0.1);
            color: #6c757d;
        }

        .status-connected {
            background: rgba(23, 162, 184, 0.1);
            color: var(--info-color);
        }

        .status-error {
            background: rgba(220, 53, 69, 0.1);
            color: var(--danger-color);
        }

        /* =================== Loading States =================== */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* =================== Sequential Loading UI =================== */
        .sequential-loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
            backdrop-filter: blur(5px);
        }

        .sequential-loading.show {
            display: flex;
        }

        .loading-content {
            background: white;
            padding: 40px;
            border-radius: var(--border-radius);
            text-align: center;
            min-width: 400px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
        }

        .loading-steps {
            margin: 20px 0;
        }

        .loading-step {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .loading-step:last-child {
            border-bottom: none;
        }

        .step-icon {
            width: 24px;
            height: 24px;
            margin-right: 15px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .step-icon.pending {
            background: #f0f0f0;
            color: #999;
        }

        .step-icon.loading {
            background: var(--info-color);
            color: white;
        }

        .step-icon.success {
            background: var(--accent-color);
            color: white;
        }

        .step-icon.error {
            background: var(--danger-color);
            color: white;
        }

        .step-text {
            flex: 1;
            text-align: left;
        }

        .step-text.loading {
            color: var(--info-color);
            font-weight: 600;
        }

        .step-text.success {
            color: var(--accent-color);
        }

        .step-text.error {
            color: var(--danger-color);
        }

        /* =================== Notification =================== */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: var(--border-radius);
            color: white;
            font-weight: 600;
            box-shadow: var(--box-shadow);
            z-index: 3000;
            opacity: 0;
            transform: translateX(350px);
            transition: var(--transition);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.success { background: var(--accent-color); }
        .notification.error { background: var(--danger-color); }
        .notification.warning { background: var(--warning-color); color: var(--dark-color); }
        .notification.info { background: var(--info-color); }
		
		
		/* Maps Management Specific Styles */
		.upload-section .form-input[type="file"] {
			border: 2px dashed var(--border-color);
			padding: 20px;
			text-align: center;
			cursor: pointer;
			transition: var(--transition);
		}

		.upload-section .form-input[type="file"]:hover {
			border-color: var(--primary-color);
			background: rgba(102, 126, 234, 0.05);
		}

		.preview-card img {
			max-width: 100%;
			max-height: 150px;
			border-radius: 8px;
			box-shadow: 0 4px 15px rgba(0,0,0,0.1);
		}

		.image-preview-info {
			margin-top: 10px;
			font-size: 12px;
			color: var(--text-secondary);
		}

		@media (max-width: 768px) {
			.image-previews {
				grid-template-columns: 1fr;
			}
		}
		
		/* Deployment Guide Specific Styles */
		.deployment-step {
			transition: var(--transition);
		}

		.deployment-step:hover {
			box-shadow: 0 4px 15px rgba(0,0,0,0.1);
		}

		.accordion-header:hover {
			background: #e9ecef !important;
		}

		.accordion-content.show {
			display: block !important;
		}

		.accordion-header .fas {
			transition: transform 0.3s ease;
		}

		.accordion-header.active .fas {
			transform: rotate(180deg);
		}

		.tip-card {
			transition: var(--transition);
		}

		.tip-card:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 15px rgba(0,0,0,0.1);
		}

		@media (max-width: 768px) {
			.deployment-quick-start > div {
				grid-template-columns: 1fr;
			}
			
			.advanced-tips > div {
				grid-template-columns: 1fr;
			}
		}
		/* Enhanced Google Sheets Specific Styles */
			.connection-banner {
				transition: var(--transition);
			}

			.connection-banner.connected {
				background: rgba(40, 167, 69, 0.1);
				border: 1px solid rgba(40, 167, 69, 0.3);
				color: var(--accent-color);
			}

			.connection-banner.disconnected {
				background: rgba(220, 53, 69, 0.1);
				border: 1px solid rgba(220, 53, 69, 0.3);
				color: var(--danger-color);
			}

			.connection-banner.testing {
				background: rgba(23, 162, 184, 0.1);
				border: 1px solid rgba(23, 162, 184, 0.3);
				color: var(--info-color);
			}

			.setup-step .step-header.completed {
				border-color: var(--accent-color) !important;
				background: rgba(40, 167, 69, 0.1) !important;
			}

			.setup-step .step-header.completed .step-number {
				background: var(--accent-color) !important;
			}

			.setup-step .step-header.active .step-chevron {
				transform: rotate(180deg);
			}

			.url-validation.valid {
				color: var(--accent-color);
			}

			.url-validation.invalid {
				color: var(--danger-color);
			}
			
			/* Modal Specific Styles */
			.modal {
				animation: fadeIn 0.3s ease-out;
			}

			@keyframes fadeIn {
				from { opacity: 0; }
				to { opacity: 1; }
			}

			.modal-content {
				animation: slideIn 0.3s ease-out;
			}

			@keyframes slideIn {
				from { transform: translateY(-50px); opacity: 0; }
				to { transform: translateY(0); opacity: 1; }
			}

			.image-url-input {
				transition: var(--transition);
			}

			.image-url-input input.error {
				border-color: var(--danger-color);
				background: rgba(220, 53, 69, 0.1);
			}

			.image-url-input input.success {
				border-color: var(--accent-color);
				background: rgba(40, 167, 69, 0.1);
			}

			/* Mobile Responsive */
			@media (max-width: 768px) {
				.modal-content {
					margin: 20px;
					max-width: none;
				}
				
				.modal-header {
					padding: 20px !important;
				}
				
				.modal-body {
					padding: 20px !important;
				}
				
				.form-row {
					grid-template-columns: 1fr !important;
				}
			}		
			/* Enhanced Navigation Styles */
				.mobile-more-menu {
					animation: slideUp 0.3s ease-out;
				}

				@keyframes slideUp {
					from { transform: translateY(20px); opacity: 0; }
					to { transform: translateY(0); opacity: 1; }
				}

				.more-menu-item:hover {
					background: rgba(102, 126, 234, 0.1);
				}

				.more-menu-item:last-child {
					border-bottom: none;
					border-radius: 0 0 10px 10px;
				}

				.more-menu-item:first-child {
					border-radius: 10px 10px 0 0;
				}

				/* Enhanced Search Styles */
				#buildingQuickSearch:focus,
				#roomQuickSearch:focus {
					outline: none;
					border-color: var(--primary-color);
					box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
				}

				/* Responsive Enhanced Headers */
				@media (max-width: 768px) {
					.enhanced-card-header {
						flex-direction: column;
						align-items: stretch;
					}
					
					.enhanced-card-header > div {
						justify-content: center;
					}
					
					#buildingQuickSearch,
					#roomQuickSearch {
						width: 100%;
					}
				}
				
			/* Additional styles for missing elements */
			.connection-banner {
				transition: all 0.3s ease;
			}

			.connection-banner.connected {
				background: rgba(40, 167, 69, 0.1);
				border-color: rgba(40, 167, 69, 0.3);
			}

			.connection-banner.disconnected {
				background: rgba(220, 53, 69, 0.1);
				border-color: rgba(220, 53, 69, 0.3);
			}

			.connection-banner.testing {
				background: rgba(23, 162, 184, 0.1);
				border-color: rgba(23, 162, 184, 0.3);
			}

			.url-validation.valid {
				color: var(--accent-color);
			}

			.url-validation.invalid {
				color: var(--danger-color);
			}

			.setup-step {
				margin-bottom: 15px;
				border: 1px solid var(--border-color);
				border-radius: 10px;
				overflow: hidden;
			}

			.step-header {
				padding: 15px;
				background: #f8f9fa;
				cursor: pointer;
				transition: background 0.3s ease;
			}

			.step-header:hover {
				background: #e9ecef;
			}

			.step-header.completed {
				border-left: 4px solid var(--accent-color);
				background: rgba(40, 167, 69, 0.1);
			}

			.step-content {
				padding: 20px;
				background: white;
				display: none;
			}

			.step-number {
				width: 30px;
				height: 30px;
				border-radius: 50%;
				background: #6c757d;
				color: white;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 600;
				transition: all 0.3s ease;
			}

			.step-chevron {
				transition: transform 0.3s ease;
			}

			.step-header.active .step-chevron {
				transform: rotate(180deg);
			}

			/* Debug Panel Styles */
			.debug-line {
				margin: 2px 0;
				white-space: pre-wrap;
			}

			.debug-timestamp {
				color: #888;
				margin-right: 8px;
			}

			.debug-success {
				color: #00ff00;
			}

			.debug-error {
				color: #ff4444;
			}

			.debug-warning {
				color: #ffaa00;
			}

			.debug-info {
				color: #00aaff;
			}
			
			/* เพิ่ม CSS นี้ในส่วน <style> ของ admin.html หลังจาก CSS เดิม */

			.interactive-map-container {
				background: var(--card-background);
				border-radius: var(--border-radius);
				padding: 20px;
				margin-bottom: 20px;
				border: 2px solid var(--border-color);
				position: relative;
			}

			.map-picker-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 15px;
				padding-bottom: 10px;
				border-bottom: 1px solid var(--border-color);
			}

			.map-picker-title {
				font-size: 14px;
				font-weight: 600;
				color: var(--primary-color);
				display: flex;
				align-items: center;
				gap: 8px;
			} 

			.map-canvas-container {
				position: relative;
				border: 1px solid var(--border-color);
				border-radius: 8px;
				overflow: hidden;
				background: #f8f9fa;
				cursor: crosshair;
				width: 100%;
				margin-bottom: 15px;
				min-height: 350px;  /* เพิ่มความสูง */
				display: flex;
				align-items: stretch;  /* เปลี่ยนจาก center */
				justify-content: stretch;  /* เปลี่ยนจาก center */
			}

			.position-marker {
				position: absolute;
				width: 16px;
				height: 16px;
				background: #ff4757;
				border: 2px solid white;
				border-radius: 50%;
				transform: translate(-50%, -50%);
				box-shadow: 0 2px 8px rgba(255, 71, 87, 0.4);
				pointer-events: none;
				z-index: 10;
				animation: markerPulse 2s infinite;
			}

			@keyframes markerPulse {
				0% { transform: translate(-50%, -50%) scale(1); }
				50% { transform: translate(-50%, -50%) scale(1.3); }
				100% { transform: translate(-50%, -50%) scale(1); }
			}

		 

			.coordinate-display { 
				background: rgba(0, 0, 0, 0.7);
				color: white;
				padding: 4px 8px;
				border-radius: 10px;
				font-family: monospace;
				font-size: 9px;
				position: absolute;
				top: 5px;
				left: 5px;  /* เปลี่ยนจาก right เป็น left */
				z-index: 20;
				backdrop-filter: blur(3px);
				pointer-events: none;  /* ป้องกันการคลิก */
				opacity: 0.8;
			} 
   
			.coordinate-inputs-enhanced {
				display: grid;
				grid-template-columns: 1fr 1fr auto;
				gap: 10px;
				align-items: end;
				margin-top: 15px;
			}

			.coordinate-input-group-enhanced {
				display: flex;
				flex-direction: column;
			}

			.coordinate-input-enhanced {
				padding: 8px 10px;
				border: 1px solid var(--border-color);
				border-radius: 6px;
				font-family: monospace;
				font-size: 13px;
				background: #f8f9fa;
				width: 100%;
			}

			.coordinate-input-enhanced:focus {
				outline: none;
				border-color: var(--primary-color);
				background: white;
			}

			.clear-position-btn {
				padding: 8px 12px;
				background: var(--danger-color);
				color: white;
				border: none;
				border-radius: 6px;
				cursor: pointer;
				font-size: 11px;
				display: flex;
				align-items: center;
				gap: 4px;
				transition: var(--transition);
				height: fit-content;
			}

			.clear-position-btn:hover {
				background: #c92a2a;
				transform: translateY(-1px);
			}

			.map-instructions {
				background: #e3f2fd;
				border: 1px solid #2196f3;
				border-radius: 6px;
				padding: 10px;
				margin-bottom: 12px;
				font-size: 12px;
				color: #1565c0;
			}

			.map-placeholder {
				width: 100%;
				height: 250px;
				background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
							linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
							linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
							linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
				background-size: 20px 20px;
				background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
				border: 2px dashed #ddd;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				color: #666;
				font-weight: 500;
				border-radius: 6px;
				position: relative;
			}

			/* Mobile responsive Optimizations */
			@media (max-width: 768px) {
				.map-canvas-container {
					min-height: 280px;
				} 

				.coordinate-inputs-enhanced {
					grid-template-columns: 1fr;
					gap: 8px;
				}

				.coordinate-display {
					font-size: 8px;
					padding: 3px 6px;
				}

				.map-canvas-container {
					cursor: pointer;
					min-height: 200px;
				} 
 
			}
			/* =================== Image Loading Enhancements =================== */
			.map-image-container {
				position: relative;
				width: 100%;
				height: 100%;
				background: #f5f5f5;
				border-radius: 6px;
				overflow: hidden;
			}

					
			.map-floorplan-image, .map-canvas {
			    width: 100%;
				height: 100%;
				object-fit: contain;  /* ✓ ตั้งค่าถูกต้องแล้ว */
				object-position: center;  /* ⚠️ ต้องเพิ่มบรรทัดนี้ */
				display: block;
			}

			.map-loading-overlay {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(255, 255, 255, 0.9);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				z-index: 5;
			}

			.map-upload-zone {
				border: 2px dashed var(--primary-color);
				border-radius: 10px;
				padding: 20px;
				text-align: center;
				background: rgba(102, 126, 234, 0.05);
				cursor: pointer;
				transition: all 0.3s ease;
				margin-bottom: 15px;
			}

			.map-upload-zone:hover {
				border-color: var(--secondary-color);
				background: rgba(102, 126, 234, 0.1);
			}

			.map-upload-zone.dragover {
				border-color: var(--accent-color);
				background: rgba(40, 167, 69, 0.1);
			}

			.image-controls {
				position: absolute;
				top: 10px;
				right: 10px;
				display: flex;
				gap: 5px;
				z-index: 10;
			}

			.image-control-btn {
				width: 30px;
				height: 30px;
				border-radius: 50%;
				border: none;
				background: rgba(0, 0, 0, 0.7);
				color: white;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 12px;
				transition: all 0.2s ease;
			}

			.image-control-btn:hover {
				background: rgba(0, 0, 0, 0.9);
				transform: scale(1.1);
			}	

		/* ========== Route Control Panel Styles ========== */
		.route-control-panel {
			background: rgba(255, 255, 255, 0.95);
			backdrop-filter: blur(10px);
			border-radius: 15px;
			margin: 15px 0;
			box-shadow: 0 8px 25px rgba(0,0,0,0.1);
			overflow: hidden;
			transition: all 0.3s ease;
		}

		.control-header {
			background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
			color: white;
			padding: 15px 20px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.control-header h3 {
			margin: 0;
			font-size: 16px;
			font-weight: 600;
		}

		.control-toggle {
			background: rgba(255,255,255,0.2);
			border: none;
			color: white;
			padding: 8px;
			border-radius: 50%;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.control-toggle:hover {
			background: rgba(255,255,255,0.3);
			transform: scale(1.1);
		}

		.control-content {
			padding: 20px;
			transition: all 0.3s ease;
		}

		.control-content.collapsed {
			max-height: 0;
			padding: 0 20px;
			overflow: hidden;
		}

		.control-group {
			margin-bottom: 20px;
		}

		.control-group:last-child {
			margin-bottom: 0;
		}

		.control-label {
			display: block;
			font-weight: 600;
			color: var(--text-primary);
			margin-bottom: 10px;
			font-size: 14px;
		}

		.control-label i {
			margin-right: 8px;
			color: var(--primary-color);
		}

		/* Start Point Options */
		.start-point-options {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 10px;
			margin-bottom: 10px;
		}

		.option-btn {
			background: #f8fafc;
			border: 1px solid #e2e8f0;
			border-radius: 10px;
			padding: 12px 15px;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 13px;
		}

		.option-btn:hover {
			background: var(--primary-color);
			color: white;
			border-color: var(--primary-color);
		}

		.option-btn.active {
			background: var(--primary-color);
			color: white;
			border-color: var(--primary-color);
		}

		.selected-point, .selected-destination {
			background: #f0f9ff;
			border: 1px solid #bae6fd;
			border-radius: 8px;
			padding: 10px;
			font-size: 13px;
			color: var(--text-secondary);
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.selected-point.has-selection,
		.selected-destination.has-selection {
			background: #f0fdf4;
			border-color: #bbf7d0;
			color: var(--text-primary);
		}

		/* Destination Selector */
		.destination-selector {
			position: relative;
		}

		.search-input {
			width: 100%;
			padding: 12px 15px;
			border: 1px solid #d1d5db;
			border-radius: 10px;
			font-size: 14px;
			transition: all 0.2s ease;
		}

		.search-input:focus {
			outline: none;
			border-color: var(--primary-color);
			box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
		}

		.search-suggestions {
			position: absolute;
			top: 100%;
			left: 0;
			right: 0;
			background: white;
			border: 1px solid #e5e7eb;
			border-top: none;
			border-radius: 0 0 10px 10px;
			max-height: 200px;
			overflow-y: auto;
			z-index: 1000;
			display: none;
		}

		.search-suggestions.show {
			display: block;
		}

		.suggestion-item {
			padding: 12px 15px;
			cursor: pointer;
			border-bottom: 1px solid #f3f4f6;
			transition: all 0.2s ease;
		}

		.suggestion-item:hover {
			background: #f9fafb;
		}

		.suggestion-item:last-child {
			border-bottom: none;
		}

		/* Route Options */
		.route-options {
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.option-item {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.option-item input[type="radio"],
		.option-item input[type="checkbox"] {
			margin: 0;
		}

		.option-item label {
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 13px;
			cursor: pointer;
			margin: 0;
		}

		/* Action Buttons */
		.action-buttons {
			display: grid;
			grid-template-columns: 1fr auto;
			gap: 10px;
			margin-top: 20px;
		}

		.route-btn {
			background: var(--primary-color);
			color: white;
			border: none;
			padding: 12px 20px;
			border-radius: 10px;
			cursor: pointer;
			font-weight: 600;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
			transition: all 0.2s ease;
			font-size: 14px;
		}

		.route-btn:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
		}

		.route-btn:disabled {
			background: #9ca3af;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
		}

		.route-btn.secondary {
			background: var(--text-secondary);
		}

		.route-btn.secondary:hover {
			box-shadow: 0 4px 15px rgba(107, 114, 128, 0.3);
		}

		/* ========== Route Info Panel ========== */
		.route-info-panel {
			background: rgba(255, 255, 255, 0.95);
			backdrop-filter: blur(10px);
			border-radius: 15px;
			margin: 15px 0;
			padding: 20px;
			box-shadow: 0 8px 25px rgba(0,0,0,0.1);
			animation: slideUp 0.3s ease;
		}

		@keyframes slideUp {
			from {
				opacity: 0;
				transform: translateY(20px);
			}
			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		.route-summary {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 15px;
			margin-bottom: 20px;
		}

		.summary-item {
			background: linear-gradient(135deg, #f8fafc, #e2e8f0);
			border-radius: 12px;
			padding: 15px;
			text-align: center;
			transition: all 0.2s ease;
		}

		.summary-item:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 15px rgba(0,0,0,0.1);
		}

		.summary-icon {
			font-size: 24px;
			margin-bottom: 8px;
		}

		.summary-value {
			font-size: 20px;
			font-weight: bold;
			color: var(--primary-color);
			margin-bottom: 4px;
		}

		.summary-label {
			font-size: 12px;
			color: var(--text-secondary);
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		/* Directions */
		.directions-container {
			margin-bottom: 20px;
		}

		.directions-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 15px;
			padding-bottom: 10px;
			border-bottom: 1px solid #e5e7eb;
		}

		.directions-header h4 {
			margin: 0;
			font-size: 16px;
			color: var(--text-primary);
		}

		.voice-toggle {
			background: #f3f4f6;
			border: none;
			padding: 8px 12px;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.voice-toggle:hover {
			background: var(--primary-color);
			color: white;
		}

		.voice-toggle.active {
			background: var(--accent-color);
			color: white;
		}

		.directions-list {
			max-height: 200px;
			overflow-y: auto;
		}

		.direction-item {
			display: flex;
			align-items: center;
			gap: 15px;
			padding: 12px 0;
			border-bottom: 1px solid #f3f4f6;
		}

		.direction-item:last-child {
			border-bottom: none;
		}

		.direction-step {
			background: var(--primary-color);
			color: white;
			width: 24px;
			height: 24px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 12px;
			font-weight: bold;
			flex-shrink: 0;
		}

		.direction-content {
			flex: 1;
		}

		.direction-instruction {
			font-weight: 600;
			color: var(--text-primary);
			margin-bottom: 2px;
		}

		.direction-distance {
			font-size: 12px;
			color: var(--text-secondary);
		}

		.direction-icon {
			width: 20px;
			text-align: center;
			color: var(--primary-color);
		}

		/* Route Actions */
		.route-actions {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 10px;
		}

		.action-btn {
			background: #f8fafc;
			border: 1px solid #e2e8f0;
			border-radius: 10px;
			padding: 12px 8px;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 5px;
			font-size: 12px;
		}

		.action-btn:hover {
			background: var(--primary-color);
			color: white;
			border-color: var(--primary-color);
		}

		.action-btn i {
			font-size: 16px;
		}

		/* ========== Interactive Elements ========== */
		.walkable-points-layer,
		.route-path-layer,
		.interactive-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
		}

		.interactive-overlay {
			z-index: 200;
		}

		.start-point-indicator,
		.destination-indicator {
			position: absolute;
			transform: translate(-50%, -50%);
			z-index: 201;
		}

		.pulse-ring {
			width: 30px;
			height: 30px;
			border: 2px solid var(--accent-color);
			border-radius: 50%;
			animation: pulse 2s infinite;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		@keyframes pulse {
			0% {
				transform: translate(-50%, -50%) scale(0.8);
				opacity: 1;
			}
			100% {
				transform: translate(-50%, -50%) scale(2);
				opacity: 0;
			}
		}

		.start-dot,
		.destination-dot {
			width: 20px;
			height: 20px;
			background: white;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 12px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.2);
			position: relative;
			z-index: 202;
		}

		/* ========== Responsive Design ========== */
		@media (max-width: 768px) {
			.start-point-options {
				grid-template-columns: 1fr;
			}
			
			.route-summary {
				grid-template-columns: 1fr;
				gap: 10px;
			}
			
			.action-buttons {
				grid-template-columns: 1fr;
			}
			
			.route-actions {
				grid-template-columns: 1fr;
			}
			
			.option-btn {
				padding: 10px 12px;
				font-size: 12px;
			}
			
			.control-content {
				padding: 15px;
			}
			
			.route-info-panel {
				padding: 15px;
			}
		}

		@media (max-width: 480px) {
			.summary-item {
				padding: 12px;
			}
			
			.summary-value {
				font-size: 18px;
			}
			
			.summary-icon {
				font-size: 20px;
			}
			
			.direction-item {
				gap: 10px;
			}
			
			.control-header {
				padding: 12px 15px;
			}
			
			.control-header h3 {
				font-size: 14px;
			}
		}

		/* ========== Admin Walkable Points Styles ========== */
		.admin-walkable-section {
			background: #fff;
			border-radius: 15px;
			padding: 25px;
			margin: 20px 0;
			box-shadow: 0 4px 20px rgba(0,0,0,0.08);
		}

		.walkable-dashboard {
			margin-bottom: 25px;
		}

		.stat-cards {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 15px;
		}

		.stat-card {
			background: linear-gradient(135deg, #f8fafc, #e2e8f0);
			border-radius: 12px;
			padding: 20px;
			display: flex;
			align-items: center;
			gap: 15px;
			transition: all 0.2s ease;
		}

		.stat-card:hover {
			transform: translateY(-3px);
			box-shadow: 0 8px 25px rgba(0,0,0,0.1);
		}

		.stat-card.primary { background: linear-gradient(135deg, var(--primary-color), #4338ca); color: white; }
		.stat-card.success { background: linear-gradient(135deg, var(--accent-color), #059669); color: white; }
		.stat-card.warning { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
		.stat-card.info { background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; }

		.stat-icon {
			font-size: 32px;
			opacity: 0.9;
		}

		.stat-content {
			flex: 1;
		}

		.stat-number {
			font-size: 24px;
			font-weight: bold;
			margin-bottom: 4px;
		}

		.stat-label {
			font-size: 12px;
			opacity: 0.9;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		/* Walkable Canvas */
		.walkable-canvas-container {
			background: #f8fafc;
			border: 1px solid #e2e8f0;
			border-radius: 12px;
			overflow: hidden;
			margin-bottom: 25px;
		}

		.canvas-header {
			background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
			color: white;
			padding: 15px 20px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.canvas-header h4 {
			margin: 0;
			font-size: 16px;
		}

		.canvas-controls {
			display: flex;
			gap: 8px;
		}

		.canvas-btn {
			background: rgba(255,255,255,0.2);
			border: none;
			color: white;
			padding: 8px;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.canvas-btn:hover {
			background: rgba(255,255,255,0.3);
		}

		.walkable-canvas {
			position: relative;
			min-height: 400px;
			background: #fff;
			overflow: hidden;
		}

		.canvas-background {
			width: 100%;
			height: 100%;
			object-fit: contain;
			opacity: 0.7;
		}

		.grid-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			opacity: 0.3;
			background-image: 
				linear-gradient(to right, #e5e7eb 1px, transparent 1px),
				linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
			background-size: 20px 20px;
			display: none;
		}

		.grid-overlay.show {
			display: block;
		}

		.walkable-svg {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 100;
		}

		.points-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 200;
		}

		.canvas-info-bar {
			background: #f3f4f6;
			padding: 10px 20px;
			display: flex;
			gap: 20px;
			font-size: 12px;
			border-top: 1px solid #e5e7eb;
		}

		.info-item {
			display: flex;
			gap: 5px;
			align-items: center;
		}

		.info-label {
			color: var(--text-secondary);
			font-weight: 500;
		}

		.info-value {
			color: var(--text-primary);
			font-weight: 600;
		}

		/* Tools Panel */
		.walkable-tools-panel {
			background: #f8fafc;
			border: 1px solid #e2e8f0;
			border-radius: 12px;
			padding: 20px;
			margin-bottom: 25px;
		}

		.tool-groups {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
			gap: 20px;
			margin-bottom: 20px;
		}

		.tool-group h5 {
			margin: 0 0 15px 0;
			color: var(--text-primary);
			font-size: 14px;
			font-weight: 600;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.tool-buttons {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 8px;
		}

		.tool-btn {
			background: white;
			border: 1px solid #d1d5db;
			border-radius: 8px;
			padding: 10px 8px;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 5px;
			font-size: 11px;
			text-align: center;
		}

		.tool-btn:hover {
			background: var(--primary-color);
			color: white;
			border-color: var(--primary-color);
		}

		.tool-btn.active {
			background: var(--primary-color);
			color: white;
			border-color: var(--primary-color);
			box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
		}

		.tool-btn i {
			font-size: 16px;
		}

		/* Settings Panel */
		.settings-panel {
			border-top: 1px solid #e5e7eb;
			padding-top: 20px;
		}

		.settings-panel h5 {
			margin: 0 0 15px 0;
			color: var(--text-primary);
			font-size: 14px;
			font-weight: 600;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.setting-groups {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 15px;
		}

		.setting-item {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.setting-item label {
			font-size: 12px;
			font-weight: 500;
			color: var(--text-primary);
		}

		.setting-item input[type="range"] {
			width: 100%;
		}

		.setting-item input[type="number"],
		.setting-item input[type="checkbox"] {
			padding: 6px 8px;
			border: 1px solid #d1d5db;
			border-radius: 6px;
			font-size: 12px;
		}

		.setting-value {
			font-size: 12px;
			color: var(--primary-color);
			font-weight: 600;
		}

		/* Walkable Actions */
		.walkable-actions {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
			justify-content: center;
		}

		.walkable-actions .btn {
			flex: 1;
			min-width: 140px;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
		}

		@media (max-width: 768px) {
			.tool-groups {
				grid-template-columns: 1fr;
			}
			
			.tool-buttons {
				grid-template-columns: repeat(2, 1fr);
			}
			
			.setting-groups {
				grid-template-columns: 1fr;
			}
			
			.stat-cards {
				grid-template-columns: repeat(2, 1fr);
			}
			
			.canvas-controls {
				flex-wrap: wrap;
			}
			
			.walkable-actions {
				flex-direction: column;
			}
			
			.walkable-actions .btn {
				min-width: auto;
			}
		}	
				
    </style>
	<script>
			// เพิ่มใน admin.html

		// Add CSS for walkable points management
		const walkablePointsCSS = `
		<style>
			/* Walkable Points Management Styles */
			.walkable-section {
				background: #fff;
				border-radius: 15px;
				padding: 20px;
				margin-bottom: 20px;
				box-shadow: 0 4px 15px rgba(0,0,0,0.1);
			}
			
			.walkable-header {
				display: flex;
				justify-content: between;
				align-items: center;
				margin-bottom: 15px;
				padding-bottom: 10px;
				border-bottom: 2px solid var(--primary-color);
			}
			
			.walkable-controls {
				display: flex;
				gap: 10px;
				flex-wrap: wrap;
				margin-bottom: 15px;
			}
			
			.walkable-btn {
				background: var(--primary-color);
				color: white;
				border: none;
				padding: 10px 15px;
				border-radius: 8px;
				cursor: pointer;
				display: flex;
				align-items: center;
				gap: 8px;
				font-size: 13px;
				transition: all 0.2s ease;
			}
			.walkable-btn:hover { opacity: 0.9; transform: translateY(-1px); }
			.walkable-btn.secondary { background: var(--text-secondary); }
			.walkable-btn.danger { background: var(--danger-color); }
			.walkable-btn.success { background: var(--accent-color); }
			
			.walkable-map-container {
				position: relative;
				border: 2px solid #e2e8f0;
				border-radius: 12px;
				overflow: hidden;
				background: #f8fafc;
				min-height: 400px;
				margin-bottom: 15px;
			}
			
			.walkable-overlay {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
				z-index: 100;
			}
			
			.walkable-node {
				position: absolute;
				width: 12px;
				height: 12px;
				background: #10b981;
				border: 2px solid #fff;
				border-radius: 50%;
				cursor: pointer;
				transform: translate(-50%, -50%);
				transition: all 0.2s ease;
				pointer-events: all;
				box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
			}
			.walkable-node:hover {
				background: #f59e0b;
				transform: translate(-50%, -50%) scale(1.2);
				box-shadow: 0 4px 15px rgba(245, 158, 11, 0.5);
			}
			.walkable-node.selected {
				background: #dc2626;
				box-shadow: 0 4px 15px rgba(220, 38, 38, 0.6);
			}
			
			.walkable-edge {
				stroke: #cbd5e1;
				stroke-width: 2;
				fill: none;
				opacity: 0.6;
				transition: all 0.2s ease;
			}
			.walkable-edge:hover {
				stroke: var(--primary-color);
				stroke-width: 3;
				opacity: 1;
			}
			
			.walkable-stats {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
				gap: 15px;
				margin-bottom: 20px;
			}
			
			.stat-card {
				background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
				color: Green;
				padding: 15px;
				border-radius: 12px;
				text-align: center;
			}
			.stat-value {
				font-size: 24px;
				font-weight: bold;
				margin-bottom: 5px;
			}
			.stat-label {
				font-size: 12px;
				opacity: 0.9;
			}
			
			.walkable-settings {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 15px;
				margin-bottom: 20px;
			}
			
			.setting-group {
				background: #f8fafc;
				padding: 15px;
				border-radius: 10px;
				border: 1px solid #e2e8f0;
			}
			.setting-label {
				font-weight: 600;
				margin-bottom: 8px;
				color: var(--text-primary);
			}
			.setting-input {
				width: 100%;
				padding: 8px 12px;
				border: 1px solid #cbd5e1;
				border-radius: 6px;
				font-size: 13px;
			}
			.setting-help {
				font-size: 11px;
				color: var(--text-secondary);
				margin-top: 5px;
			}
			
			.export-section {
				background: #f8fafc;
				border: 1px solid #e2e8f0;
				border-radius: 10px;
				padding: 15px;
				margin-top: 20px;
			}
			
			.export-textarea {
				width: 100%;
				height: 120px;
				padding: 10px;
				border: 1px solid #cbd5e1;
				border-radius: 6px;
				font-family: monospace;
				font-size: 12px;
				resize: vertical;
			}
			
			@media (max-width: 768px) {
				.walkable-controls {
					flex-direction: column;
				}
				.walkable-btn {
					justify-content: center;
				}
				.walkable-settings {
					grid-template-columns: 1fr;
				}
			}
		</style>
		`;

		// ========== 2. CSS Styles (เพิ่มใน <style>) ==========
				const WALKABLE_UI_STYLES = `
				.sync-status {
					padding: 6px 12px;
					border-radius: 15px;
					font-size: 12px;
					font-weight: 500;
					display: inline-block;
					transition: all 0.3s ease;
				}
				.sync-status.idle { background: #e9ecef; color: #6c757d; }
				.sync-status.syncing { background: #cce5ff; color: #0066cc; animation: pulse 1.5s infinite; }
				.sync-status.success { background: #d4edda; color: #155724; }
				.sync-status.error { background: #f8d7da; color: #721c24; }

				.sync-progress {
					width: 100%;
					height: 4px;
					background: #e9ecef;
					border-radius: 2px;
					overflow: hidden;
					margin-top: 5px;
				}
				.progress-bar {
					height: 100%;
					background: linear-gradient(90deg, #007bff, #0056b3);
					width: 0%;
					transition: width 0.3s ease;
					animation: shimmer 1s infinite;
				}

				.error-log {
					background: #fff3cd;
					border: 1px solid #ffeaa7;
					border-radius: 6px;
					padding: 8px;
					max-height: 100px;
					overflow-y: auto;
				}
				.error-item {
					font-size: 11px;
					color: #856404;
					margin-bottom: 4px;
					word-break: break-word;
				}

				@keyframes pulse {
					0%, 100% { opacity: 1; }
					50% { opacity: 0.7; }
				}
				@keyframes shimmer {
					0% { transform: translateX(-100%); }
					100% { transform: translateX(100%); }
				}

				.btn-sm {
					padding: 4px 8px;
					font-size: 11px;
					border-radius: 4px;
				}
				`;
		// Add walkable points CSS to head
		document.head.insertAdjacentHTML('beforeend', walkablePointsCSS);


// 🔗 Admin-Index Integration Bridge V1.3
		// ========== 1. Compatibility Analysis ==========
		/* 
		🔍 CONFLICTS DETECTED:

		Admin.html ใช้:
		- walkablePointsData (global object)
		- Dynamic node creation (click to add)
		- localStorage key: walkableData_${building}
		- Manual node management via UI

		Index.html ใช้:
		- walkableRoutingData (global object) 
		- Fixed grid system (48 nodes)
		- localStorage key: walkableData_${building} (SAME!)
		- Automatic grid generation

		❌ CONFLICT: Data structure และ management approach ต่างกัน
		✅ SOLUTION: สร้าง integration bridge
		*/

		// ========== 2. Data Structure Bridge ==========

		// สร้าง bridge object เพื่อ sync ข้อมูลระหว่าง admin และ index
		const ADMIN_INDEX_BRIDGE = {
			// ตรวจสอบว่าอยู่ในโหมดไหน
			isAdminMode: () => window.location.pathname.includes('admin.html'),
			isIndexMode: () => window.location.pathname.includes('index.html'),
			
			// Data format mapping
			adminFormat: 'walkablePointsData',
			indexFormat: 'walkableRoutingData',
			
			// Sync settings
			syncEnabled: true,
			autoSyncOnChange: true,
			adminHasPriority: true,  // Admin data มีความสำคัญสูงกว่า
			lastSyncTime: null,
			
			// Storage key management (🚨 FIXED: แยก keys แล้ว!)
			getStorageKey: (building, mode) => {
				if (!building) building = 'Main Building';
				return `walkableData_${building.replace(/\s+/g, '')}_${mode}`;
			},
				
			
			// Compatibility flags
			preserveFixedGrid: false, // ไม่บังคับใช้ fixed grid ถ้า admin มีข้อมูล
			allowDynamicNodes: true,   // อนุญาตให้ admin เพิ่ม nodes ได้
			maxDataAge: 24 * 60 * 60 * 1000, // 24 ชั่วโมง (milliseconds)
			
			// Status tracking
			lastConversionError: null,
			conversionCount: 0,
			debugMode: true    
		};

		// ========== 3. Data Format Converter ==========

		// แปลงจาก admin format เป็น index format
		function convertAdminToIndexFormat(adminData) {
			if (!adminData || !adminData.nodes) return null;
			
			debugLog('🔄 Converting admin data to index format...', {
				adminNodes: Object.keys(adminData.nodes).length,
				adminEdges: adminData.edges ? adminData.edges.length : 0
			});
			
			const indexData = {
				nodes: {},
				edges: [],
				settings: {
					metersPerPercent: adminData.settings?.metersPerPercent || 1.2,
					maxSearchRadius: adminData.settings?.maxConnectionDistance || 25,
					defaultWalkSpeed: 1.5
				},
				currentBuilding: adminData.building || adminData.currentBuilding,
				lastPath: null,
				isInitialized: true,
				dataSource: 'admin',
				syncTime: new Date().toISOString()
			};
			
			// แปลง nodes
			Object.values(adminData.nodes).forEach(node => {
				indexData.nodes[node.id] = {
					id: node.id,
					x: node.x,
					y: node.y,
					type: node.type || 'admin',  // mark as admin-created
					building: node.building || indexData.currentBuilding,
					isFixed: false,  // admin nodes ไม่ใช่ fixed
					source: 'admin'
				};
			});
			
			// แปลง edges
			if (adminData.edges && Array.isArray(adminData.edges)) {
				adminData.edges.forEach(edge => {
					indexData.edges.push({
						from: edge.from,
						to: edge.to,
						weight: edge.weight,
						bidirectional: edge.bidirectional !== false,
						type: 'admin',
						source: 'admin'
					});
				});
			}
			
			debugLog('✅ Admin to index conversion completed:', {
				convertedNodes: Object.keys(indexData.nodes).length,
				convertedEdges: indexData.edges.length
			});
			
			return indexData;
		}

		// แปลงจาก index format เป็น admin format
		function convertIndexToAdminFormat(indexData) {
			if (!indexData || !indexData.nodes) return null;
			
			debugLog('🔄 Converting index data to admin format...', {
				indexNodes: Object.keys(indexData.nodes).length,
				indexEdges: indexData.edges ? indexData.edges.length : 0
			});
			
			const adminData = {
				currentBuilding: indexData.currentBuilding,
				building: indexData.currentBuilding,
				nodes: {},
				edges: [],
				settings: {
					maxConnectionDistance: indexData.settings?.maxSearchRadius || 25,
					metersPerPercent: indexData.settings?.metersPerPercent || 1.2,
					autoConnect: true,
					snapToGrid: false,
					gridSize: 5
				},
				selectedNodes: new Set(),
				isDragging: false,
				dragNode: null,
				dataSource: 'index',
				syncTime: new Date().toISOString()
			};
			
			// แปลง nodes
			Object.values(indexData.nodes).forEach(node => {
				adminData.nodes[node.id] = {
					id: node.id,
					x: node.x,
					y: node.y,
					type: node.type || 'grid',
					building: node.building || adminData.currentBuilding,
					source: node.source || 'index'
				};
			});
			
			// แปลง edges
			if (indexData.edges && Array.isArray(indexData.edges)) {
				indexData.edges.forEach(edge => {
					adminData.edges.push({
						from: edge.from,
						to: edge.to,
						weight: edge.weight,
						bidirectional: edge.bidirectional !== false,
						source: edge.source || 'index'
					});
				});
			}
			
			debugLog('✅ Index to admin conversion completed:', {
				convertedNodes: Object.keys(adminData.nodes).length,
				convertedEdges: adminData.edges.length
			});
			
			return adminData;
		}

		// ========== 4. Smart Data Sync ==========

		// อัปเดตข้อมูลใน index.html จาก admin data
		function syncAdminDataToIndex(building) {
			if (!ADMIN_INDEX_BRIDGE.isIndexMode()) return false;
			
			debugLog('📥 Syncing admin data to index...', { building });
			
			try {
				// โหลดข้อมูลจาก admin
				const storageKey = `walkableData_${building}`;
				const adminDataString = localStorage.getItem(storageKey);
				
				if (!adminDataString) {
					debugLog('⚠️ No admin data found, using fixed grid');
					return false;
				}
				
				const adminData = JSON.parse(adminDataString);
				
				// ตรวจสอบว่าเป็นข้อมูลจาก admin หรือไม่
				if (adminData.dataSource === 'index') {
					debugLog('ℹ️ Data source is index, no sync needed');
					return false;
				}
				
				// แปลงเป็น index format
				const indexData = convertAdminToIndexFormat(adminData);
				if (!indexData) {
					debugLog('❌ Failed to convert admin data');
					return false;
				}
				
				// อัปเดต walkableRoutingData
				if (typeof walkableRoutingData !== 'undefined') {
					Object.assign(walkableRoutingData, indexData);
					debugLog('✅ walkableRoutingData updated from admin');
				}
				
				// อัปเดต localStorage สำหรับ index
				const indexStorageKey = `walkableData_${building}_index`;
				localStorage.setItem(indexStorageKey, JSON.stringify(indexData));
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('✅ Admin data synced to index successfully');
				return true;
				
			} catch (error) {
				debugLog('❌ Error syncing admin data to index:', error);
				return false;
			}
		}

		// อัปเดตข้อมูลใน admin.html จาก index data
		function syncIndexDataToAdmin(building) {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) return false;
			
			debugLog('📤 Syncing index data to admin...', { building });
			
			try {
				// โหลดข้อมูลจาก index
				const indexStorageKey = `walkableData_${building}_index`;
				const indexDataString = localStorage.getItem(indexStorageKey);
				
				if (!indexDataString) {
					debugLog('⚠️ No index data found');
					return false;
				}
				
				const indexData = JSON.parse(indexDataString);
				
				// แปลงเป็น admin format
				const adminData = convertIndexToAdminFormat(indexData);
				if (!adminData) {
					debugLog('❌ Failed to convert index data');
					return false;
				}
				
				// อัปเดต walkablePointsData
				if (typeof walkablePointsData !== 'undefined') {
					Object.assign(walkablePointsData, adminData);
					
					// Render ใหม่ถ้ามีฟังก์ชัน
					if (typeof renderWalkablePoints === 'function') {
						renderWalkablePoints();
					}
					if (typeof updateWalkableStats === 'function') {
						updateWalkableStats();
					}
					
					debugLog('✅ walkablePointsData updated from index');
				}
				
				ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
				
				debugLog('✅ Index data synced to admin successfully');
				return true;
				
			} catch (error) {
				debugLog('❌ Error syncing index data to admin:', error);
				return false;
			}
		}

		// ========== 5. Automatic Sync Triggers ==========

		// ตรวจสอบและ sync อัตโนมัติเมื่อโหลดหน้า
		function autoSyncOnPageLoad() {
			if (!ADMIN_INDEX_BRIDGE.syncEnabled) return;
			
			const building = getCurrentBuilding();
			if (!building) return;
			
			debugLog('🔄 Auto-sync on page load...', { 
				building, 
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode()
			});
			
			if (ADMIN_INDEX_BRIDGE.isIndexMode()) {
				// ใน index.html - ลองโหลดข้อมูลจาก admin ก่อน
				const adminSynced = syncAdminDataToIndex(building);
				
				if (!adminSynced) {
					debugLog('📋 No admin data available, creating fixed grid for index');
					// สร้าง fixed grid ตามปกติ
					if (typeof createFixedWalkableGrid === 'function') {
						createFixedWalkableGrid();
					}
				} else {
					debugLog('✅ Using admin-created walkable points in index');
				}
				
			} else if (ADMIN_INDEX_BRIDGE.isAdminMode()) {
				// ใน admin.html - โหลดข้อมูลปกติ
				debugLog('📋 Admin mode: Using standard admin data loading');
			}
		}

		// ========== 6. Enhanced Integration Functions ==========

		// แทนที่ฟังก์ชัน loadWalkableData เดิมใน index.html
		function loadWalkableDataWithAdminSync() {
			const building = getCurrentBuilding();
			const storageKey = `walkableData_${building}`;
			const indexStorageKey = `walkableData_${building}_index`;
			
			debugLog('📁 Loading walkable data with admin sync...', { building });
			
			// ลองโหลดจาก admin ก่อน
			const adminSynced = syncAdminDataToIndex(building);
			
			if (adminSynced) {
				debugLog('✅ Loaded admin-created walkable data');
				return;
			}
			
			// ถ้าไม่มีข้อมูลจาก admin ให้ลองโหลดจาก index cache
			const indexDataString = localStorage.getItem(indexStorageKey);
			if (indexDataString) {
				try {
					const data = JSON.parse(indexDataString);
					Object.assign(walkableRoutingData, data);
					debugLog('📁 Loaded cached index walkable data');
					return;
				} catch (error) {
					debugLog('⚠️ Error loading cached data:', error);
				}
			}
			
			// สุดท้ายถ้าไม่มีข้อมูลใดๆ ให้สร้าง fixed grid
			debugLog('🏗️ No existing data, creating fixed grid');
			if (typeof createFixedWalkableGrid === 'function') {
				createFixedWalkableGrid();
			}
		}

		// ปรับปรุงฟังก์ชัน saveWalkableData ใน admin.html
		function enhancedSaveWalkableData() {
			// ป้องกัน infinite loop โดยไม่เรียก saveWalkableData() ซ้ำ
			if (_saveInProgress) {
				debugLog('⚠️ Enhanced save already in progress...');
				return;
			}
			
			// เรียกใช้ saveWalkableDataEnhanced โดยตรง
			return saveWalkableDataEnhanced();
		}

		// ========== 7. UI Integration Helpers ==========

		// เพิ่ม sync status indicator ใน admin
		function addSyncStatusIndicator() {
			if (!ADMIN_INDEX_BRIDGE.isAdminMode()) return;
			
			const header = document.querySelector('.walkable-header');
			if (!header || document.getElementById('syncStatus')) return;
			
			const syncStatus = document.createElement('div');
			syncStatus.id = 'syncStatus';
			syncStatus.className = 'sync-status';
			syncStatus.innerHTML = `
				<div class="sync-indicator">
					<i class="fas fa-sync"></i>
					<span>Sync Ready</span>
				</div>
			`;
			
			// เพิ่ม CSS
			const style = document.createElement('style');
			style.textContent = `
				.sync-status {
					display: flex;
					align-items: center;
					gap: 8px;
					font-size: 12px;
					color: var(--text-secondary);
				}
				
				.sync-indicator {
					display: flex;
					align-items: center;
					gap: 4px;
					padding: 4px 8px;
					background: #f0f9ff;
					border: 1px solid #bae6fd;
					border-radius: 4px;
				}
				
				.sync-indicator.syncing {
					background: #fef3c7;
					border-color: #fcd34d;
				}
				
				.sync-indicator.synced {
					background: #dcfce7;
					border-color: #86efac;
				}
				
				.sync-indicator i {
					font-size: 10px;
				}
				
				.sync-indicator.syncing i {
					animation: spin 1s linear infinite;
				}
				
				@keyframes spin {
					from { transform: rotate(0deg); }
					to { transform: rotate(360deg); }
				}
			`;
			document.head.appendChild(style);
			
			header.appendChild(syncStatus);
		}

		// อัปเดต sync status
		function updateSyncStatus(status, message) {
			const indicator = document.querySelector('.sync-indicator');
			if (!indicator) return;
			
			indicator.className = `sync-indicator ${status}`;
			
			const statusMessages = {
				ready: '🔄 พร้อม sync',
				syncing: '⏳ กำลัง sync...',
				synced: '✅ Sync แล้ว',
				error: '❌ Sync ผิดพลาด'
			};
			
			indicator.querySelector('span').textContent = message || statusMessages[status] || status;
		}

		// ========== 8. Debug and Monitoring ==========

		// ตรวจสอบสถานะ compatibility
		function debugCompatibilityStatus() {
			console.group('🔍 Admin-Index Compatibility Status');
			
			console.log('Environment:', {
				isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
				isIndex: ADMIN_INDEX_BRIDGE.isIndexMode(),
				syncEnabled: ADMIN_INDEX_BRIDGE.syncEnabled
			});
			
			// ตรวจสอบ global objects
			const adminDataExists = typeof walkablePointsData !== 'undefined';
			const indexDataExists = typeof walkableRoutingData !== 'undefined';
			
			console.log('Global Objects:', {
				walkablePointsData: adminDataExists ? 'EXISTS' : 'NOT FOUND',
				walkableRoutingData: indexDataExists ? 'EXISTS' : 'NOT FOUND'
			});
			
			// ตรวจสอบข้อมูลใน localStorage
			const building = getCurrentBuilding();
			if (building) {
				const adminKey = `walkableData_${building}`;
				const indexKey = `walkableData_${building}_index`;
				
				const adminData = localStorage.getItem(adminKey);
				const indexData = localStorage.getItem(indexKey);
				
				console.log('LocalStorage Data:', {
					adminData: adminData ? 'EXISTS' : 'NOT FOUND',
					indexData: indexData ? 'EXISTS' : 'NOT FOUND',
					lastSync: ADMIN_INDEX_BRIDGE.lastSyncTime
				});
				
				if (adminData) {
					try {
						const parsed = JSON.parse(adminData);
						console.log('Admin Data Summary:', {
							nodes: Object.keys(parsed.nodes || {}).length,
							edges: (parsed.edges || []).length,
							source: parsed.dataSource,
							building: parsed.building || parsed.currentBuilding
						});
					} catch (e) {
						console.warn('⚠️ Admin data parsing error:', e);
					}
				}
			}
			
			console.log('Sync Status:', ADMIN_INDEX_BRIDGE);
			console.groupEnd();
		}

		// ========== 9. Auto-Initialize Integration ==========

		// Initialize integration bridge
		function initializeAdminIndexBridge() {
			debugLog('🌉 Initializing Admin-Index Integration Bridge...');
			
			try {
				// ตรวจสอบ environment
				const isAdmin = ADMIN_INDEX_BRIDGE.isAdminMode();
				const isIndex = ADMIN_INDEX_BRIDGE.isIndexMode();
				
				debugLog('Environment detection:', { isAdmin, isIndex });
				
				if (isAdmin) {
					// Admin mode setup
					addSyncStatusIndicator();
					updateSyncStatus('ready');
					
					// Hook into save function (แก้ไขเพื่อป้องกัน infinite loop)
					if (typeof window.saveWalkableData === 'function') {
						// Backup original function
						if (!window.originalSaveWalkableData) {
							window.originalSaveWalkableData = window.saveWalkableData;
						}
						
						// แทนที่ด้วยเวอร์ชันที่แก้ไขแล้ว
						window.saveWalkableData = saveWalkableDataEnhanced;
					}
										
				} else if (isIndex) {
					// Index mode setup
					autoSyncOnPageLoad();
					
					// แทนที่ฟังก์ชัน loadWalkableData
					if (typeof window.loadWalkableData === 'function') {
						window.originalLoadWalkableData = window.loadWalkableData;
						window.loadWalkableData = loadWalkableDataWithAdminSync;
					}
				}
				
				debugLog('✅ Admin-Index Integration Bridge initialized');
				
			} catch (error) {
				debugLog('❌ Error initializing bridge:', error);
			}
		}

		// Auto-initialize based on page type
		document.addEventListener('DOMContentLoaded', function() {
			setTimeout(() => {
				initializeAdminIndexBridge();
				
				// Debug compatibility after initialization
				setTimeout(() => {
					debugCompatibilityStatus();
				}, 2000);
				
			}, 1000);
		});

		// Export bridge functions
		window.adminIndexBridge = {
			sync: {
				adminToIndex: syncAdminDataToIndex,
				indexToAdmin: syncIndexDataToAdmin,
				auto: autoSyncOnPageLoad
			},
			convert: {
				adminToIndex: convertAdminToIndexFormat,
				indexToAdmin: convertIndexToAdminFormat
			},
			debug: debugCompatibilityStatus,
			config: ADMIN_INDEX_BRIDGE
		};
	//******************* End Admin-index Integration bridge *********************
	</script>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-container" id="loginContainer">
        <div class="login-card">
            <div class="login-header">
                <div class="login-logo">🔐</div>
                <h2 class="login-title">Admin Panel Login</h2>
                <p class="login-subtitle">ระบบแผนที่โรงเรียนอัจฉริยะ V1.3 <br>Enhanced: Dikstra Admin-Index Integrtaion Bridge (Fixed)</p>
            </div>
            
            <form class="login-form" onsubmit="handleLogin(event)">
                <div class="login-form-group">
                    <label class="login-label">Username</label>
                    <input type="text" class="login-input" id="loginUsername" placeholder="กรอก username" required>
                </div>
                
                <div class="login-form-group">
                    <label class="login-label">Password</label>
                    <input type="password" class="login-input" id="loginPassword" placeholder="กรอก password" required>
                </div>
                
                <button type="submit" class="login-btn">
                    <i class="fas fa-sign-in-alt"></i> เข้าสู่ระบบ
                </button>
                
                <div class="login-error" id="loginError"></div>
                
                <div class="login-info">
                    <strong>ข้อมูลการเข้าสู่ระบบ:</strong><br>
                    Username: <code>admin</code><br>
                    Password: <code>1234</code>
                </div>
            </form>
        </div>
    </div>

    <!-- Sequential Loading Screen -->
    <div class="sequential-loading" id="sequentialLoading">
        <div class="loading-content">
            <h3 style="margin-bottom: 20px; color: var(--primary-color);">
                <i class="fas fa-cog fa-spin"></i> กำลังโหลดระบบ
            </h3>
            <div class="loading-steps" id="loadingSteps">
                <div class="loading-step" id="step-connection">
                    <div class="step-icon pending">1</div>
                    <div class="step-text">ตรวจสอบการเชื่อมต่อ Google Sheets</div>
                </div>
                <div class="loading-step" id="step-buildings">
                    <div class="step-icon pending">2</div>
                    <div class="step-text">โหลดข้อมูลอาคาร</div>
                </div>
                <div class="loading-step" id="step-rooms">
                    <div class="step-icon pending">3</div>
                    <div class="step-text">โหลดข้อมูลห้อง</div>
                </div>
                <div class="loading-step" id="step-ui">
                    <div class="step-icon pending">4</div>
                    <div class="step-text">อัปเดต UI และแดชบอร์ด</div>
                </div>
            </div>
            <p style="color: var(--text-secondary); font-size: 12px; margin-top: 20px;">
                กรุณารอสักครู่ ระบบกำลังโหลดข้อมูลแบบ Sequential
            </p>
        </div>
    </div>

    <!-- Main Admin Interface -->
    <div class="admin-container" id="adminContainer" style="display: none;">
        <!-- Desktop Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="sidebar-toggle" onclick="toggleSidebar()">
                    <i class="fas fa-bars"></i>
                </button>
                <h2>🏫 Admin Panel</h2>
                <p>ระบบจัดการแผนที่โรงเรียน V1.3 <br>Enhanced: Dikstra Admin-Index Integrtaion Bridge </p>
            </div>

            <!-- ======================== Updated Sidebar Menu ======================== -->
			<!-- แทนที่ sidebar-menu เดิมด้วยเนื้อหานี้ -->
			<div class="sidebar-menu">
				<div class="menu-item active" onclick="showSection('dashboard')">
					<i class="fas fa-tachometer-alt"></i>
					<span class="menu-text">แดชบอร์ด</span>
				</div>
				<div class="menu-item" onclick="showSection('buildings')">
					<i class="fas fa-building"></i>
					<span class="menu-text">จัดการอาคาร</span>
				</div>
				<div class="menu-item" onclick="showSection('rooms')">
					<i class="fas fa-door-open"></i>
					<span class="menu-text">จัดการห้อง</span>
				</div>
				<div class="menu-item" onclick="showSection('maps')">
					<i class="fas fa-map"></i>
					<span class="menu-text">จัดการแผนที่</span>
				</div>
				<div class="menu-item" onclick="showSection('sheets')">
					<i class="fas fa-table"></i>
					<span class="menu-text">Google Sheets</span>
				</div>
				<div class="menu-item" onclick="showSection('deployment')">
					<i class="fas fa-rocket"></i>
					<span class="menu-text">Deploy Guide</span>
				</div>
				<div class="menu-item" onclick="openUserInterface()">
					<i class="fas fa-external-link-alt"></i>
					<span class="menu-text">เปิดหน้าผู้ใช้</span>
				</div>
			</div>
        </div>

       <!-- ======================== Updated Mobile Navigation ======================== -->
		<!-- แทนที่ mobile-nav เดิมด้วยเนื้อหานี้ -->
		<div class="mobile-nav" id="mobileNav">
			<div class="mobile-nav-item active" onclick="showSection('dashboard')">
				<i class="fas fa-tachometer-alt"></i>
				<span>แดช</span>
			</div>
			<div class="mobile-nav-item" onclick="showSection('buildings')">
				<i class="fas fa-building"></i>
				<span>อาคาร</span>
			</div>
			<div class="mobile-nav-item" onclick="showSection('rooms')">
				<i class="fas fa-door-open"></i>
				<span>ห้อง</span>
			</div>
			<div class="mobile-nav-item" onclick="showSection('maps')">
				<i class="fas fa-map"></i>
				<span>แผนที่</span>
			</div>
			<div class="mobile-nav-item" onclick="showSection('sheets')">
				<i class="fas fa-table"></i>
				<span>Sheets</span>
			</div>
			<div class="mobile-nav-item" onclick="openMoreMenu()">
				<i class="fas fa-ellipsis-h"></i>
				<span>เพิ่ม</span>
			</div>
		</div>

		<!-- Mobile More Menu (Dropdown) -->
		<div id="mobileMoreMenu" class="mobile-more-menu" style="display: none; position: fixed; bottom: 70px; right: 10px; background: white; border-radius: 10px; box-shadow: 0 8px 25px rgba(0,0,0,0.15); z-index: 2000; min-width: 150px;">
			<div class="more-menu-item" onclick="showSection('deployment'); closeMobileMoreMenu();" style="padding: 15px 20px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 10px;">
				<i class="fas fa-rocket" style="color: var(--primary-color);"></i>
				<span>Deploy Guide</span>
			</div>
			<div class="more-menu-item" onclick="openUserInterface(); closeMobileMoreMenu();" style="padding: 15px 20px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
				<i class="fas fa-external-link-alt" style="color: var(--accent-color);"></i>
				<span>หน้าผู้ใช้</span>
			</div>
		</div>

        <!-- Main Content -->
        <div class="main-content" id="mainContent">
            <!-- Header -->
            <div class="main-header">
                <!-- Global Status Indicator -->
                <div style="position: absolute; top: 5px; left: 30px; right: 30px; text-align: center; z-index: 200;">
                    <span id="globalStatusIndicator" class="status-indicator status-connected" style="font-size: 11px; padding: 4px 12px;">
                        <i class="fas fa-check-circle"></i> SYSTEM READY
                    </span>
                </div>
                <h1 class="header-title" id="pageTitle">แดชบอร์ด</h1>
                <div class="header-actions">
                    <button class="header-btn primary" onclick="sequentialLoadData()">
                        <i class="fas fa-sync-alt"></i>
                        <span>Reload Data</span>
                    </button>
                    <button class="header-btn logout-btn" onclick="handleLogout()">
                        <i class="fas fa-sign-out-alt"></i>
                        <span>Logout</span>
                    </button>
                </div>
            </div>

            <!-- Content Area -->
            <div class="content-area">
                <!-- ======================== Dashboard Section ======================== -->
                <div class="page-section active" id="dashboard-section">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">🏢</div>
                            <div class="stat-number" id="buildingCount">0</div>
                            <div class="stat-label">อาคารทั้งหมด</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">🚪</div>
                            <div class="stat-number" id="roomCount">0</div>
                            <div class="stat-label">ห้องทั้งหมด</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">📊</div>
                            <div class="stat-number" id="activeRooms">0</div>
                            <div class="stat-label">ห้องที่ใช้งาน</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">🔗</div>
                            <div class="stat-number" id="connectionStatus">กำลังตรวจสอบ</div>
                            <div class="stat-label">สถานะ Google Sheets</div>
                        </div>
                    </div>

                    <div class="admin-card">
                        <div class="card-header">
                            <h3 class="card-title">
                                <i class="fas fa-chart-line"></i>
                                ข้อมูลการใช้งานระบบ
                            </h3>
                        </div>
                        <div style="text-align: center; padding: 40px;">
                            <i class="fas fa-chart-bar" style="font-size: 64px; color: var(--primary-color); opacity: 0.3; margin-bottom: 20px;"></i>
                            <p style="color: var(--text-secondary);">กราฟและสถิติการใช้งานจะแสดงที่นี่</p>
                        </div>
                    </div>
                </div>

                <!-- ======================== Buildings Management Section ======================== -->
                <div class="page-section" id="buildings-section">
                    <div class="admin-card">
                         <div class="enhanced-card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--border-color); flex-wrap: wrap; gap: 15px;">
							<h3 class="card-title" style="margin: 0;">
								<i class="fas fa-building"></i>
								จัดการอาคาร
							</h3>
							
							<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
								<!-- Quick Search -->
								<div style="position: relative;">
									<input type="text" placeholder="ค้นหาอาคาร..." 
										   style="padding: 8px 35px 8px 12px; border: 1px solid var(--border-color); border-radius: 20px; font-size: 14px; width: 200px;" 
										   id="buildingQuickSearch" 
										   oninput="quickSearchBuildings(this.value)">
									<i class="fas fa-search" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); font-size: 12px;"></i>
								</div>
								
								<!-- Filter Button -->
								<button class="btn btn-sm btn-info" onclick="openFilterModal()" title="ตัวกรองขั้นสูง">
									<i class="fas fa-filter"></i>
								</button>
								
								<!-- Add Button -->
								<button class="btn btn-primary" onclick="openBuildingModal()">
									<i class="fas fa-plus"></i>
									เพิ่มอาคารใหม่
								</button>
							</div>
						</div>
                        <div style="overflow-x: auto;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>รหัสอาคาร</th>
                                        <th>ชื่ออาคาร</th>
                                        <th>จำนวนชั้น</th>
                                        <th>จำนวนห้อง</th>
                                        <th>สถานะ</th>
                                        <th>การจัดการ</th>
                                    </tr>
                                </thead>
                                <tbody id="buildingsTableBody">
                                    <!-- Data will be populated by JavaScript -->
                                </tbody>
                            </table>
							<div id="buildingsPagination"></div>
                        </div>
                    </div>
                </div>

                <!-- ======================== Rooms Management Section ======================== -->
                <div class="page-section" id="rooms-section">
                    <div class="admin-card">
                        <div class="enhanced-card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid var(--border-color); flex-wrap: wrap; gap: 15px;">
							<h3 class="card-title" style="margin: 0;">
								<i class="fas fa-door-open"></i>
								จัดการห้อง
							</h3>
							
							<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
								<!-- Quick Search -->
								<div style="position: relative;">
									<input type="text" placeholder="ค้นหาห้อง..." 
										   style="padding: 8px 35px 8px 12px; border: 1px solid var(--border-color); border-radius: 20px; font-size: 14px; width: 200px;" 
										   id="roomQuickSearch" 
										   oninput="quickSearchRooms(this.value)">
									<i class="fas fa-search" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); color: var(--text-secondary); font-size: 12px;"></i>
								</div>
								
								<!-- Filter Button -->
								<button class="btn btn-sm btn-info" onclick="openFilterModal()" title="ตัวกรองขั้นสูง">
									<i class="fas fa-filter"></i>
								</button>
								
								<!-- Add Button -->
								<button class="btn btn-primary" onclick="openRoomModal()">
									<i class="fas fa-plus"></i>
									เพิ่มห้องใหม่
								</button>
							</div>
						</div>
				 
						
						
                        <div style="overflow-x: auto;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>รหัสห้อง</th>
                                        <th>ชื่อห้อง</th>
                                        <th>อาคาร</th>
                                        <th>ชั้น</th>
                                        <th>ประเภท</th>
                                        <th>สถานะ</th>
                                        <th>การจัดการ</th>
                                    </tr>
                                </thead>
                                <tbody id="roomsTableBody">
                                    <!-- Data will be populated by JavaScript -->
                                </tbody>
                            </table>
							<div id="roomsPagination"></div>
                        </div>						
					</div>
                </div>
<!-- ======================== Google Sheets Section ======================== -->
				<div class="page-section" id="sheets-section">
					<div class="admin-card">
						<div class="card-header">
							<h3 class="card-title">
								<i class="fas fa-table"></i>
								Google Sheets Integration
							</h3>
						 
						</div>
						
						<div class="form-group">
							<label class="form-label">Google Sheets Web App URL</label>
							<input type="url" class="form-input" id="sheetsUrl" 
								   placeholder="https://script.google.com/macros/s/YOUR_SCRIPT_ID/exec">
						</div>
						<div id="urlValidation" class="url-validation" style="margin-top: 5px; font-size: 12px;"></div>

						<div class="form-row-3">
							<div class="form-group">
								<label class="form-label">Buildings Sheet Name</label>
								<input type="text" class="form-input" id="buildingsSheetName" value="Buildings">
							</div>
							<div class="form-group">
								<label class="form-label">Rooms Sheet Name</label>
								<input type="text" class="form-input" id="roomsSheetName" value="Rooms">
							</div>
							<div class="form-group">
								<label class="form-label">MapImages Sheet Name</label>
								<input type="text" class="form-input" id="mapImagesSheetName" value="MapImages">
							</div>
						</div>
						
						<div style="display: flex; gap: 10px; margin-top: 20px;">
							<button class="btn btn-primary" onclick="testConnection()">
								<i class="fas fa-plug"></i>
								ทดสอบการเชื่อมต่อ
							</button>
							<button class="btn btn-success" onclick="saveSheetConfig()">
								<i class="fas fa-save"></i>
								บันทึกการตั้งค่า
							</button>
							<button class="btn btn-info" onclick="sequentialLoadData()">
								<i class="fas fa-sync-alt"></i>
								โหลดข้อมูล (Sequential)
							</button>
						</div>
						
						<!-- 8. Enhanced Advanced Options Form - เพิ่มใน Google Sheets section -->
						<div id="advancedOptionsContainer" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
							<h4 style="color: var(--secondary-color); margin-bottom: 15px;">
								<i class="fas fa-cogs"></i> Advanced Options
							</h4>
							
							<div class="form-row">
								<div class="form-group">
									<label class="form-label">Request Timeout (seconds)</label>
									<input type="number" class="form-input" id="requestTimeout" min="5" max="60" value="15">
								</div>
								
								<div class="form-group">
									<label class="form-label">Retry Attempts</label>
									<input type="number" class="form-input" id="retryAttempts" min="1" max="10" value="3">
								</div>
							</div>
							
							<div class="form-row">
								<div class="form-group">
									<label style="display: flex; align-items: center; cursor: pointer;">
										<input type="checkbox" id="autoSyncEnabled" style="margin-right: 8px;">
										<span>Auto-sync เมื่อมีการเปลี่ยนแปลงข้อมูล</span>
									</label>
								</div>
								
								<div class="form-group">
									<label style="display: flex; align-items: center; cursor: pointer;">
										<input type="checkbox" id="debugModeEnabled" style="margin-right: 8px;">
										<span>Debug Mode (แสดง Technical Details)</span>
									</label>
								</div>
							</div>
						</div>
							
						<!-- Setup Guide (Collapsible) -->
						<!-- 2. Enhanced Setup Guide Container - เพิ่มหลัง Google Sheets form -->
						<div id="setupGuideContainer" style="display: none; margin-top: 25px;">
							<div class="admin-card" style="background: #f8f9fa; border-left: 5px solid var(--info-color);">
								<h4 style="color: var(--info-color); margin-bottom: 20px;">
									<i class="fas fa-graduation-cap"></i> คู่มือการตั้งค่า Google Sheets แบบสมบูรณ์
								</h4>
								
								<!-- Progress Indicator -->
								<div class="setup-progress" style="margin-bottom: 25px;">
									<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
										<span style="font-size: 14px; font-weight: 600;">ความคืบหน้า</span>
										<span id="setupProgressPercent" style="font-size: 14px; color: var(--primary-color);">0%</span>
									</div>
									<div style="background: #e9ecef; height: 8px; border-radius: 4px; overflow: hidden;">
										<div id="setupProgressBar" style="background: var(--primary-color); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
									</div>
								</div>
								
								<!-- Setup Steps Container -->
								<div class="setup-steps">
									<!-- Steps content will be populated by JavaScript -->
								</div>
								
								<!-- Completion Status -->
								<div id="setupCompleteStatus" style="display: none; background: #d4edda; padding: 20px; border-radius: 10px; text-align: center; margin-top: 20px;">
									<h5 style="color: #155724; margin-bottom: 10px;">
										<i class="fas fa-check-circle"></i> ตั้งค่าเสร็จสมบูรณ์!
									</h5>
									<p style="color: #155724; margin: 0;">ระบบพร้อมใช้งานกับ Google Sheets แล้ว</p>
								</div>
							</div>
						</div>
							
						<!-- 4. Debug Panel Container - เพิ่มใน Google Sheets section -->
						<div id="debugPanel" style="display: none; background: #1a1a1a; color: #00ff00; padding: 20px; border-radius: 10px; font-family: 'Courier New', monospace; font-size: 12px; max-height: 300px; overflow-y: auto; margin-top: 20px;">
							<div style="margin-bottom: 10px; color: #fff; font-weight: bold;">🔍 Debug Terminal</div>
							<div id="debugOutput"></div>
						</div>	

						<!-- Sync History -->
						<div style="margin-top: 30px;">				
							
							<!-- 6. Map Sync History Container - เพิ่มในหน้า Maps Management -->
							<div id="mapSyncHistory" style="background: #f8f9fa; padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto; margin-top: 30px;">
								<h4 style="color: var(--info-color); margin-bottom: 15px;">
									<i class="fas fa-history"></i> ประวัติการซิงค์
								</h4>
								 
							</div>
							 <!-- 5. Sync History Container - เพิ่มในหน้า Maps Management -->
							<div id="syncHistoryContainer" style="background: #f8f9fa; padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto;">
								<p style="color: var(--text-secondary); text-align: center; margin: 0;">ยังไม่มีประวัติการซิงค์</p>
							</div>
						</div>						
					</div>			
				</div>	
				
				<!-- ======================== Maps Management Section (Simplified) ======================== -->
				<div class="page-section" id="maps-section">
					<div class="admin-card">
						<div class="card-header">
							<h3 class="card-title">
								<i class="fas fa-map"></i>
								จัดการแผนที่และรูปภาพ
							</h3>
							<button class="btn btn-success" onclick="uploadMapsToSheets()">
								<i class="fas fa-cloud-upload-alt"></i>
								ซิงค์ไปยัง Google Sheets
							</button>
						</div>
						
						<!-- Upload Section -->
						<div class="upload-section" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
							<h4 style="color: var(--primary-color); margin-bottom: 15px;">
								<i class="fas fa-upload"></i> อัปโหลดรูปภาพแผนที่
							</h4>
							
							<div class="form-row">
								<div class="form-group">
									<label class="form-label">
										<i class="fas fa-drafting-compass"></i> รูปแผนผัง (Floor Plan)
									</label>
									<input type="file" class="form-input" id="floorplanUpload" 
										   accept="image/*" onchange="handleImageUpload(this, 'floorplan')">
									<small style="color: var(--text-secondary);">รองรับ: JPG, PNG, GIF (ไม่เกิน 5MB)</small>
								</div>
								
								<div class="form-group">
									<label class="form-label">
										<i class="fas fa-camera"></i> รูปจริง (Real Photo)
									</label>
									<input type="file" class="form-input" id="realphotoUpload" 
										   accept="image/*" onchange="handleImageUpload(this, 'realphoto')">
									<small style="color: var(--text-secondary);">รองรับ: JPG, PNG, GIF (ไม่เกิน 5MB)</small>
								</div>
							</div>
							
							<div class="form-group">
								<label class="form-label">หมายเหตุ</label>
								<textarea class="form-input" id="mapNotes" rows="3" 
										 placeholder="บันทึกข้อมูลเพิ่มเติมเกี่ยวกับแผนที่นี้..."></textarea>
							</div>
							
							<div style="text-align: center; margin-top: 15px;">
								<button class="btn btn-primary" onclick="saveMapImages()">
									<i class="fas fa-save"></i>
									บันทึกแผนที่
								</button>
								<button class="btn btn-secondary" onclick="forceRefreshMaps()" title="รีเฟรชข้อมูลจาก Google Sheets">
									<i class="fas fa-sync-alt"></i>
									รีเฟรชข้อมูล
								</button>
								<button class="btn btn-secondary" onclick="clearMapForms()">
									<i class="fas fa-times"></i>
									ล้างข้อมูล
								</button>
							</div>
						</div>
						
						<!-- Preview Section -->
						<div class="preview-section">
							<h4 style="color: var(--primary-color); margin-bottom: 15px;">
								<i class="fas fa-eye"></i> ตัวอย่างรูปภาพ
							</h4>
							
							<div class="image-previews" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
								<div class="preview-card" style="border: 2px dashed #ddd; border-radius: 10px; padding: 20px; text-align: center; min-height: 200px;">
									<div id="floorplanPreview">
										<i class="fas fa-drafting-compass" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
										<p style="color: var(--text-secondary);">รูปแผนผังจะแสดงที่นี่</p>
									</div>
								</div>
								
								<div class="preview-card" style="border: 2px dashed #ddd; border-radius: 10px; padding: 20px; text-align: center; min-height: 200px;">
									<div id="realphotoPreview">
										<i class="fas fa-camera" style="font-size: 48px; color: #ccc; margin-bottom: 15px;"></i>
										<p style="color: var(--text-secondary);">รูปจริงจะแสดงที่นี่</p>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Sync History - เก็บไว้เฉพาะส่วนนี้ -->
						 
						<!-- Walkable Points Management Interface -->
						 
						<div class="admin-walkable-section" id="walkablePointsSection" style="display: none;">
							<div class="section-header">
								<h3><i class="fas fa-route"></i> จัดการจุดเดินและเส้นทาง</h3>
								<div class="header-actions">
									<button class="btn btn-primary" onclick="toggleWalkableMode()">
										<i class="fas fa-edit"></i> โหมดแก้ไข
									</button>
									<button class="btn btn-info" onclick="previewWalkablePoints()">
										<i class="fas fa-eye"></i> ดูตัวอย่าง
									</button>
								</div>
							</div>
							
							<!-- Statistics Dashboard -->
							<div class="walkable-dashboard">
								<div class="stat-cards">
									<div class="stat-card primary">
										<div class="stat-icon">🚶‍♂️</div>
										<div class="stat-content">
											<div class="stat-number" id="totalWalkablePoints">0</div>
											<div class="stat-label">จุดเดินทั้งหมด</div>
										</div>
									</div>
									<div class="stat-card success">
										<div class="stat-icon">🔗</div>
										<div class="stat-content">
											<div class="stat-number" id="totalConnections">0</div>
											<div class="stat-label">การเชื่อมโยง</div>
										</div>
									</div>
									<div class="stat-card warning">
										<div class="stat-icon">📏</div>
										<div class="stat-content">
											<div class="stat-number" id="averageDistance">0m</div>
											<div class="stat-label">ระยะเฉลี่ย</div>
										</div>
									</div>
									<div class="stat-card info">
										<div class="stat-icon">📊</div>
										<div class="stat-content">
											<div class="stat-number" id="coveragePercentage">0%</div>
											<div class="stat-label">ความครอบคลุม</div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Walkable Points Canvas -->
							<div class="walkable-canvas-container">
								<div class="canvas-header">
									<h4>แผนที่จุดเดิน - <span id="currentBuildingName">-</span></h4>
									<div class="canvas-controls">
										<button class="canvas-btn" onclick="zoomIn()">
											<i class="fas fa-search-plus"></i>
										</button>
										<button class="canvas-btn" onclick="zoomOut()">
											<i class="fas fa-search-minus"></i>
										</button>
										<button class="canvas-btn" onclick="resetZoom()">
											<i class="fas fa-expand-arrows-alt"></i>
										</button>
										<button class="canvas-btn" onclick="toggleGrid()">
											<i class="fas fa-th"></i>
										</button>
									</div>
								</div>
								
								<div class="walkable-canvas" id="walkableCanvas">
									<!-- Background image -->
									<img class="canvas-background" id="canvasBackground" alt="Building Floor Plan">
									
									<!-- Grid overlay -->
									<div class="grid-overlay" id="gridOverlay"></div>
									
									<!-- Walkable points and connections -->
									<svg class="walkable-svg" id="walkableSvg" viewBox="0 0 100 100">
										<!-- Connections will be drawn here -->
									</svg>
									
									<!-- Interactive points -->
									<div class="points-layer" id="pointsLayer">
										<!-- Points will be added here -->
									</div>
									
									<!-- Selection tools -->
									<div class="selection-tools" id="selectionTools">
										<!-- Selection rectangle, etc. -->
									</div>
								</div>
								
								<!-- Canvas Info Bar -->
								<div class="canvas-info-bar">
									<div class="info-item">
										<span class="info-label">เลือก:</span>
										<span class="info-value" id="selectedPointsCount">0</span>
										<span>จุด</span>
									</div>
									<div class="info-item">
										<span class="info-label">เมาส์:</span>
										<span class="info-value" id="mousePosition">-</span>
									</div>
									<div class="info-item">
										<span class="info-label">ซูม:</span>
										<span class="info-value" id="zoomLevel">100%</span>
									</div>
								</div>
							</div>
							
							<!-- Tools Panel -->
							<div class="walkable-tools-panel">
								<div class="tool-groups">
									<!-- Point Tools -->
									<div class="tool-group">
										<h5><i class="fas fa-dot-circle"></i> เครื่องมือจุด</h5>
										<div class="tool-buttons">
											<button class="tool-btn" data-tool="add" onclick="setActiveTool('add')">
												<i class="fas fa-plus"></i>
												<span>เพิ่มจุด</span>
											</button>
											<button class="tool-btn" data-tool="select" onclick="setActiveTool('select')">
												<i class="fas fa-mouse-pointer"></i>
												<span>เลือก</span>
											</button>
											<button class="tool-btn" data-tool="move" onclick="setActiveTool('move')">
												<i class="fas fa-arrows-alt"></i>
												<span>ย้าย</span>
											</button>
											<button class="tool-btn" data-tool="delete" onclick="setActiveTool('delete')">
												<i class="fas fa-trash"></i>
												<span>ลบ</span>
											</button>
										</div>
									</div>
									
									<!-- Connection Tools -->
									<div class="tool-group">
										<h5><i class="fas fa-link"></i> เครื่องมือเชื่อมโยง</h5>
										<div class="tool-buttons">
											<button class="tool-btn" data-tool="connect" onclick="setActiveTool('connect')">
												<i class="fas fa-link"></i>
												<span>เชื่อมโยง</span>
											</button>
											<button class="tool-btn" onclick="autoConnectAll()">
												<i class="fas fa-magic"></i>
												<span>เชื่อมอัตโนมัติ</span>
											</button>
											<button class="tool-btn" onclick="optimizeConnections()">
												<i class="fas fa-cogs"></i>
												<span>ปรับปรุง</span>
											</button>
										</div>
									</div>
									
									<!-- Generation Tools -->
									<div class="tool-group">
										<h5><i class="fas fa-magic"></i> เครื่องมือสร้าง</h5>
										<div class="tool-buttons">
											<button class="tool-btn" onclick="generateGridPoints()">
												<i class="fas fa-th"></i>
												<span>สร้างกริด</span>
											</button>
											<button class="tool-btn" onclick="generateRoomPoints()">
												<i class="fas fa-door-open"></i>
												<span>จุดใกล้ห้อง</span>
											</button>
											<button class="tool-btn" onclick="generateCorridorPoints()">
												<i class="fas fa-road"></i>
												<span>จุดในทางเดิน</span>
											</button>
										</div>
									</div>
								</div>
								
								<!-- Settings Panel -->
								<div class="settings-panel">
									<h5><i class="fas fa-sliders-h"></i> การตั้งค่า</h5>
									<div class="setting-groups">
										<div class="setting-item">
											<label for="maxConnectionDistance">ระยะเชื่อมโยงสูงสุด (%)</label>
											<input type="range" id="maxConnectionDistance" min="10" max="50" value="25" step="1">
											<span class="setting-value">25</span>
										</div>
										<div class="setting-item">
											<label for="metersPerPercent">เมตรต่อเปอร์เซ็นต์</label>
											<input type="number" id="metersPerPercent" min="0.5" max="5" value="1.2" step="0.1">
										</div>
										<div class="setting-item">
											<label for="snapToGrid">แนบกริด</label>
											<input type="checkbox" id="snapToGrid">
										</div>
										<div class="setting-item">
											<label for="autoConnect">เชื่อมอัตโนมัติ</label>
											<input type="checkbox" id="autoConnect" checked>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Action Buttons -->
							<div class="walkable-actions">
								<button class="btn btn-success" onclick="saveWalkableConfiguration()">
									<i class="fas fa-save"></i> บันทึกการกำหนดค่า
								</button>
								<button class="btn btn-primary" onclick="testRouting()">
									<i class="fas fa-route"></i> ทดสอบการหาเส้นทาง
								</button>
								<button class="btn btn-info" onclick="exportWalkableData()">
									<i class="fas fa-download"></i> ส่งออกข้อมูล
								</button>
								<button class="btn btn-warning" onclick="importWalkableData()">
									<i class="fas fa-upload"></i> นำเข้าข้อมูล
								</button>
								<button class="btn btn-danger" onclick="resetWalkablePoints()">
									<i class="fas fa-refresh"></i> รีเซ็ต
								</button>
							</div>
						</div>
					</div>
				</div>
				
				
				
				
				
				<!-- ======================== Deployment Guide Section ======================== -->

				<div class="page-section" id="deployment-section">
					<div class="admin-card">
						<div class="card-header">
							<h3 class="card-title">
								<i class="fas fa-rocket"></i>
								คู่มือ Deploy ไปยัง GitHub Pages
							</h3>
						 
						</div>
						
						<!-- Quick Start -->
						<div class="deployment-quick-start" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px; margin-bottom: 25px;">
							<h4 style="margin-bottom: 15px;">
								<i class="fas fa-bolt"></i> Quick Start Guide
							</h4>
							<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
								<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
									<div style="font-size: 24px; margin-bottom: 5px;">1️⃣</div>
									<div style="font-weight: 600;">สร้าง Repository</div>
									<div style="font-size: 13px; opacity: 0.9;">สร้าง GitHub repo ใหม่</div>
								</div>
								<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
									<div style="font-size: 24px; margin-bottom: 5px;">2️⃣</div>
									<div style="font-weight: 600;">อัปโหลดไฟล์</div>
									<div style="font-size: 13px; opacity: 0.9;">Upload index.html + admin.html</div>
								</div>
								<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
									<div style="font-size: 24px; margin-bottom: 5px;">3️⃣</div>
									<div style="font-weight: 600;">เปิด Pages</div>
									<div style="font-size: 13px; opacity: 0.9;">Settings → Pages → Deploy</div>
								</div>
								<div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
									<div style="font-size: 24px; margin-bottom: 5px;">4️⃣</div>
									<div style="font-weight: 600;">เสร็จสิ้น!</div>
									<div style="font-size: 13px; opacity: 0.9;">เว็บไซต์พร้อมใช้งาน</div>
								</div>
							</div>
						</div>
						
						<!-- Detailed Steps -->
						<div class="deployment-steps">
							<h4 style="color: var(--primary-color); margin-bottom: 20px;">
								<i class="fas fa-list-ol"></i> ขั้นตอนการ Deploy แบบละเอียด
							</h4>
							
							<!-- Step 1 -->
							<div class="deployment-step" style="border: 2px solid var(--border-color); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
								<h5 style="color: var(--primary-color); margin-bottom: 15px;">
									<i class="fas fa-plus-circle"></i> ขั้นตอนที่ 1: สร้าง GitHub Repository
								</h5>
								
								<div style="margin-bottom: 15px;">
									<strong>1.1 เข้าสู่ GitHub:</strong>
									<ul style="margin: 10px 0; padding-left: 20px;">
										<li>ไปที่ <a href="https://github.com" target="_blank" style="color: var(--primary-color);">github.com</a></li>
										<li>เข้าสู่ระบบด้วยบัญชีของคุณ</li>
									</ul>
								</div>
								
								<div style="margin-bottom: 15px;">
									<strong>1.2 สร้าง Repository ใหม่:</strong>
									<ul style="margin: 10px 0; padding-left: 20px;">
										<li>คลิก "New" หรือ "+" → "New repository"</li>
										<li>ตั้งชื่อ: <code style="background: #f1f3f4; padding: 2px 6px; border-radius: 4px;">school-map-system</code></li>
										<li>เลือก "Public" (สำหรับ GitHub Pages ฟรี)</li>
										<li>☑️ เลือก "Add a README file"</li>
										<li>คลิก "Create repository"</li>
									</ul>
								</div>
								
								<div class="code-example" style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-family: monospace; margin-top: 10px;">
									<div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 5px;">ตัวอย่างชื่อ Repository:</div>
									<div>your-username/school-map-system</div>
								</div>
							</div>
							
							<!-- Step 2 -->
							<div class="deployment-step" style="border: 2px solid var(--border-color); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
								<h5 style="color: var(--primary-color); margin-bottom: 15px;">
									<i class="fas fa-upload"></i> ขั้นตอนที่ 2: อัปโหลดไฟล์
								</h5>
								
								<div style="margin-bottom: 15px;">
									<strong>2.1 ไฟล์ที่ต้องอัปโหลด:</strong>
									<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
										<div style="background: #e8f4fd; padding: 15px; border-radius: 8px; border-left: 4px solid var(--info-color);">
											<div style="font-weight: 600; color: var(--info-color);">📄 index.html</div>
											<div style="font-size: 13px; color: var(--text-secondary);">หน้าหลักสำหรับผู้ใช้งาน</div>
										</div>
										<div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid var(--warning-color);">
											<div style="font-weight: 600; color: #856404;">🔐 admin.html</div>
											<div style="font-size: 13px; color: var(--text-secondary);">หน้า Admin Panel (ไฟล์นี้)</div>
										</div>
									</div>
								</div>
								
								<div style="margin-bottom: 15px;">
									<strong>2.2 วิธีอัปโหลด:</strong>
									<ol style="margin: 10px 0; padding-left: 20px;">
										<li>ในหน้า Repository คลิก "Add file" → "Upload files"</li>
										<li>ลากไฟล์ index.html และ admin.html มาวางในพื้นที่</li>
										<li>เขียนข้อความ commit: <code style="background: #f1f3f4; padding: 2px 6px; border-radius: 4px;">Add school map system files</code></li>
										<li>คลิก "Commit changes"</li>
									</ol>
								</div>
								
								<div class="file-structure" style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-family: monospace; margin-top: 10px;">
									<div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 5px;">โครงสร้างไฟล์ที่ถูกต้อง:</div>
									<div>📁 your-repository/</div>
									<div>&nbsp;&nbsp;├── 📄 README.md</div>
									<div>&nbsp;&nbsp;├── 📄 index.html</div>
									<div>&nbsp;&nbsp;└── 📄 admin.html</div>
								</div>
							</div>
							
							<!-- Step 3 -->
							<div class="deployment-step" style="border: 2px solid var(--border-color); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
								<h5 style="color: var(--primary-color); margin-bottom: 15px;">
									<i class="fas fa-cog"></i> ขั้นตอนที่ 3: เปิดใช้งาน GitHub Pages
								</h5>
								
								<div style="margin-bottom: 15px;">
									<strong>3.1 เข้าสู่การตั้งค่า:</strong>
									<ol style="margin: 10px 0; padding-left: 20px;">
										<li>ในหน้า Repository คลิกแท็บ "Settings" (ด้านบน)</li>
										<li>เลื่อนลงไปหาส่วน "Pages" ในเมนูซ้าย</li>
										<li>คลิก "Pages"</li>
									</ol>
								</div>
								
								<div style="margin-bottom: 15px;">
									<strong>3.2 ตั้งค่า Pages:</strong>
									<ul style="margin: 10px 0; padding-left: 20px;">
										<li><strong>Source:</strong> เลือก "Deploy from a branch"</li>
										<li><strong>Branch:</strong> เลือก "main" (หรือ "master")</li>
										<li><strong>Folder:</strong> เลือก "/ (root)"</li>
										<li>คลิก "Save"</li>
									</ul>
								</div>
								
								<div class="success-box" style="background: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 8px; margin-top: 15px;">
									<div style="color: #155724; font-weight: 600;">✅ การตั้งค่าสำเร็จ!</div>
									<div style="color: #155724; margin-top: 5px;">GitHub จะแสดง URL ของเว็บไซต์ เช่น:</div>
									<div style="font-family: monospace; background: #fff; padding: 8px; border-radius: 4px; margin-top: 8px;">
										https://your-username.github.io/school-map-system/
									</div>
								</div>
							</div>
							
							<!-- Step 4 -->
							<div class="deployment-step" style="border: 2px solid var(--border-color); border-radius: 15px; padding: 20px; margin-bottom: 20px;">
								<h5 style="color: var(--primary-color); margin-bottom: 15px;">
									<i class="fas fa-check-circle"></i> ขั้นตอนที่ 4: ทดสอบและใช้งาน
								</h5>
								
								<div style="margin-bottom: 15px;">
									<strong>4.1 รอการ Deploy:</strong>
									<ul style="margin: 10px 0; padding-left: 20px;">
										<li>การ Deploy ใช้เวลา 5-10 นาที</li>
										<li>ตรวจสอบสถานะในแท็บ "Actions"</li>
										<li>เมื่อเสร็จจะแสดงสถานะ ✅</li>
									</ul>
								</div>
								
								<div style="margin-bottom: 15px;">
									<strong>4.2 ทดสอบเว็บไซต์:</strong>
									<ul style="margin: 10px 0; padding-left: 20px;">
										<li>เปิด URL ของเว็บไซต์ในเบราว์เซอร์</li>
										<li>ทดสอบหน้าหลัก: <code>/index.html</code></li>
										<li>ทดสอบหน้า Admin: <code>/admin.html</code></li>
									</ul>
								</div>
								
								<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
									<div style="background: #e3f2fd; padding: 15px; border-radius: 8px;">
										<div style="font-weight: 600; color: var(--info-color); margin-bottom: 5px;">🌐 หน้าผู้ใช้</div>
										<div style="font-size: 13px;">https://your-site.github.io/school-map-system/</div>
									</div>
									<div style="background: #fff3e0; padding: 15px; border-radius: 8px;">
										<div style="font-weight: 600; color: #f57c00; margin-bottom: 5px;">🔐 หน้า Admin</div>
										<div style="font-size: 13px;">https://your-site.github.io/school-map-system/admin.html</div>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Advanced Tips -->
						<div class="advanced-tips" style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin-top: 25px;">
							<h4 style="color: var(--secondary-color); margin-bottom: 15px;">
								<i class="fas fa-lightbulb"></i> เทคนิคขั้นสูง
							</h4>
							
							<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
								<div class="tip-card" style="background: white; padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-color);">
									<h6 style="color: var(--accent-color); margin-bottom: 8px;">🎯 Custom Domain</h6>
									<p style="font-size: 13px; margin: 0; line-height: 1.5;">เพิ่มไฟล์ CNAME สำหรับใช้โดเมนส่วนตัว เช่น schoolmap.yourschool.ac.th</p>
								</div>
								
								<div class="tip-card" style="background: white; padding: 15px; border-radius: 10px; border-left: 4px solid var(--info-color);">
									<h6 style="color: var(--info-color); margin-bottom: 8px;">🔄 Auto Deploy</h6>
									<p style="font-size: 13px; margin: 0; line-height: 1.5;">ใช้ GitHub Actions สำหรับ CI/CD และ auto-deploy เมื่อมีการอัปเดต</p>
								</div>
								
								<div class="tip-card" style="background: white; padding: 15px; border-radius: 10px; border-left: 4px solid var(--warning-color);">
									<h6 style="color: #856404; margin-bottom: 8px;">📊 Analytics</h6>
									<p style="font-size: 13px; margin: 0; line-height: 1.5;">เพิ่ม Google Analytics เพื่อติดตามการใช้งานเว็บไซต์</p>
								</div>
								
								<div class="tip-card" style="background: white; padding: 15px; border-radius: 10px; border-left: 4px solid var(--danger-color);">
									<h6 style="color: var(--danger-color); margin-bottom: 8px;">🛡️ Security</h6>
									<p style="font-size: 13px; margin: 0; line-height: 1.5;">ใช้ environment variables สำหรับ sensitive data และ API keys</p>
								</div>
							</div>
						</div>
						
						<!-- Troubleshooting -->
						<div class="troubleshooting" style="margin-top: 25px;">
							<h4 style="color: var(--danger-color); margin-bottom: 15px;">
								<i class="fas fa-tools"></i> แก้ไขปัญหาที่พบบ่อย
							</h4>
							
							<div class="accordion" style="border: 1px solid var(--border-color); border-radius: 10px;">
								<div class="accordion-item" style="border-bottom: 1px solid var(--border-color);">
									<div class="accordion-header" style="padding: 15px; cursor: pointer; background: #f8f9fa;" onclick="toggleAccordion(this)">
										<strong>❌ หน้าเว็บแสดง 404 Not Found</strong>
										<i class="fas fa-chevron-down" style="float: right; transition: transform 0.3s;"></i>
									</div>
									<div class="accordion-content" style="padding: 15px; display: none;">
										<ul style="margin: 0; padding-left: 20px;">
											<li>ตรวจสอบว่าไฟล์ index.html อยู่ใน root directory</li>
											<li>ตรวจสอบการตั้งค่า GitHub Pages ใน Settings</li>
											<li>รอการ deploy เสร็จสิ้น (5-10 นาที)</li>
											<li>ลองเข้า URL แบบ https:// แทน http://</li>
										</ul>
									</div>
								</div>
								
								<div class="accordion-item" style="border-bottom: 1px solid var(--border-color);">
									<div class="accordion-header" style="padding: 15px; cursor: pointer; background: #f8f9fa;" onclick="toggleAccordion(this)">
										<strong>⏳ การ Deploy ช้าหรือไม่สำเร็จ</strong>
										<i class="fas fa-chevron-down" style="float: right; transition: transform 0.3s;"></i>
									</div>
									<div class="accordion-content" style="padding: 15px; display: none;">
										<ul style="margin: 0; padding-left: 20px;">
											<li>ตรวจสอบสถานะใน Actions tab</li>
											<li>ดู error logs ถ้ามี deployment ล้มเหลว</li>
											<li>ลองสร้าง commit ใหม่เพื่อ trigger deployment</li>
											<li>ตรวจสอบขนาดไฟล์ไม่เกิน 1GB</li>
										</ul>
									</div>
								</div>
								
								<div class="accordion-item">
									<div class="accordion-header" style="padding: 15px; cursor: pointer; background: #f8f9fa;" onclick="toggleAccordion(this)">
										<strong>🔗 ลิงก์หรือรูปภาพใช้งานไม่ได้</strong>
										<i class="fas fa-chevron-down" style="float: right; transition: transform 0.3s;"></i>
									</div>
									<div class="accordion-content" style="padding: 15px; display: none;">
										<ul style="margin: 0; padding-left: 20px;">
											<li>ใช้ relative paths แทน absolute paths</li>
											<li>ตรวจสอบชื่อไฟล์ให้ตรงกัน (case-sensitive)</li>
											<li>ใช้ / แทน \ ในชื่อ path</li>
											<li>ใช้ base tag ถ้าจำเป็น: &lt;base href="/repository-name/"&gt;</li>
										</ul>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>

				
            </div>
        </div>
    </div>
	
	<!-- ======================== Modal Forms ======================== -->
	<!-- เพิ่มส่วนนี้ก่อน closing </body> tag -->

	<!-- Building Modal -->
	<div id="buildingModal" class="modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; backdrop-filter: blur(5px);">
		<div class="modal-content" style="background: white; margin: 50px auto; padding: 0; border-radius: 15px; max-width: 600px; max-height: 90vh; overflow-y: auto; box-shadow: 0 25px 50px rgba(0,0,0,0.3);">
			<!-- Modal Header -->
			<div class="modal-header" style="padding: 25px 30px; border-bottom: 2px solid var(--border-color); background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: white; border-radius: 15px 15px 0 0;">
				<h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
					<i class="fas fa-building"></i>
					<span id="buildingModalTitle">เพิ่มอาคารใหม่</span>
				</h3>
				<button onclick="closeBuildingModal()" style="position: absolute; top: 20px; right: 25px; background: rgba(255,255,255,0.2); border: none; color: white; width: 35px; height: 35px; border-radius: 50%; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">×</button>
			</div>
			
			<!-- Modal Body -->
			<div class="modal-body" style="padding: 30px;">
				<form id="buildingForm" onsubmit="saveBuildingForm(event)">
					<div class="form-row">
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-hashtag"></i> รหัสอาคาร
								<span style="color: var(--danger-color);">*</span>
							</label>
							<input type="text" class="form-input" id="buildingCode" 
								   placeholder="B001" maxlength="10" required>
							<small style="color: var(--text-secondary);">รหัสจะถูกสร้างอัตโนมัติถ้าไม่ระบุ</small>
						</div>
						
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-building"></i> ชื่ออาคาร
								<span style="color: var(--danger-color);">*</span>
							</label>
							<input type="text" class="form-input" id="buildingName" 
								   placeholder="อาคารเรียนรวม" required>
						</div>
					</div>
					
					<div class="form-row">
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-layer-group"></i> จำนวนชั้น
								<span style="color: var(--danger-color);">*</span>
							</label>
							<input type="number" class="form-input" id="buildingFloors" 
								   min="1" max="50" value="1" required>
						</div>
						
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-calendar-alt"></i> ปีที่สร้าง
							</label>
							<input type="number" class="form-input" id="buildingYear" 
								   min="1900" max="2030" placeholder="2023">
						</div>
					</div>
					
					<div class="form-row">
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-door-open"></i> จำนวนห้อง
							</label>
							<input type="number" class="form-input" id="buildingRooms" 
								   min="0" max="1000" value="0">
						</div>
						
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-toggle-on"></i> สถานะ
								<span style="color: var(--danger-color);">*</span>
							</label>
							<select class="form-input" id="buildingStatus" required>
								<option value="">เลือกสถานะ</option>
								<option value="active">ใช้งาน</option>
								<option value="inactive">ไม่ใช้งาน</option>
								<option value="maintenance">ปรับปรุง</option>
							</select>
						</div>
					</div>
					
					<div class="form-group">
						<label class="form-label">
							<i class="fas fa-align-left"></i> รายละเอียด
						</label>
						<textarea class="form-input" id="buildingDescription" rows="3" 
								 placeholder="รายละเอียดเพิ่มเติมเกี่ยวกับอาคาร..."></textarea>
					</div>
					
					<!-- Form Actions -->
					<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px; padding-top: 20px; border-top: 1px solid var(--border-color);">
						<button type="button" class="btn btn-secondary" onclick="closeBuildingModal()">
							<i class="fas fa-times"></i> ยกเลิก
						</button>
						<button type="submit" class="btn btn-primary">
							<i class="fas fa-save"></i> บันทึก
						</button>
					</div>
				</form>
			</div>
		</div>
	</div>

	<!-- Room Modal -->
	<div id="roomModal" class="modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; backdrop-filter: blur(5px);">
		<div class="modal-content" style="background: white; margin: 30px auto; padding: 0; border-radius: 15px; max-width: 700px; max-height: 95vh; overflow-y: auto; box-shadow: 0 25px 50px rgba(0,0,0,0.3);">
			<!-- Modal Header -->
			<div class="modal-header" style="padding: 25px 30px; border-bottom: 2px solid var(--border-color); background: linear-gradient(135deg, var(--accent-color), var(--info-color)); color: white; border-radius: 15px 15px 0 0;">
				<h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
					<i class="fas fa-door-open"></i>
					<span id="roomModalTitle">เพิ่มห้องใหม่</span>
				</h3>
				<button onclick="closeRoomModal()" style="position: absolute; top: 20px; right: 25px; background: rgba(255,255,255,0.2); border: none; color: white; width: 35px; height: 35px; border-radius: 50%; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">×</button>
			</div>
			
			<!-- Modal Body -->
			<div class="modal-body" style="padding: 30px;">
				<form id="roomForm" onsubmit="saveRoomForm(event)">
					<div class="form-row">
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-hashtag"></i> รหัสห้อง
								<span style="color: var(--danger-color);">*</span>
							</label>
							<input type="text" class="form-input" id="roomCode" 
								   placeholder="R0001" maxlength="10" required>
							<small style="color: var(--text-secondary);">รหัสจะถูกสร้างอัตโนมัติถ้าไม่ระบุ</small>
						</div>
						
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-door-open"></i> ชื่อห้อง
								<span style="color: var(--danger-color);">*</span>
							</label>
							<input type="text" class="form-input" id="roomName" 
								   placeholder="ห้อง 101" required>
						</div>
					</div>
					
					<div class="form-row">
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-building"></i> อาคาร
								<span style="color: var(--danger-color);">*</span>
							</label>
							<select class="form-input" id="roomBuilding" required>
								<option value="">เลือกอาคาร</option>
								<!-- Options will be populated by JavaScript -->
							</select>
						</div>
						
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-layer-group"></i> ชั้น
								<span style="color: var(--danger-color);">*</span>
							</label>
							<input type="number" class="form-input" id="roomFloor" 
								   min="1" max="50" value="1" required>
						</div>
					</div>
					
					<div class="form-row">
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-tags"></i> ประเภทห้อง
							</label>
							<select class="form-input" id="roomType">
								<option value="ห้องเรียน">ห้องเรียน</option>
								<option value="ห้องปฏิบัติการ">ห้องปฏิบัติการ</option>
								<option value="ห้องสำนักงาน">ห้องสำนักงาน</option>
								<option value="ห้องประชุม">ห้องประชุม</option>
								<option value="ห้องพักครู">ห้องพักครู</option>
								<option value="ห้องน้ำ">ห้องน้ำ</option>
								<option value="ห้องเก็บของ">ห้องเก็บของ</option>
								<option value="อื่นๆ">อื่นๆ</option>
							</select>
						</div>
						
						<div class="form-group">
							<label class="form-label">
								<i class="fas fa-toggle-on"></i> สถานะ
								<span style="color: var(--danger-color);">*</span>
							</label>
							<select class="form-input" id="roomStatus" required>
								<option value="">เลือกสถานะ</option>
								<option value="active">ใช้งาน</option>
								<option value="inactive">ไม่ใช้งาน</option>
								<option value="maintenance">ปรับปรุง</option>
							</select>
						</div>
					</div>
					
					<div class="form-group">
						<label class="form-label">
							<i class="fas fa-map-marked-alt"></i> ตำแหน่งบนแผนที่
						</label>
						
						<div class="interactive-map-container">
							
							<!-- Header -->
							<div class="map-picker-header">
								<div class="map-picker-title">
									<i class="fas fa-crosshairs"></i>
									เลือกตำแหน่งห้องบนแผนที่
								</div> 
							</div>

							<!-- Instructions -->
							<div class="map-instructions">
								<strong>วิธีใช้:</strong> คลิกบนแผนที่เพื่อเลือกตำแหน่งห้อง • เปิด Grid เพื่อความแม่นยำ • ปรับ X,Y ด้วยตนเองได้
							</div>
 

							<!-- แทนที่ส่วน map-canvas-container ทั้งหมดใน Room Modal -->
							<div class="map-canvas-container" id="roomMapContainer" onclick="selectRoomPosition(event)">
								<!-- Coordinate Display -->
								<div class="coordinate-display" id="roomCoordinateDisplay">
									X: 0.0, Y: 0.0
								</div>
							 
								<!-- NEW: Image Container -->
								<div class="map-image-container" id="mapImageContainer">
									<!-- Floorplan Image -->
									<img class="map-floorplan-image" id="mapFloorplanImage" style="display: none;" alt="Floor Plan">
									
									<!-- Loading Overlay -->
									<div class="map-loading-overlay" id="mapLoadingOverlay" style="display: none;">
										<div class="loading-spinner"></div>
										<p style="margin-top: 10px; font-size: 14px;">กำลังโหลดแผนที่...</p>
									</div>
									
									<!-- Upload Zone -->
									<div class="map-upload-zone" id="mapUploadZone" style="display: none;">
										<i class="fas fa-cloud-upload-alt" style="font-size: 32px; color: var(--primary-color); margin-bottom: 10px;"></i>
										<p style="font-weight: 600; margin-bottom: 5px;">อัปโหลดแผนผังอาคาร</p>
										<p style="font-size: 12px; color: var(--text-secondary);">ลากไฟล์มาวาง หรือคลิกเพื่อเลือก</p>
										<input type="file" id="floorplanFileInput" accept="image/*" style="display: none;">
									</div>
									
									<!-- Placeholder (แสดงเมื่อไม่มีแผนผัง) -->
									<div class="map-placeholder" id="roomMapPlaceholder">
										<i class="fas fa-map" style="font-size: 32px; margin-bottom: 8px; opacity: 0.5;"></i>
										<div style="font-size: 14px; margin-bottom: 4px;">แผนผังอาคาร</div>
										<div style="font-size: 11px; opacity: 0.7;">ไม่พบรูปแผนที่!! โปรดตรวจสอบที่เมนูจัดการแผนที่</div>
									</div>			 
								</div>
								
								<!-- Position Marker -->
								<div class="position-marker" id="roomPositionMarker" style="display: none;"></div>
							</div>

							<!-- Coordinate Inputs -->
							<div class="coordinate-inputs-enhanced">
								<div class="coordinate-input-group-enhanced">
									<label style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: #555;">
										<i class="fas fa-arrows-alt-h"></i> X Coordinate
									</label>
									<input type="number" class="coordinate-input-enhanced" id="roomX" 
										   placeholder="0.0" step="0.1" 
										   oninput="updateRoomMarkerFromInput()" />
								</div>
								
								<div class="coordinate-input-group-enhanced">
									<label style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: #555;">
										<i class="fas fa-arrows-alt-v"></i> Y Coordinate
									</label>
									<input type="number" class="coordinate-input-enhanced" id="roomY" 
										   placeholder="0.0" step="0.1" 
										   oninput="updateRoomMarkerFromInput()" />
								</div>
								
								<button type="button" class="clear-position-btn" onclick="clearRoomPosition()">
									<i class="fas fa-times"></i>
									ล้าง
								</button>
							</div>

						</div>
					</div>
					
					<div class="form-group">
						<label class="form-label">
							<i class="fas fa-align-left"></i> รายละเอียด
						</label>
						<textarea class="form-input" id="roomDescription" rows="3" 
								 placeholder="รายละเอียดเพิ่มเติมเกี่ยวกับห้อง..."></textarea>
					</div>
					
					<!-- Image URLs Section -->
					<div class="form-group">
						<label class="form-label">
							<i class="fas fa-images"></i> รูปภาพ (URLs)
						</label>
						<div id="roomImagesContainer">
							<div class="image-url-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
								<input type="url" class="form-input" placeholder="https://example.com/image.jpg" 
									   style="flex: 1;" onchange="validateImageUrl(this)">
								<button type="button" class="btn btn-sm btn-success" onclick="addImageUrl()">
									<i class="fas fa-plus"></i>
								</button>
							</div>
						</div>
						<small style="color: var(--text-secondary);">สามารถเพิ่มหลาย URL ได้</small>
					</div>
					
					<!-- Form Actions -->
					<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 25px; padding-top: 20px; border-top: 1px solid var(--border-color);">
						<button type="button" class="btn btn-secondary" onclick="closeRoomModal()">
							<i class="fas fa-times"></i> ยกเลิก
						</button>
						<button type="submit" class="btn btn-primary">
							<i class="fas fa-save"></i> บันทึก
						</button>
					</div>
				</form>
			</div>
		</div>
	</div>

	<!-- Filter/Search Modal -->
	<div id="filterModal" class="modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; backdrop-filter: blur(5px);">
		<div class="modal-content" style="background: white; margin: 100px auto; padding: 0; border-radius: 15px; max-width: 500px; box-shadow: 0 25px 50px rgba(0,0,0,0.3);">
			<!-- Modal Header -->
			<div class="modal-header" style="padding: 20px 25px; border-bottom: 2px solid var(--border-color); background: linear-gradient(135deg, var(--info-color), var(--primary-color)); color: white; border-radius: 15px 15px 0 0;">
				<h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
					<i class="fas fa-filter"></i>
					<span>ตัวกรองและการค้นหา</span>
				</h3>
				<button onclick="closeFilterModal()" style="position: absolute; top: 15px; right: 20px; background: rgba(255,255,255,0.2); border: none; color: white; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-size: 16px;">×</button>
			</div>
			
			<!-- Modal Body -->
			<div class="modal-body" style="padding: 25px;">
				<div class="form-group">
					<label class="form-label">
						<i class="fas fa-search"></i> ค้นหา
					</label>
					<input type="text" class="form-input" id="filterSearch" 
						   placeholder="ค้นหาจากชื่อ รหัส หรือรายละเอียด..." 
						   oninput="applyFilter()">
				</div>
				
				<div class="form-group">
					<label class="form-label">
						<i class="fas fa-sort"></i> เรียงตาม
					</label>
					<div style="display: flex; gap: 10px;">
						<select class="form-input" id="filterSortField" onchange="applySort()" style="flex: 2;">
							<option value="">ไม่เรียง</option>
							<option value="name">ชื่อ</option>
							<option value="code">รหัส</option>
							<option value="created">วันที่สร้าง</option>
							<option value="updated">วันที่อัปเดต</option>
						</select>
						<select class="form-input" id="filterSortDirection" onchange="applySort()" style="flex: 1;">
							<option value="asc">น้อย → มาก</option>
							<option value="desc">มาก → น้อย</option>
						</select>
					</div>
				</div>
				
				<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
					<button type="button" class="btn btn-secondary" onclick="clearFilter()">
						<i class="fas fa-times"></i> ล้างตัวกรอง
					</button>
					<button type="button" class="btn btn-primary" onclick="closeFilterModal()">
						<i class="fas fa-check"></i> ตกลง
					</button>
				</div>
			</div>
		</div>
	</div>	
	<!-- 1. Enhanced Google Sheets Section - เพิ่มใน Google Sheets section -->
	<div id="connectionBanner" class="connection-banner disconnected" style="padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 1px solid var(--border-color);">
		<i id="connectionIcon" class="fas fa-plug" style="font-size: 18px; margin-right: 10px;"></i>
		<span id="connectionText">ยังไม่ได้เชื่อมต่อ</span>
	</div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // =================== Global Variables ===================
        let currentVersion = 'live';
        let buildingsData = {};
        let roomsData = {};
        let sheetsConfig = {
            url: 'https://script.google.com/macros/s/AKfycbzpCFGZ_7kvyvAqiQGw3y_t6ROwUhh8Csp-I3xOPZZhP_XJ9Yyfyjsrl88s5qg3xx56/exec',
            buildingsSheet: 'Buildings',
            roomsSheet: 'Rooms',
            mapImagesSheet: 'MapImages',
            connected: false,
			requestTimeout: 15,
			retryAttempts: 3,
			autoSyncEnabled: false,
			debugModeEnabled: false			
        };
		const mapImageCache = new Map();		// ตัวแปรสำหรับ Map Image Cache
		let imageLoadingAbortController = new AbortController();
        let isLoggedIn = false;
        let isSystemReady = false;
		// Global variables for image management 

 				
		// ========== Walkable Points Data Management ==========
		let walkablePointsData = {
			currentBuilding: null,
			nodes: {},
			edges: [],
			settings: {
				maxConnectionDistance: 25, // เปอร์เซ็นต์
				metersPerPercent: 1.2,
				autoConnect: true,
				snapToGrid: false,
				gridSize: 5
			},
			selectedNodes: new Set(),
			isDragging: false,
			dragNode: null
		};
        // =================== Sequential Loading System ===================
        
        class SequentialLoader {
            constructor() {
                this.steps = [
                    { id: 'connection', name: 'ตรวจสอบการเชื่อมต่อ Google Sheets', status: 'pending' },
                    { id: 'buildings', name: 'โหลดข้อมูลอาคาร', status: 'pending' },
                    { id: 'rooms', name: 'โหลดข้อมูลห้อง', status: 'pending' },
                    { id: 'ui', name: 'อัปเดต UI และแดชบอร์ด', status: 'pending' }
                ];
                this.isLoading = false;
            }

            async startSequentialLoad() {
                if (this.isLoading) {
                    console.log('Sequential loading already in progress');
                    return false;
                }

                this.isLoading = true;
                this.showLoadingScreen();
                
                let allSuccess = true;
		 

                try {
                    // Step 1: Test Connection
                    this.updateStepStatus('connection', 'loading');
                    const connectionResult = await this.testConnectionStep();
                    this.updateStepStatus('connection', connectionResult ? 'success' : 'error');
                    
                    // Step 2: Load Buildings
                    this.updateStepStatus('buildings', 'loading');
                    const buildingsResult = await this.loadBuildingsStep();
                    this.updateStepStatus('buildings', buildingsResult ? 'success' : 'error');
                    if (!buildingsResult) allSuccess = false;

                    // Step 3: Load Rooms  
                    this.updateStepStatus('rooms', 'loading');
                    const roomsResult = await this.loadRoomsStep();
                    this.updateStepStatus('rooms', roomsResult ? 'success' : 'error');
                    if (!roomsResult) allSuccess = false;

                    // Step 4: Update UI (Always runs)
                    this.updateStepStatus('ui', 'loading');
                    await this.updateUIStep();
                    this.updateStepStatus('ui', 'success');

                    // Final status
                    isSystemReady = true;
                    this.updateGlobalStatus(allSuccess);

                    // Hide loading screen after delay
                    setTimeout(() => {
                        this.hideLoadingScreen();
                    }, 1500);
 

                    return allSuccess;

                } catch (error) {
                    console.error('Sequential loading failed:', error);
                    allSuccess = false;
                    this.updateGlobalStatus(false);
                    setTimeout(() => {
                        this.hideLoadingScreen();
                    }, 2000);
                    return false;
                } finally {
                    this.isLoading = false;
                }
				
            }

            async testConnectionStep() {
				 
                try {
                    if (!sheetsConfig.url) {
                        console.log('No Google Sheets URL configured');
                        sheetsConfig.connected = false;
                        return false;
                    }

                    const params = new URLSearchParams();
                    params.append('action', 'getData');
                    params.append('sheet', sheetsConfig.buildingsSheet);

                    const response = await Promise.race([
                        fetch(sheetsConfig.url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: params.toString()
                        }),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout')), 10000)
                        )
                    ]);

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success !== undefined) {
                            sheetsConfig.connected = true;
                            localStorage.setItem('sheetsConfig', JSON.stringify(sheetsConfig));
                            console.log('✅ Google Sheets connected');
                            return true;
                        }
                    }

                    throw new Error('Invalid response from Google Sheets');

                } catch (error) {
                    console.log('❌ Connection failed:', error.message);
                    sheetsConfig.connected = false;
                    return false;
                }
            }

            async loadBuildingsStep() {
                try { 
                    if (sheetsConfig.connected) { 
                        // Load from Google Sheets
                        const params = new URLSearchParams();
                        params.append('action', 'getData');
                        params.append('sheet', sheetsConfig.buildingsSheet);

                        const response = await Promise.race([
                            fetch(sheetsConfig.url, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: params.toString()
                            }),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Buildings load timeout')), 15000)
                            )
                        ]);

                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && result.data) {
                                const buildings = {};
                                result.data.forEach(building => {
                                    if (building.code) {
                                        buildings[building.code] = building;
                                    }
                                });
                                
                                buildingsData = buildings;
                                localStorage.setItem('buildingsData', JSON.stringify(buildings));
                                console.log('✅ Buildings loaded from Google Sheets:', Object.keys(buildings).length);
                                return true;
                            }
                        }
                        
                        throw new Error('Failed to load buildings from Google Sheets');
                    } else {
                        // Load from localStorage
                        const saved = localStorage.getItem('buildingsData');
                        if (saved) {
                            buildingsData = JSON.parse(saved);
                            console.log('✅ Buildings loaded from localStorage:', Object.keys(buildingsData).length);
                            return true;
                        } else {
                            buildingsData = {};
                            console.log('✅ Using empty buildings data');
                            return true;
                        }
                    }
                } catch (error) {
                    console.error('❌ Buildings loading failed:', error);
                    // Fallback to localStorage
                    const saved = localStorage.getItem('buildingsData');
                    buildingsData = saved ? JSON.parse(saved) : {};
                    return false;
                }
            }

            async loadRoomsStep() {
                try {
                    if (sheetsConfig.connected) {
                        // Load from Google Sheets
                        const params = new URLSearchParams();
                        params.append('action', 'getData');
                        params.append('sheet', sheetsConfig.roomsSheet);

                        const response = await Promise.race([
                            fetch(sheetsConfig.url, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: params.toString()
                            }),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Rooms load timeout')), 15000)
                            )
                        ]);

                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && result.data) {
                                const rooms = {};
                                result.data.forEach(room => {
                                    if (room.code) {
                                        // Parse images if needed
                                        if (typeof room.images === 'string') {
                                            try {
                                                room.images = JSON.parse(room.images);
                                            } catch (e) {
                                                room.images = [];
                                            }
                                        }
                                        if (!Array.isArray(room.images)) {
                                            room.images = [];
                                        }
                                        rooms[room.code] = room;
                                    }
                                });
                                
                                roomsData = rooms;
                                localStorage.setItem('roomsData', JSON.stringify(rooms));
                                console.log('✅ Rooms loaded from Google Sheets:', Object.keys(rooms).length);
                                return true;
                            }
                        }
                        
                        throw new Error('Failed to load rooms from Google Sheets');
                    } else {
                        // Load from localStorage
                        const saved = localStorage.getItem('roomsData');
                        if (saved) {
                            roomsData = JSON.parse(saved);
                            console.log('✅ Rooms loaded from localStorage:', Object.keys(roomsData).length);
                            return true;
                        } else {
                            roomsData = {};
                            console.log('✅ Using empty rooms data');
                            return true;
                        }
                    }
                } catch (error) {
                    console.error('❌ Rooms loading failed:', error);
                    // Fallback to localStorage
                    const saved = localStorage.getItem('roomsData');
                    roomsData = saved ? JSON.parse(saved) : {};
                    return false;
                }
            }

            async updateUIStep() {
                // Simulate UI update delay
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Update dashboard stats
                updateDashboardStats();
                
                // Update tables
                loadBuildingsTable();
                loadRoomsTable();
                
                // Update connection status
                updateConnectionStatus();
                
                console.log('✅ UI updated successfully');
                return true;
            }

            showLoadingScreen() {
                const screen = document.getElementById('sequentialLoading');
                if (screen) {
                    // Reset all steps to pending
                    this.steps.forEach(step => {
                        this.updateStepStatus(step.id, 'pending');
                    });
                    screen.classList.add('show');
                }
            }

            hideLoadingScreen() {
                const screen = document.getElementById('sequentialLoading');
                if (screen) {
                    screen.classList.remove('show');
                }
            }

            updateStepStatus(stepId, status) {
                const stepElement = document.getElementById(`step-${stepId}`);
                if (!stepElement) return;

                const icon = stepElement.querySelector('.step-icon');
                const text = stepElement.querySelector('.step-text');

                // Remove all status classes
                icon.classList.remove('pending', 'loading', 'success', 'error');
                text.classList.remove('loading', 'success', 'error');

                // Add new status class
                icon.classList.add(status);
                if (status !== 'pending') {
                    text.classList.add(status);
                }

                // Update icon content
                switch (status) {
                    case 'pending':
                        icon.textContent = stepElement.id.split('-')[1] === 'connection' ? '1' : 
                                          stepElement.id.split('-')[1] === 'buildings' ? '2' :
                                          stepElement.id.split('-')[1] === 'rooms' ? '3' : '4';
                        break;
                    case 'loading':
                        icon.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                        break;
                    case 'success':
                        icon.innerHTML = '<i class="fas fa-check"></i>';
                        break;
                    case 'error':
                        icon.innerHTML = '<i class="fas fa-times"></i>';
                        break;
                }

                // Update step in array
                const step = this.steps.find(s => s.id === stepId);
                if (step) step.status = status;
            }

            updateGlobalStatus(success) {
                const indicator = document.getElementById('globalStatusIndicator');
                if (!indicator) return;

                if (success) {
                    indicator.innerHTML = '<i class="fas fa-check-circle"></i> SYSTEM READY';
                    indicator.className = 'status-indicator status-active';
                } else {
                    indicator.innerHTML = '<i class="fas fa-exclamation-triangle"></i> SYSTEM ISSUES';
                    indicator.className = 'status-indicator status-error';
                }
            }
        }

        // Create global sequential loader instance
        const sequentialLoader = new SequentialLoader();

        // =================== Public Functions ===================
        
        async function sequentialLoadData() {
            showNotification('🔄 เริ่มโหลดข้อมูลแบบ Sequential...', 'info');
            const success = await sequentialLoader.startSequentialLoad();
            
            if (success) {
                showNotification('✅ โหลดข้อมูลเสร็จสิ้น!', 'success');
            } else {
                showNotification('⚠️ โหลดข้อมูลเสร็จสิ้น แต่มีบางส่วนที่ไม่สำเร็จ', 'warning');
            }
        }

        // =================== UI Update Functions ===================
        
        function updateDashboardStats() {
            const buildingCount = Object.keys(buildingsData).length;
            const roomCount = Object.keys(roomsData).length;
            const activeRooms = Object.values(roomsData).filter(room => room.status === 'active').length;

            document.getElementById('buildingCount').textContent = buildingCount;
            document.getElementById('roomCount').textContent = roomCount;
            document.getElementById('activeRooms').textContent = activeRooms;
        }

		// =================== Fixed Connection Status Update ===================

		function updateConnectionStatus() {
			const banner = document.getElementById('connectionBanner');
			const icon = document.getElementById('connectionIcon');
			const text = document.getElementById('connectionText');
			
			if (!banner || !icon || !text) return;
			
			if (sheetsConfig.connected) {
				banner.className = 'connection-banner connected';
				icon.className = 'fas fa-check-circle';
				text.textContent = 'เชื่อมต่อ Google Sheets สำเร็จ';
			} else if (sheetsConfig.url) {
				banner.className = 'connection-banner disconnected';
				icon.className = 'fas fa-exclamation-triangle';
				text.textContent = 'ยังไม่ได้ทดสอบการเชื่อมต่อ - คลิก "ทดสอบการเชื่อมต่อ"';
			} else {
				banner.className = 'connection-banner disconnected';
				icon.className = 'fas fa-times-circle';
				text.textContent = 'ยังไม่ได้ตั้งค่า Google Apps Script URL';
			}
		}

		console.log('🖼️ Enhanced image processing system loaded!');

        function loadBuildingsTable() {
            const tbody = document.getElementById('buildingsTableBody');
            if (!tbody) return;

            const buildings = Object.values(buildingsData);

            if (buildings.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            <i class="fas fa-building" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
                            <p>ยังไม่มีข้อมูลอาคาร</p>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = buildings.map(building => `
                <tr>
                    <td><strong>${building.code}</strong></td>
                    <td>${building.name}</td>
                    <td>${building.floors} ชั้น</td>
                    <td>${building.rooms || 0} ห้อง</td>
                    <td>
                        <span class="status-indicator ${building.status === 'active' ? 'status-active' : 'status-inactive'}">
                            ${building.status === 'active' ? 'ใช้งาน' : 'ไม่ใช้งาน'}
                        </span>
                    </td>
                    <td>
                        <button class="btn btn-sm btn-info" onclick="editBuilding('${building.code}')">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteBuilding('${building.code}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        function loadRoomsTable() {
            const tbody = document.getElementById('roomsTableBody');
            if (!tbody) return;

            const rooms = Object.values(roomsData);

            if (rooms.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            <i class="fas fa-door-open" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
                            <p>ยังไม่มีข้อมูลห้อง</p>
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = rooms.map(room => {
                const building = buildingsData[room.building];
                return `
                    <tr>
                        <td><strong>${room.code}</strong></td>
                        <td>${room.name}</td>
                        <td>${building ? building.name : room.building}</td>
                        <td>ชั้น ${room.floor || 'N/A'}</td>
                        <td>
                            <span style="background: rgba(102, 126, 234, 0.1); padding: 4px 8px; border-radius: 12px; font-size: 11px; color: var(--primary-color);">
                                ${room.type || 'ห้องเรียน'}
                            </span>
                        </td>
                        <td>
                            <span class="status-indicator ${getStatusClass(room.status)}">
                                ${getStatusText(room.status)}
                            </span>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-info" onclick="editRoom('${room.code}')">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteRoom('${room.code}')">
                                <i class="fas fa-trash"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // =================== Google Sheets Functions ===================
        
        async function testConnection() {
            const url = document.getElementById('sheetsUrl').value.trim();
            
            if (!url) {
                showNotification('❌ กรุณาใส่ URL ของ Google Sheets', 'error');
                return;
            }

            showNotification('🔄 กำลังทดสอบการเชื่อมต่อ...', 'info');

            try {
                const params = new URLSearchParams();
                params.append('action', 'getData');
                params.append('sheet', 'Buildings');

                const response = await Promise.race([
                    fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: params.toString()
                    }),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Connection timeout')), 10000)
                    )
                ]);

                if (response.ok) {
                    const result = await response.json();
                    if (result.success !== undefined) {
                        sheetsConfig.url = url;
                        sheetsConfig.connected = true;
                        localStorage.setItem('sheetsConfig', JSON.stringify(sheetsConfig));
                        updateConnectionStatus();
                        showNotification('✅ เชื่อมต่อ Google Sheets สำเร็จ!', 'success');
                        return true;
                    }
                }

                throw new Error('Invalid response from Google Sheets');

            } catch (error) {
                console.error('Connection test failed:', error);
                sheetsConfig.connected = false;
                updateConnectionStatus();
                showNotification(`❌ การเชื่อมต่อล้มเหลว: ${error.message}`, 'error');
                return false;
            }
        }

        function saveSheetConfig() {
            const url = document.getElementById('sheetsUrl').value.trim();
            const buildingsSheet = document.getElementById('buildingsSheetName').value.trim();
            const roomsSheet = document.getElementById('roomsSheetName').value.trim();
            const mapImagesSheet = document.getElementById('mapImagesSheetName').value.trim();

            sheetsConfig.url = url;
            sheetsConfig.buildingsSheet = buildingsSheet || 'Buildings';
            sheetsConfig.roomsSheet = roomsSheet || 'Rooms';
            sheetsConfig.mapImagesSheet = mapImagesSheet || 'MapImages';

            localStorage.setItem('sheetsConfig', JSON.stringify(sheetsConfig));
            showNotification('💾 บันทึกการตั้งค่า Google Sheets เรียบร้อย', 'success');
        }

        function loadSheetsConfig() {
            try {
                const saved = localStorage.getItem('sheetsConfig');
				 
                if (saved) {
                    const config = JSON.parse(saved);
                    sheetsConfig = { ...sheetsConfig, ...config };
					
					//alert(sheetsConfig.url);

                    // Update UI
                    document.getElementById('sheetsUrl').value = sheetsConfig.url || '';
                    document.getElementById('buildingsSheetName').value = sheetsConfig.buildingsSheet || 'Buildings';
                    document.getElementById('roomsSheetName').value = sheetsConfig.roomsSheet || 'Rooms';
                    document.getElementById('mapImagesSheetName').value = sheetsConfig.mapImagesSheet || 'MapImages';
                }
            } catch (error) {
                console.error('Error loading sheets config:', error);
            }
        }

        // =================== Utility Functions ===================
        
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            if (!notification) return;

            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function getStatusClass(status) {
            const statusClasses = {
                'active': 'status-active',
                'inactive': 'status-inactive',
                'maintenance': 'status-error'
            };
            return statusClasses[status] || 'status-inactive';
        }

        function getStatusText(status) {
            const statusTexts = {
                'active': 'ใช้งาน',
                'inactive': 'ไม่ใช้งาน',
                'maintenance': 'ปรับปรุง'
            };
            return statusTexts[status] || status;
        }

        // =================== Navigation Functions ===================
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');

            if (window.innerWidth > 768) {
                sidebar.classList.toggle('collapsed');
                mainContent.classList.toggle('expanded');
            }
        }

      /*  function showSection(sectionId) {
		alert('x');
            // Hide all sections
            document.querySelectorAll('.page-section').forEach(section => {
                section.classList.remove('active');
            });

            // Remove active class from all menu items
            document.querySelectorAll('.menu-item, .mobile-nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // Show target section
            const targetSection = document.getElementById(sectionId + '-section');
            if (targetSection) {
                targetSection.classList.add('active');
            }

            // Add active class to clicked menu item
            if (event && event.target) {
                const clickedItem = event.target.closest('.menu-item') || event.target.closest('.mobile-nav-item');
                if (clickedItem) {
                    clickedItem.classList.add('active');
                }
            }

            // Update page title
            const titles = {
                'dashboard': 'แดชบอร์ด',
                'buildings': 'จัดการอาคาร',
                'rooms': 'จัดการห้อง',
                'sheets': 'Google Sheets'
            };

            const pageTitle = document.getElementById('pageTitle');
            if (pageTitle && titles[sectionId]) {
                pageTitle.textContent = titles[sectionId];
            }

            // Close mobile sidebar if open
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                if (sidebar) {
                    sidebar.classList.remove('show');
                }
            }
        }*/

        function openUserInterface() {
            showNotification('🚀 กำลังเปิดหน้าผู้ใช้...', 'info');
            setTimeout(() => {
                window.open('index.html', '_blank');
                showNotification('✅ เปิดหน้าผู้ใช้ในแท็บใหม่', 'success');
            }, 1000);
        }

        // =================== Login System ===================
        
        function handleLogin(event) {
            event.preventDefault();

            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value.trim();
            const errorDiv = document.getElementById('loginError');

            if (username === 'admin' && password === '1234') {
                isLoggedIn = true;
                sessionStorage.setItem('adminLoggedIn', 'true');

                document.getElementById('loginContainer').style.display = 'none';
                document.getElementById('adminContainer').style.display = 'flex';

                initializeAdmin();
                showNotification('🎉 เข้าสู่ระบบสำเร็จ!', 'success');
            } else {
                errorDiv.style.display = 'block';
                errorDiv.textContent = '❌ Username หรือ Password ไม่ถูกต้อง';

                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 3000);
            }
        }

        function handleLogout() {
            if (confirm('คุณต้องการออกจากระบบใช่หรือไม่?')) {
                isLoggedIn = false;
                sessionStorage.removeItem('adminLoggedIn');

                document.getElementById('adminContainer').style.display = 'none';
                document.getElementById('loginContainer').style.display = 'flex';

                document.getElementById('loginUsername').value = '';
                document.getElementById('loginPassword').value = '';

                showNotification('👋 ออกจากระบบเรียบร้อย', 'info');
            }
        }

        function checkLoginStatus() {
            const loggedIn = sessionStorage.getItem('adminLoggedIn');
            if (loggedIn === 'true') {
                isLoggedIn = true;
                document.getElementById('loginContainer').style.display = 'none';
                document.getElementById('adminContainer').style.display = 'flex';
                return true;
            }
            return false;
        }

        // =================== Event Handlers ===================
        
        function setupEventHandlers() {
            console.log('🔗 Setting up event handlers...');
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    // Close any open modals
                }

                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    sequentialLoadData();
                }
            });

            // Mobile menu toggle
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('sidebar-toggle') && window.innerWidth <= 768) {
                    const sidebar = document.getElementById('sidebar');
                    if (sidebar) {
                        sidebar.classList.toggle('show');
                    }
                }
            });
        }

        
		
		// =================== Deployment Guide Functions ===================

		// =================== Accordion Functions ===================

		function toggleAccordion(headerElement) {
			const content = headerElement.nextElementSibling;
			const icon = headerElement.querySelector('.fas');
			
			// Toggle display
			if (content.style.display === 'none' || !content.style.display) {
				content.style.display = 'block';
				headerElement.classList.add('active');
			} else {
				content.style.display = 'none';
				headerElement.classList.remove('active');
			}
		}
 
		 // =================== Enhanced Google Sheets Functions ===================

		let setupProgress = {
			steps: [false, false, false, false],
			currentStep: 0
		};

		let debugMode = false; 


		// Debug logging function
 

		function debugLog(message, type = 'info') {
			// Console logging
			const prefix = {
				'success': '✅',
				'error': '❌', 
				'warning': '⚠️',
				'info': '💡'
			}[type] || '📝';
			
			console.log(`${prefix} ${message}`);
			
			// UI debug panel (if exists)
			const output = document.getElementById('debugOutput');
			if (output && (debugMode || type === 'error')) {
				const timestamp = new Date().toLocaleTimeString();
				const line = document.createElement('div');
				line.className = `debug-line debug-${type}`;
				line.innerHTML = `<span class="debug-timestamp">[${timestamp}]</span>${message}`;
				
				output.appendChild(line);
				output.scrollTop = output.scrollHeight;
				
				// Keep only last 100 lines
				while (output.children.length > 100) {
					output.removeChild(output.firstChild);
				}
			}
		}

		function toggleStep(stepNumber) {
			const step = document.querySelector(`[data-step="${stepNumber}"]`);
			if (!step) return;
			
			const content = step.querySelector('.step-content');
			const header = step.querySelector('.step-header');
			const chevron = header?.querySelector('.step-chevron');
			
			if (content && header) {
				if (content.style.display === 'none') {
					content.style.display = 'block';
					if (chevron) chevron.style.transform = 'rotate(180deg)';
					header.classList.add('active');
				} else {
					content.style.display = 'none';
					if (chevron) chevron.style.transform = 'rotate(0deg)';
					header.classList.remove('active');
				}
			}
		}

		function markStepComplete(stepNumber) {
			if (stepNumber < 1 || stepNumber > 4) return;
			
			setupProgress.steps[stepNumber - 1] = true;
			
			const step = document.querySelector(`[data-step="${stepNumber}"]`);
			if (step) {
				const header = step.querySelector('.step-header');
				const stepNum = header?.querySelector('.step-number');
				
				if (header) header.classList.add('completed');
				if (stepNum) stepNum.innerHTML = '<i class="fas fa-check"></i>';
			}
			
			updateSetupProgress();
			
			// Auto-open next step
			if (stepNumber < 4 && !setupProgress.steps[stepNumber]) {
				setTimeout(() => {
					toggleStep(stepNumber + 1);
				}, 500);
			}
			
			showNotification(`✅ ขั้นตอนที่ ${stepNumber} เสร็จสมบูรณ์!`, 'success');
		}

		// =================== Fixed Progress Functions ===================

		function updateSetupProgress() {
			const percentElement = document.getElementById('setupProgressPercent');
			const barElement = document.getElementById('setupProgressBar');
			
			if (!percentElement || !barElement) return;
			
			try {
				const completedSteps = setupProgress.steps.filter(step => step).length;
				const progressPercent = (completedSteps / 4) * 100;
				
				percentElement.textContent = `${progressPercent.toFixed(0)}%`;
				barElement.style.width = `${progressPercent}%`;
				
				if (completedSteps === 4) {
					const statusElement = document.getElementById('setupCompleteStatus');
					if (statusElement) {
						statusElement.style.display = 'block';
					}
				}
				
			} catch (error) {
				console.error('❌ Error updating setup progress:', error);
			}
}
 

		// =================== Enhanced Configuration ===================

		function saveSheetConfigEnhanced() {
			const url = document.getElementById('sheetsUrl')?.value?.trim();
			const buildingsSheet = document.getElementById('buildingsSheetName')?.value?.trim();
			const roomsSheet = document.getElementById('roomsSheetName')?.value?.trim();
			const mapImagesSheet = document.getElementById('mapImagesSheetName')?.value?.trim();
			const autoSync = document.getElementById('autoSyncEnabled')?.checked;
			const debug = document.getElementById('debugModeEnabled')?.checked;
			
			// Validate URL format
			if (url && !isValidSheetsUrl(url)) {
				showNotification('❌ URL ไม่ถูกต้อง กรุณาตรวจสอบรูปแบบ', 'error');
				return;
			}
			
			sheetsConfig.url = url || '';
			sheetsConfig.buildingsSheet = buildingsSheet || 'Buildings';
			sheetsConfig.roomsSheet = roomsSheet || 'Rooms';
			sheetsConfig.mapImagesSheet = mapImagesSheet || 'MapImages';
			sheetsConfig.autoSync = autoSync !== false;
			sheetsConfig.debugMode = debug || false;
			
			// Save advanced settings
			sheetsConfig.timeout = parseInt(document.getElementById('requestTimeout')?.value || '15');
			sheetsConfig.retryAttempts = parseInt(document.getElementById('retryAttempts')?.value || '3');
			
			localStorage.setItem('sheetsConfig', JSON.stringify(sheetsConfig));
			
			// Update debug mode
			debugMode = debug || false;
			localStorage.setItem('debugMode', debugMode.toString());
			
			showNotification('💾 บันทึกการตั้งค่า Google Sheets เรียบร้อย', 'success');
			addSyncHistoryItem('⚙️ อัปเดตการตั้งค่าระบบ', 'info');
			
			debugLog('💾 Configuration saved:', 'info');
			debugLog(JSON.stringify(sheetsConfig, null, 2), 'info');
		}

		// =================== Connection Status Functions ===================

		// Update connection status banner
		function updateConnectionBanner(status, message) {
			const banner = document.getElementById('connectionBanner');
			const icon = document.getElementById('connectionIcon');
			const text = document.getElementById('connectionText');
			
			if (!banner || !icon || !text) return;
			
			banner.classList.remove('connected', 'disconnected', 'testing');
			banner.classList.add(status);
			
			if (status === 'connected') {
				icon.style.color = 'var(--accent-color)';
			} else if (status === 'disconnected') {
				icon.style.color = 'var(--danger-color)';
			} else if (status === 'testing') {
				icon.style.color = 'var(--info-color)';
			}
			
			text.textContent = message;
		}

		// =================== Safe URL Validation ===================

		function validateUrlInput(input) {
			const validation = document.getElementById('urlValidation');
			if (!validation) return;
			
			const url = input.value.trim();
			
			if (!url) {
				validation.innerHTML = '';
				return;
			}
			
			if (isValidSheetsUrl(url)) {
				validation.innerHTML = '<i class="fas fa-check-circle"></i> URL ถูกต้อง';
				validation.className = 'url-validation valid';
			} else {
				validation.innerHTML = '<i class="fas fa-times-circle"></i> URL ไม่ถูกต้อง - ต้องเป็น Google Apps Script Web App URL';
				validation.className = 'url-validation invalid';
			}
		}

		function isValidSheetsUrl(url) {
			return url.includes('script.google.com') && 
				   url.includes('/macros/s/') && 
				   url.endsWith('/exec');
		}

		function clearUrl() {
			document.getElementById('sheetsUrl').value = '';
			document.getElementById('urlValidation').innerHTML = '';
			sheetsConfig.url = '';
			sheetsConfig.connected = false;
			updateConnectionBanner('disconnected', 'ยังไม่ได้ระบุ URL');
		}
		
		
		// Initialize missing elements after DOM load
		document.addEventListener('DOMContentLoaded', function() {
			// Add URL validation to sheets URL input
			const sheetsUrlInput = document.getElementById('sheetsUrl');
			if (sheetsUrlInput) {
				sheetsUrlInput.addEventListener('input', function() {
					validateUrlInput(this);
				});
			}
			
			// Initialize debug mode from localStorage
			const debugMode = localStorage.getItem('debugMode') === 'true';
			const debugCheckbox = document.getElementById('debugModeEnabled');
			if (debugCheckbox) {
				debugCheckbox.checked = debugMode;
			}
			
			console.log('✅ Missing elements initialized');
		});

		// =================== Batch Sync Functions ===================

		async function batchSyncToSheets() {
			if (!sheetsConfig.connected || !sheetsConfig.url) {
				showNotification('❌ ยังไม่ได้เชื่อมต่อ Google Sheets', 'error');
				return;
			}
			
			try {
				showNotification('☁️ กำลังซิงค์ข้อมูลทั้งหมดไปยัง Google Sheets...', 'info');
				debugLog('🔄 Starting batch sync...', 'info');
				
				let totalItems = 0;
				let successCount = 0;
				let errorCount = 0;
				
				// Sync Buildings
				const buildings = Object.values(buildingsData);
				totalItems += buildings.length;
				
				for (const building of buildings) {
					try {
						await syncBuildingToSheets(building, true);
						successCount++;
						debugLog(`✅ Synced building: ${building.code}`, 'success');
					} catch (error) {
						errorCount++;
						debugLog(`❌ Failed to sync building ${building.code}: ${error.message}`, 'error');
					}
				}
				
				// Sync Rooms
				const rooms = Object.values(roomsData);
				totalItems += rooms.length;
				
				for (const room of rooms) {
					try {
						await syncRoomToSheets(room, true);
						successCount++;
						debugLog(`✅ Synced room: ${room.code}`, 'success');
					} catch (error) {
						errorCount++;
						debugLog(`❌ Failed to sync room ${room.code}: ${error.message}`, 'error');
					}
				}
				
				const successMessage = `✅ ซิงค์สำเร็จ ${successCount}/${totalItems} รายการ`;
				showNotification(successMessage, successCount === totalItems ? 'success' : 'warning');
				addSyncHistoryItem(successMessage, successCount === totalItems ? 'success' : 'warning');
				
				if (errorCount > 0) {
					addSyncHistoryItem(`❌ ซิงค์ล้มเหลว ${errorCount} รายการ`, 'error');
				}
				
				debugLog(`🏁 Batch sync completed: ${successCount} success, ${errorCount} errors`, 'info');
				
			} catch (error) {
				console.error('Batch sync error:', error);
				showNotification('❌ ไม่สามารถซิงค์ข้อมูลได้', 'error');
				addSyncHistoryItem(`❌ Batch sync ล้มเหลว: ${error.message}`, 'error');
				debugLog(`❌ Batch sync failed: ${error.message}`, 'error');
			}
		}

		// =================== Improved AddSyncHistoryItem ===================	
		function addSyncHistoryItem(message, type) {
			console.log(`📊 Map Sync History: ${message} (${type})`);
			
			try {
				const history = JSON.parse(localStorage.getItem('mapSyncHistory') || '[]');
				const item = {
					message,
					type,
					timestamp: new Date().toLocaleString('th-TH')
				};
				
				history.unshift(item);
				history.splice(10); // Keep only last 10 items
				localStorage.setItem('mapSyncHistory', JSON.stringify(history));
				
				// Update UI if container exists
				updateMapSyncHistoryUI();
				
			} catch (error) {
				console.error('❌ Error adding map sync history item:', error);
			}
		}
		
		function updateMapSyncHistoryUI() {
			const container = document.getElementById('mapSyncHistory');
			if (!container) return;
			
			try {
				const history = JSON.parse(localStorage.getItem('mapSyncHistory') || '[]');
				
				if (history.length === 0) {
					container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; margin: 0;">ยังไม่มีประวัติการซิงค์</p>';
					return;
				}
				
				container.innerHTML = history.map(item => `
					<div style="
						padding: 10px 15px; margin-bottom: 8px; border-radius: 8px; font-size: 13px;
						background: ${item.type === 'success' ? 'rgba(40, 167, 69, 0.1)' : 
									 item.type === 'error' ? 'rgba(220, 53, 69, 0.1)' : 'rgba(23, 162, 184, 0.1)'};
						color: ${item.type === 'success' ? 'var(--accent-color)' : 
								 item.type === 'error' ? 'var(--danger-color)' : 'var(--info-color)'};
						border-left: 3px solid ${item.type === 'success' ? 'var(--accent-color)' : 
												 item.type === 'error' ? 'var(--danger-color)' : 'var(--info-color)'};
					">
						<div style="font-weight: 600;">${item.message}</div>
						<div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">${item.timestamp}</div>
					</div>
				`).join('');
				
			} catch (error) {
				console.error('❌ Error updating map sync history UI:', error);
			}
		}		
		function updateSyncHistoryUI() {
			const container = document.getElementById('syncHistoryContainer');
			if (!container) return;
			
			try {
				const history = JSON.parse(localStorage.getItem('syncHistory') || '[]');
				
				if (history.length === 0) {
					container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; margin: 0;">ยังไม่มีประวัติการซิงค์</p>';
					return;
				}
				
				container.innerHTML = history.map(item => `
					<div style="
						padding: 10px 15px; margin-bottom: 8px; border-radius: 8px; font-size: 13px;
						background: ${item.type === 'success' ? 'rgba(40, 167, 69, 0.1)' : 
									item.type === 'error' ? 'rgba(220, 53, 69, 0.1)' : 
									item.type === 'warning' ? 'rgba(255, 193, 7, 0.1)' : 'rgba(23, 162, 184, 0.1)'};
						color: ${item.type === 'success' ? 'var(--accent-color)' : 
								 item.type === 'error' ? 'var(--danger-color)' : 
								 item.type === 'warning' ? '#856404' : 'var(--info-color)'};
						border-left: 3px solid ${item.type === 'success' ? 'var(--accent-color)' : 
												 item.type === 'error' ? 'var(--danger-color)' : 
												 item.type === 'warning' ? '#ffc107' : 'var(--info-color)'};
					">
						<div style="font-weight: 600;">${item.message}</div>
						<div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">${item.timestamp}</div>
					</div>
				`).join('');
				
			} catch (error) {
				console.error('❌ Error updating sync history UI:', error);
			}
		}

		// =================== Fixed Load Functions ===================

		function loadSyncHistory() {
			console.log('📊 Loading sync history...');
			
			const container = safeGetElement('syncHistoryContainer');
			if (!container) {
				console.log('ℹ️ Sync history container not found - skipping');
				return;
			}
			
			try {
				const history = JSON.parse(localStorage.getItem('syncHistory') || '[]');
				
				if (history.length === 0) {
					container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; margin: 0;">ยังไม่มีประวัติการซิงค์</p>';
					return;
				}
				
				container.innerHTML = '';
				history.forEach(item => {
					addSyncHistoryItemDirect(item.message, item.type, item.timestamp);
				});
				
				console.log('✅ Sync history loaded');
			} catch (error) {
				console.error('❌ Error loading sync history:', error);
				if (container) {
					container.innerHTML = '<p style="color: var(--danger-color); text-align: center; margin: 0;">ไม่สามารถโหลดประวัติการซิงค์ได้</p>';
				}
			}
		}

		
		function addSyncHistoryItemDirect(message, type, timestamp) {
			const container = safeGetElement('syncHistoryContainer');
			if (!container) {
				console.log(`📊 Sync History (no UI): ${message} (${type}) at ${timestamp}`);
				return;
			}
			
			const item = document.createElement('div');
			item.style.cssText = `
				padding: 10px 15px;
				margin-bottom: 8px;
				border-radius: 8px;
				font-size: 13px;
				background: ${type === 'success' ? 'rgba(40, 167, 69, 0.1)' : 
							 type === 'error' ? 'rgba(220, 53, 69, 0.1)' : 
							 type === 'warning' ? 'rgba(255, 193, 7, 0.1)' :
							 'rgba(23, 162, 184, 0.1)'};
				color: ${type === 'success' ? 'var(--accent-color)' : 
						 type === 'error' ? 'var(--danger-color)' : 
						 type === 'warning' ? '#856404' :
						 'var(--info-color)'};
				border-left: 3px solid ${type === 'success' ? 'var(--accent-color)' : 
										 type === 'error' ? 'var(--danger-color)' : 
										 type === 'warning' ? '#ffc107' :
										 'var(--info-color)'};
			`;
			
			item.innerHTML = `
				<div style="font-weight: 600;">${message}</div>
				<div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">${timestamp}</div>
			`;
			
			container.appendChild(item);
		}

		function clearSyncHistory() {
			if (confirm('คุณต้องการล้างประวัติการซิงค์ทั้งหมดใช่หรือไม่?')) {
				localStorage.removeItem('syncHistory');
				updateSyncHistoryUI();
				showNotification('🧹 ล้างประวัติการซิงค์เรียบร้อย', 'info');
			}
		}

		// =================== Apps Script Code Display ===================

		function showAppsScriptCode() {
			const modal = document.createElement('div');
			modal.style.cssText = `
				position: fixed; top: 0; left: 0; right: 0; bottom: 0;
				background: rgba(0,0,0,0.8); z-index: 9999;
				display: flex; align-items: center; justify-content: center;
				padding: 20px;
			`;
			
			modal.innerHTML = `
				<div style="background: white; border-radius: 15px; padding: 30px; max-width: 90%; max-height: 90%; overflow-y: auto;">
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
						<h4 style="color: var(--primary-color); margin: 0;">📄 Google Apps Script Code</h4>
						<button onclick="this.closest('div').parentElement.remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">×</button>
					</div>
					<p style="margin-bottom: 15px; color: var(--text-secondary);">คัดลอกโค้ดนี้ไปวางใน Google Apps Script Editor:</p>
					<textarea readonly style="width: 100%; height: 400px; font-family: monospace; font-size: 12px; border: 1px solid #ddd; border-radius: 5px; padding: 15px;" onclick="this.select()">
		// Google Apps Script Code for School Map System
		// Copy this entire code to your Google Apps Script project

		function doGet(e) {
			return handleRequest(e);
		}

		function doPost(e) {
			return handleRequest(e);
		}

		function handleRequest(e) {
			try {
				const action = e.parameter.action || e.parameters.action?.[0];
				
				switch (action) {
					case 'getData':
						return getData(e.parameter);
					case 'addData':
						return addData(e.parameter);
					case 'deleteData':
						return deleteData(e.parameter);
					case 'getBatchData':
						return getBatchData();
					case 'getMapImages':
						return getMapImages();
					case 'addMapImages':
						return addMapImages(e.parameter);
					default:
						return createErrorResponse('Invalid action');
				}
			} catch (error) {
				return createErrorResponse(error.toString());
			}
		}

		function createSuccessResponse(data, message = '') {
			return ContentService.createTextOutput(JSON.stringify({
				success: true,
				data: data,
				message: message,
				timestamp: new Date().toISOString()
			})).setMimeType(ContentService.MimeType.JSON);
		}

		function createErrorResponse(errorMessage) {
			return ContentService.createTextOutput(JSON.stringify({
				success: false,
				error: errorMessage,
				timestamp: new Date().toISOString()
			})).setMimeType(ContentService.MimeType.JSON);
		}

		// Add other functions from GoogleSheet_AppScripts.txt here...
					</textarea>
					<div style="text-align: center; margin-top: 15px;">
						<button onclick="navigator.clipboard.writeText(this.parentElement.previousElementSibling.value); alert('คัดลอกแล้ว!')" class="btn btn-primary">
							<i class="fas fa-copy"></i> คัดลอกโค้ด
						</button>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
		}

		// =================== Error Helper Functions ===================

		function getDetailedErrorMessage(error) {
			let errorMessage = '❌ การเชื่อมต่อล้มเหลว:\n\n';
			
			if (error.message.includes('Failed to fetch')) {
				errorMessage += '• ไม่สามารถเชื่อมต่อได้\n• ตรวจสอบอินเทอร์เน็ต\n• ตรวจสอบว่า Web App ถูก Deploy แล้ว';
			} else if (error.message.includes('404')) {
				errorMessage += '• ไม่พบ Web App (404)\n• ตรวจสอบ URL\n• ตรวจสอบการ Deploy ใหม่';
			} else if (error.message.includes('403')) {
				errorMessage += '• ไม่มีสิทธิ์เข้าถึง (403)\n• ตั้งค่า Execute as: Me\n• ตั้งค่า Who has access: Anyone';
			} else if (error.message.includes('timeout')) {
				errorMessage += '• การเชื่อมต่อหมดเวลา\n• ลองเพิ่ม Timeout ใน Advanced Options\n• ตรวจสอบความเร็วอินเทอร์เน็ต';
			} else if (error.message.includes('HTML')) {
				errorMessage += '• ได้รับ HTML แทน JSON\n• Web App ยังไม่ได้ Deploy ถูกต้อง\n• ลอง Deploy ใหม่อีกครั้ง';
			} else {
				errorMessage += error.message;
			}
			
			return errorMessage;
		}

		// =================== Fixed Enhanced Sheets Config Loading ===================

		function loadEnhancedSheetsConfig() {
			console.log('⚙️ Loading Enhanced Sheets Config...');
			try {
				// โหลดการตั้งค่าจาก localStorage
				const saved = localStorage.getItem('sheetsConfig');
				if (saved) {
					const config = JSON.parse(saved);
					sheetsConfig = { ...sheetsConfig, ...config };
					console.log('✅ Sheets config loaded');
				}
				return true;
			} catch (error) {
				console.error('❌ Error loading enhanced sheets config:', error);
				return false;
			}
		}
		
		// =================== Safe Element Update Functions ===================

		function safeSetValue(elementId, value) {
			const element = document.getElementById(elementId);
			if (element) {
				element.value = value;
				return true;
			}
			return false;
		}

		function safeSetChecked(elementId, checked) {
			const element = document.getElementById(elementId);
			if (element) {
				element.checked = checked;
				return true;
			}
			return false;
		}

		function safeSetTextContent(elementId, text) {
			const element = safeGetElement(elementId);
			if (element) {
				element.textContent = text;
				return true;
			}
			return false;
		}

		// =================== Initialize Enhanced Sheets Module ===================

		function initializeEnhancedSheetsModule() {
			console.log('📊 Initializing Enhanced Sheets Module...');
			try {
				// โหลดการตั้งค่า Sheets
				if (typeof loadSheetsConfig === 'function') {
					loadSheetsConfig();
				}
				
				console.log('✅ Enhanced Sheets Module initialized');
				return true;
			} catch (error) {
				console.error('❌ Error initializing Enhanced Sheets module:', error);
				return false;
			}
		}


		// =================== Full CRUD Implementation ===================

		let currentPage = 1;
		let itemsPerPage = 20;
		let totalItems = 0;
		let currentFilter = '';
		let currentSortField = '';
		let currentSortDirection = 'asc';
		let isEditMode = false;
		let editingItemId = null;

		// =================== Building CRUD Functions ===================

		async function createBuilding(buildingData) {
			try {
				showNotification('🏗️ กำลังเพิ่มอาคารใหม่...', 'info');
				
				// Generate code if not provided
				if (!buildingData.code) {
					buildingData.code = generateBuildingCode();
				}
				
				// Validate data
				const validation = validateBuildingData(buildingData);
				if (!validation.isValid) {
					throw new Error(validation.error);
				}
				
				// Add timestamps
				buildingData.created = new Date().toISOString();
				buildingData.updated = new Date().toISOString();
				
				// Save to local storage
				buildingsData[buildingData.code] = buildingData;
				localStorage.setItem('buildingsData', JSON.stringify(buildingsData));
				
				// Auto-sync to Google Sheets if enabled
				if (sheetsConfig.connected && sheetsConfig.autoSync) {
					await syncBuildingToSheets(buildingData, false);
				}
				
				// Update UI
				loadBuildingsTable();
				updateDashboardStats();
				
				showNotification(`✅ เพิ่มอาคาร ${buildingData.name} สำเร็จ!`, 'success');
				addSyncHistoryItem(`🏢 เพิ่มอาคาร ${buildingData.name}`, 'success');
				
				return buildingData;
				
			} catch (error) {
				console.error('Create building error:', error);
				showNotification(`❌ ไม่สามารถเพิ่มอาคารได้: ${error.message}`, 'error');
				throw error;
			}
		}

		async function updateBuilding(code, updatedData) {
			try {
				showNotification(`🔄 กำลังอัปเดตอาคาร ${code}...`, 'info');
				
				if (!buildingsData[code]) {
					throw new Error('ไม่พบอาคารที่ต้องการอัปเดต');
				}
				
				// Validate updated data
				const validation = validateBuildingData(updatedData);
				if (!validation.isValid) {
					throw new Error(validation.error);
				}
				
				// Preserve created timestamp and update timestamp
				updatedData.created = buildingsData[code].created;
				updatedData.updated = new Date().toISOString();
				
				// Update local storage
				buildingsData[code] = updatedData;
				localStorage.setItem('buildingsData', JSON.stringify(buildingsData));
				
				// Auto-sync to Google Sheets if enabled
				if (sheetsConfig.connected && sheetsConfig.autoSync) {
					await syncBuildingToSheets(updatedData, false);
				}
				
				// Update UI
				loadBuildingsTable();
				updateDashboardStats();
				
				showNotification(`✅ อัปเดตอาคาร ${updatedData.name} สำเร็จ!`, 'success');
				addSyncHistoryItem(`🔄 อัปเดตอาคาร ${updatedData.name}`, 'success');
				
				return updatedData;
				
			} catch (error) {
				console.error('Update building error:', error);
				showNotification(`❌ ไม่สามารถอัปเดตอาคารได้: ${error.message}`, 'error');
				throw error;
			}
		}

		async function deleteBuilding(code) {
			try {
				if (!buildingsData[code]) {
					throw new Error('ไม่พบอาคารที่ต้องการลบ');
				}
				
				const buildingName = buildingsData[code].name;
				
				// Check if any rooms belong to this building
				const roomsInBuilding = Object.values(roomsData).filter(room => room.building === code);
				if (roomsInBuilding.length > 0) {
					throw new Error(`ไม่สามารถลบอาคารได้ เนื่องจากมีห้อง ${roomsInBuilding.length} ห้องในอาคารนี้`);
				}
				
				showNotification(`🗑️ กำลังลบอาคาร ${buildingName}...`, 'info');
				
				// Delete from local storage
				delete buildingsData[code];
				localStorage.setItem('buildingsData', JSON.stringify(buildingsData));
				
				// Delete from Google Sheets if connected
				if (sheetsConfig.connected) {
					await deleteBuildingFromSheets(code);
				}
				
				// Update UI
				loadBuildingsTable();
				updateDashboardStats();
				
				showNotification(`✅ ลบอาคาร ${buildingName} เรียบร้อย`, 'success');
				addSyncHistoryItem(`🗑️ ลบอาคาร ${buildingName}`, 'warning');
				
			} catch (error) {
				console.error('Delete building error:', error);
				showNotification(`❌ ไม่สามารถลบอาคารได้: ${error.message}`, 'error');
				throw error;
			}
		}

		// =================== Room CRUD Functions ===================

		async function createRoom(roomData) {
			try {
				showNotification('🚪 กำลังเพิ่มห้องใหม่...', 'info');
				
				// Generate code if not provided
				if (!roomData.code) {
					roomData.code = generateRoomCode();
				}
				
				// Validate data
				const validation = validateRoomData(roomData);
				if (!validation.isValid) {
					throw new Error(validation.error);
				}
				
				// Add timestamps
				roomData.created = new Date().toISOString();
				roomData.updated = new Date().toISOString();
				
				// Ensure images is an array
				if (!roomData.images) {
					roomData.images = [];
				}
				
				// Save to local storage
				roomsData[roomData.code] = roomData;
				localStorage.setItem('roomsData', JSON.stringify(roomsData));
				
				// Auto-sync to Google Sheets if enabled
				if (sheetsConfig.connected && sheetsConfig.autoSync) {
					await syncRoomToSheets(roomData, false);
				}
				
				// Update UI
				loadRoomsTable();
				updateDashboardStats();
				
				showNotification(`✅ เพิ่มห้อง ${roomData.name} สำเร็จ!`, 'success');
				addSyncHistoryItem(`🚪 เพิ่มห้อง ${roomData.name}`, 'success');
				
				return roomData;
				
			} catch (error) {
				console.error('Create room error:', error);
				showNotification(`❌ ไม่สามารถเพิ่มห้องได้: ${error.message}`, 'error');
				throw error;
			}
		}

		async function updateRoom(code, updatedData) {
			try {
				showNotification(`🔄 กำลังอัปเดตห้อง ${code}...`, 'info');
				
				if (!roomsData[code]) {
					throw new Error('ไม่พบห้องที่ต้องการอัปเดต');
				}
				
				// Validate updated data
				const validation = validateRoomData(updatedData);
				if (!validation.isValid) {
					throw new Error(validation.error);
				}
				
				// Preserve created timestamp and update timestamp
				updatedData.created = roomsData[code].created;
				updatedData.updated = new Date().toISOString();
				
				// Ensure images is an array
				if (!updatedData.images) {
					updatedData.images = [];
				}
				
				// Update local storage
				roomsData[code] = updatedData;
				localStorage.setItem('roomsData', JSON.stringify(roomsData));
				
				// Auto-sync to Google Sheets if enabled
				if (sheetsConfig.connected && sheetsConfig.autoSync) {
					await syncRoomToSheets(updatedData, false);
				}
				
				// Update UI
				loadRoomsTable();
				updateDashboardStats();
				
				showNotification(`✅ อัปเดตห้อง ${updatedData.name} สำเร็จ!`, 'success');
				addSyncHistoryItem(`🔄 อัปเดตห้อง ${updatedData.name}`, 'success');
				
				return updatedData;
				
			} catch (error) {
				console.error('Update room error:', error);
				showNotification(`❌ ไม่สามารถอัปเดตห้องได้: ${error.message}`, 'error');
				throw error;
			}
		}

		async function deleteRoom(code) {
			try {
				if (!roomsData[code]) {
					throw new Error('ไม่พบห้องที่ต้องการลบ');
				}
				
				const roomName = roomsData[code].name;
				
				showNotification(`🗑️ กำลังลบห้อง ${roomName}...`, 'info');
				
				// Delete from local storage
				delete roomsData[code];
				localStorage.setItem('roomsData', JSON.stringify(roomsData));
				
				// Delete from Google Sheets if connected
				if (sheetsConfig.connected) {
					await deleteRoomFromSheets(code);
				}
				
				// Update UI
				loadRoomsTable();
				updateDashboardStats();
				
				showNotification(`✅ ลบห้อง ${roomName} เรียบร้อย`, 'success');
				addSyncHistoryItem(`🗑️ ลบห้อง ${roomName}`, 'warning');
				
			} catch (error) {
				console.error('Delete room error:', error);
				showNotification(`❌ ไม่สามารถลบห้องได้: ${error.message}`, 'error');
				throw error;
			}
		}

		// =================== Pagination Functions ===================

		function paginateData(data, page, perPage) {
			const startIndex = (page - 1) * perPage;
			const endIndex = startIndex + perPage;
			return data.slice(startIndex, endIndex);
		}

		function createPaginationControls(totalItems, currentPage, itemsPerPage, containerId) {
			const container = document.getElementById(containerId);
			if (!container) return;
			
			const totalPages = Math.ceil(totalItems / itemsPerPage);
			
			if (totalPages <= 1) {
				container.innerHTML = '';
				return;
			}
			
			let paginationHTML = `
				<div class="pagination-controls" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; flex-wrap: wrap; gap: 10px;">
					<div class="pagination-info" style="color: var(--text-secondary); font-size: 14px;">
						แสดง ${((currentPage - 1) * itemsPerPage) + 1}-${Math.min(currentPage * itemsPerPage, totalItems)} จาก ${totalItems} รายการ
					</div>
					
					<div class="pagination-buttons" style="display: flex; gap: 5px; align-items: center;">
						<button class="btn btn-sm btn-secondary" onclick="changePage(1)" ${currentPage === 1 ? 'disabled' : ''}>
							<i class="fas fa-angle-double-left"></i>
						</button>
						<button class="btn btn-sm btn-secondary" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
							<i class="fas fa-angle-left"></i>
						</button>
			`;
			
			// Page numbers
			const maxVisiblePages = 5;
			let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
			let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
			
			if (endPage - startPage + 1 < maxVisiblePages) {
				startPage = Math.max(1, endPage - maxVisiblePages + 1);
			}
			
			for (let i = startPage; i <= endPage; i++) {
				paginationHTML += `
					<button class="btn btn-sm ${i === currentPage ? 'btn-primary' : 'btn-secondary'}" 
							onclick="changePage(${i})" ${i === currentPage ? 'disabled' : ''}>
						${i}
					</button>
				`;
			}
			
			paginationHTML += `
						<button class="btn btn-sm btn-secondary" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
							<i class="fas fa-angle-right"></i>
						</button>
						<button class="btn btn-sm btn-secondary" onclick="changePage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>
							<i class="fas fa-angle-double-right"></i>
						</button>
					</div>
					
					<div class="items-per-page" style="display: flex; align-items: center; gap: 5px;">
						<span style="font-size: 14px;">แสดง:</span>
						<select onchange="changeItemsPerPage(this.value)" style="padding: 5px; border-radius: 5px; border: 1px solid var(--border-color);">
							<option value="10" ${itemsPerPage === 10 ? 'selected' : ''}>10</option>
							<option value="20" ${itemsPerPage === 20 ? 'selected' : ''}>20</option>
							<option value="50" ${itemsPerPage === 50 ? 'selected' : ''}>50</option>
							<option value="100" ${itemsPerPage === 100 ? 'selected' : ''}>100</option>
						</select>
						<span style="font-size: 14px;">รายการ</span>
					</div>
				</div>
			`;
			
			container.innerHTML = paginationHTML;
		}

		function changePage(newPage) {
			currentPage = newPage;
			const activeSection = document.querySelector('.page-section.active');
			
			if (activeSection && activeSection.id === 'rooms-section') {
				loadRoomsTable();
			} else if (activeSection && activeSection.id === 'buildings-section') {
				loadBuildingsTable();
			}
		}

		function changeItemsPerPage(newItemsPerPage) {
			itemsPerPage = parseInt(newItemsPerPage);
			currentPage = 1; // Reset to first page
			
			const activeSection = document.querySelector('.page-section.active');
			
			if (activeSection && activeSection.id === 'rooms-section') {
				loadRoomsTable();
			} else if (activeSection && activeSection.id === 'buildings-section') {
				loadBuildingsTable();
			}
		}

		// =================== Enhanced Table Loading with Pagination ===================

		function loadBuildingsTable() {
			const tbody = document.getElementById('buildingsTableBody');
			if (!tbody) return;
			
			let buildings = Object.values(buildingsData);
			
			// Apply filter
			if (currentFilter) {
				buildings = buildings.filter(building => 
					building.name.toLowerCase().includes(currentFilter.toLowerCase()) ||
					building.code.toLowerCase().includes(currentFilter.toLowerCase()) ||
					(building.description && building.description.toLowerCase().includes(currentFilter.toLowerCase()))
				);
			}
			
			// Apply sorting
			if (currentSortField) {
				buildings.sort((a, b) => {
					let aVal = a[currentSortField] || '';
					let bVal = b[currentSortField] || '';
					
					if (typeof aVal === 'string') {
						aVal = aVal.toLowerCase();
						bVal = bVal.toLowerCase();
					}
					
					if (currentSortDirection === 'asc') {
						return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
					} else {
						return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
					}
				});
			}
			
			totalItems = buildings.length;
			
			// Apply pagination
			const paginatedBuildings = paginateData(buildings, currentPage, itemsPerPage);
			
			if (paginatedBuildings.length === 0) {
				tbody.innerHTML = `
					<tr>
						<td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
							<i class="fas fa-building" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
							<p>${buildings.length === 0 ? 'ยังไม่มีข้อมูลอาคาร' : 'ไม่พบข้อมูลที่ตรงกับการค้นหา'}</p>
						</td>
					</tr>
				`;
			} else {
				tbody.innerHTML = paginatedBuildings.map(building => `
					<tr>
						<td><strong>${building.code}</strong></td>
						<td>${building.name}</td>
						<td>${building.floors} ชั้น</td>
						<td>${building.rooms || 0} ห้อง</td>
						<td>
							<span class="status-indicator ${building.status === 'active' ? 'status-active' : 'status-inactive'}">
								${building.status === 'active' ? 'ใช้งาน' : 'ไม่ใช้งาน'}
							</span>
						</td>
						<td>
							<button class="btn btn-sm btn-info" onclick="editBuilding('${building.code}')" title="แก้ไข">
								<i class="fas fa-edit"></i>
							</button>
							<button class="btn btn-sm btn-danger" onclick="confirmDeleteBuilding('${building.code}')" title="ลบ">
								<i class="fas fa-trash"></i>
							</button>
						</td>
					</tr>
				`).join('');
			}
			
			// Update pagination controls
			createPaginationControls(totalItems, currentPage, itemsPerPage, 'buildingsPagination');
		}

		function loadRoomsTable() {
			const tbody = document.getElementById('roomsTableBody');
			if (!tbody) return;
			
			let rooms = Object.values(roomsData);
			
			// Apply filter
			if (currentFilter) {
				rooms = rooms.filter(room => 
					room.name.toLowerCase().includes(currentFilter.toLowerCase()) ||
					room.code.toLowerCase().includes(currentFilter.toLowerCase()) ||
					(room.type && room.type.toLowerCase().includes(currentFilter.toLowerCase())) ||
					(room.building && room.building.toLowerCase().includes(currentFilter.toLowerCase())) ||
					(room.description && room.description.toLowerCase().includes(currentFilter.toLowerCase()))
				);
			}
			
			// Apply sorting
			if (currentSortField) {
				rooms.sort((a, b) => {
					let aVal = a[currentSortField] || '';
					let bVal = b[currentSortField] || '';
					
					if (typeof aVal === 'string') {
						aVal = aVal.toLowerCase();
						bVal = bVal.toLowerCase();
					}
					
					if (currentSortDirection === 'asc') {
						return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
					} else {
						return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
					}
				});
			}
			
			totalItems = rooms.length;
			
			// Apply pagination
			const paginatedRooms = paginateData(rooms, currentPage, itemsPerPage);
			
			if (paginatedRooms.length === 0) {
				tbody.innerHTML = `
					<tr>
						<td colspan="7" style="text-align: center; padding: 40px; color: var(--text-secondary);">
							<i class="fas fa-door-open" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
							<p>${rooms.length === 0 ? 'ยังไม่มีข้อมูลห้อง' : 'ไม่พบข้อมูลที่ตรงกับการค้นหา'}</p>
						</td>
					</tr>
				`;
			} else {
				tbody.innerHTML = paginatedRooms.map(room => {
					const building = buildingsData[room.building];
					return `
						<tr>
							<td><strong>${room.code}</strong></td>
							<td>${room.name}</td>
							<td>${building ? building.name : room.building}</td>
							<td>ชั้น ${room.floor || 'N/A'}</td>
							<td>
								<span style="background: rgba(102, 126, 234, 0.1); padding: 4px 8px; border-radius: 12px; font-size: 11px; color: var(--primary-color);">
									${room.type || 'ห้องเรียน'}
								</span>
							</td>
							<td>
								<span class="status-indicator ${getStatusClass(room.status)}">
									${getStatusText(room.status)}
								</span>
							</td>
							<td>
								<button class="btn btn-sm btn-info" onclick="editRoom('${room.code}')" title="แก้ไข">
									<i class="fas fa-edit"></i>
								</button>
								<button class="btn btn-sm btn-danger" onclick="confirmDeleteRoom('${room.code}')" title="ลบ">
									<i class="fas fa-trash"></i>
								</button>
							</td>
						</tr>
					`;
				}).join('');
			}
			
			// Update pagination controls
			createPaginationControls(totalItems, currentPage, itemsPerPage, 'roomsPagination');
		}

		// =================== Validation Functions ===================

		function validateBuildingData(data) {
			if (!data.name || data.name.trim() === '') {
				return { isValid: false, error: 'กรุณาระบุชื่ออาคาร' };
			}
			
			if (!data.code || data.code.trim() === '') {
				return { isValid: false, error: 'กรุณาระบุรหัสอาคาร' };
			}
			
			// Check for duplicate code (excluding current building if editing)
			const existingBuilding = buildingsData[data.code];
			if (existingBuilding && !isEditMode) {
				return { isValid: false, error: `รหัสอาคาร ${data.code} มีการใช้งานแล้ว` };
			}
			
			if (!data.floors || data.floors < 1) {
				return { isValid: false, error: 'กรุณาระบุจำนวนชั้นที่ถูกต้อง' };
			}
			
			if (!data.status) {
				return { isValid: false, error: 'กรุณาเลือกสถานะอาคาร' };
			}
			
			return { isValid: true };
		}

		function validateRoomData(data) {
			if (!data.name || data.name.trim() === '') {
				return { isValid: false, error: 'กรุณาระบุชื่อห้อง' };
			}
			
			if (!data.code || data.code.trim() === '') {
				return { isValid: false, error: 'กรุณาระบุรหัสห้อง' };
			}
			
			// Check for duplicate code (excluding current room if editing)
			const existingRoom = roomsData[data.code];
			if (existingRoom && !isEditMode) {
				return { isValid: false, error: `รหัสห้อง ${data.code} มีการใช้งานแล้ว` };
			}
			
			if (!data.building || data.building.trim() === '') {
				return { isValid: false, error: 'กรุณาเลือกอาคาร' };
			}
			
			if (!data.floor || data.floor < 1) {
				return { isValid: false, error: 'กรุณาระบุชั้นที่ถูกต้อง' };
			}
			
			if (!data.status) {
				return { isValid: false, error: 'กรุณาเลือกสถานะห้อง' };
			}
			
			return { isValid: true };
		}

		// =================== Code Generation Functions ===================

		function generateBuildingCode() {
			const buildings = Object.keys(buildingsData);
			const existingNumbers = buildings
				.filter(code => code.startsWith('B'))
				.map(code => parseInt(code.substring(1)))
				.filter(num => !isNaN(num));
			
			const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
			return 'B' + nextNumber.toString().padStart(3, '0');
		}

		function generateRoomCode() {
			const rooms = Object.keys(roomsData);
			const existingNumbers = rooms
				.filter(code => code.startsWith('R'))
				.map(code => parseInt(code.substring(1)))
				.filter(num => !isNaN(num));
			
			const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
			return 'R' + nextNumber.toString().padStart(4, '0');
		}

		// =================== Delete Confirmation Functions ===================

		function confirmDeleteBuilding(code) {
			const building = buildingsData[code];
			if (!building) return;
			
			const roomsInBuilding = Object.values(roomsData).filter(room => room.building === code);
			
			let message = `คุณต้องการลบอาคาร "${building.name}" (${code}) ใช่หรือไม่?`;
			
			if (roomsInBuilding.length > 0) {
				message += `\n\n⚠️ ข้อมูลอาคารนี้มีห้อง ${roomsInBuilding.length} ห้อง ไม่สามารถลบได้`;
				alert(message);
				return;
			}
			
			message += '\n\nการดำเนินการนี้ไม่สามารถยกเลิกได้';
			
			if (confirm(message)) {
				deleteBuilding(code);
			}
		}

		function confirmDeleteRoom(code) {
			const room = roomsData[code];
			if (!room) return;
			
			const message = `คุณต้องการลบห้อง "${room.name}" (${code}) ใช่หรือไม่?\n\nการดำเนินการนี้ไม่สามารถยกเลิกได้`;
			
			if (confirm(message)) {
				deleteRoom(code);
			}
		}

		// =================== Initialize CRUD Module ===================

		function initializeCRUDModule() {
			console.log('🔧 Initializing CRUD Module...');
			try {
			
				// Add pagination containers to tables if not exist
				const buildingsSection = document.getElementById('buildings-section');
				if (buildingsSection && !document.getElementById('buildingsPagination')) {
					const tableContainer = buildingsSection.querySelector('.admin-card');
					const paginationDiv = document.createElement('div');
					paginationDiv.id = 'buildingsPagination';
					tableContainer.appendChild(paginationDiv);
				}
				
				const roomsSection = document.getElementById('rooms-section');
				if (roomsSection && !document.getElementById('roomsPagination')) {
					const tableContainer = roomsSection.querySelector('.admin-card');
					const paginationDiv = document.createElement('div');
					paginationDiv.id = 'roomsPagination';
					tableContainer.appendChild(paginationDiv);
				}
				
				console.log('✅ CRUD Module initialized');
			} catch (error) {
				console.error('❌ Error initializing CRUD module:', error);
			}
		}
		
		
		// =================== Modal Management Functions ===================

		// =================== Building Modal Functions ===================

		function openBuildingModal(code = null) {
			const modal = document.getElementById('buildingModal');
			const title = document.getElementById('buildingModalTitle');
			const form = document.getElementById('buildingForm');
			
			// Reset form
			form.reset();
			
			if (code) {
				// Edit mode
				isEditMode = true;
				editingItemId = code;
				title.textContent = 'แก้ไขอาคาร';
				
				const building = buildingsData[code];
				if (building) {
					document.getElementById('buildingCode').value = building.code;
					document.getElementById('buildingName').value = building.name;
					document.getElementById('buildingFloors').value = building.floors || 1;
					document.getElementById('buildingYear').value = building.year || '';
					document.getElementById('buildingRooms').value = building.rooms || 0;
					document.getElementById('buildingStatus').value = building.status || 'active';
					document.getElementById('buildingDescription').value = building.description || '';
					
					// Disable code editing in edit mode
					document.getElementById('buildingCode').readOnly = true;
				}
			} else {
				// Add mode
				isEditMode = false;
				editingItemId = null;
				title.textContent = 'เพิ่มอาคารใหม่';
				
				// Enable code editing in add mode
				document.getElementById('buildingCode').readOnly = false;
				
				// Auto-generate code
				document.getElementById('buildingCode').value = generateBuildingCode();
			}
			
			modal.style.display = 'block';
			document.body.style.overflow = 'hidden'; // Prevent background scrolling
		}

		function closeBuildingModal() {
			const modal = document.getElementById('buildingModal');
			modal.style.display = 'none';
			document.body.style.overflow = 'auto';
			
			// Reset form and mode
			document.getElementById('buildingForm').reset();
			isEditMode = false;
			editingItemId = null;
		}

		async function saveBuildingForm(event) {
			event.preventDefault();
			
			try {
				const formData = {
					code: document.getElementById('buildingCode').value.trim(),
					name: document.getElementById('buildingName').value.trim(),
					floors: parseInt(document.getElementById('buildingFloors').value),
					year: parseInt(document.getElementById('buildingYear').value) || null,
					rooms: parseInt(document.getElementById('buildingRooms').value) || 0,
					status: document.getElementById('buildingStatus').value,
					description: document.getElementById('buildingDescription').value.trim()
				};
				
				if (isEditMode && editingItemId) {
					await updateBuilding(editingItemId, formData);
				} else {
					await createBuilding(formData);
				}
				
				closeBuildingModal();
				
			} catch (error) {
				// Error is already handled in CRUD functions
				console.error('Save building form error:', error);
			}
		}

		// =================== Room Modal Functions ===================

		function openRoomModal(code = null) {
			const modal = document.getElementById('roomModal');
			const title = document.getElementById('roomModalTitle');
			const form = document.getElementById('roomForm');
			
			// Reset form
			form.reset();
			
			// Populate building dropdown
			populateBuildingDropdown();
			
			// Reset image container
			resetImageUrlContainer();
			
			if (code) {
				// Edit mode
				isEditMode = true;
				editingItemId = code;
				title.textContent = 'แก้ไขห้อง';
				
				const room = roomsData[code];
				if (room) {
					document.getElementById('roomCode').value = room.code;
					document.getElementById('roomName').value = room.name;
					document.getElementById('roomBuilding').value = room.building;
					document.getElementById('roomFloor').value = room.floor || 1;
					document.getElementById('roomType').value = room.type || 'ห้องเรียน';
					document.getElementById('roomStatus').value = room.status || 'active';
					document.getElementById('roomX').value = room.x || '';
					document.getElementById('roomY').value = room.y || '';
					document.getElementById('roomDescription').value = room.description || '';
					
					// Load existing images
					if (room.images && Array.isArray(room.images)) {
						loadExistingImages(room.images);
					}
					
					// Disable code editing in edit mode
					document.getElementById('roomCode').readOnly = true;
				}
			} else {
				// Add mode
				isEditMode = false;
				editingItemId = null;
				title.textContent = 'เพิ่มห้องใหม่';
				
				// Enable code editing in add mode
				document.getElementById('roomCode').readOnly = false;
				
				// Auto-generate code
				document.getElementById('roomCode').value = generateRoomCode();
			}
			
			modal.style.display = 'block';
			document.body.style.overflow = 'hidden';
		}

		function closeRoomModal() {
			const modal = document.getElementById('roomModal');
			modal.style.display = 'none';
			document.body.style.overflow = 'auto';
			
			// Reset form and mode
			document.getElementById('roomForm').reset();
			isEditMode = false;
			editingItemId = null;
		}

		async function saveRoomForm(event) {
			event.preventDefault();
			
			try {
				const formData = {
					code: document.getElementById('roomCode').value.trim(),
					name: document.getElementById('roomName').value.trim(),
					building: document.getElementById('roomBuilding').value,
					floor: parseInt(document.getElementById('roomFloor').value),
					type: document.getElementById('roomType').value,
					status: document.getElementById('roomStatus').value,
					x: parseFloat(document.getElementById('roomX').value) || null,
					y: parseFloat(document.getElementById('roomY').value) || null,
					description: document.getElementById('roomDescription').value.trim(),
					images: collectImageUrls()
				};
				
				if (isEditMode && editingItemId) {
					await updateRoom(editingItemId, formData);
				} else {
					await createRoom(formData);
				}
				
				closeRoomModal();
				
			} catch (error) {
				// Error is already handled in CRUD functions
				console.error('Save room form error:', error);
			}
		}

		// =================== Helper Functions ===================

		function populateBuildingDropdown() {
			const select = document.getElementById('roomBuilding');
			const buildings = Object.values(buildingsData);
			
			// Clear existing options except the first one
			select.innerHTML = '<option value="">เลือกอาคาร</option>';
			
			buildings.forEach(building => {
				const option = document.createElement('option');
				option.value = building.code;
				option.textContent = `${building.name} (${building.code})`;
				select.appendChild(option);
			});
		}

		function resetImageUrlContainer() {
			const container = document.getElementById('roomImagesContainer');
			container.innerHTML = `
				<div class="image-url-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
					<input type="url" class="form-input" placeholder="https://example.com/image.jpg" 
						   style="flex: 1;" onchange="validateImageUrl(this)">
					<button type="button" class="btn btn-sm btn-success" onclick="addImageUrl()">
						<i class="fas fa-plus"></i>
					</button>
				</div>
			`;
		}

		// 🔧 แก้ไข 3: แก้ไข loadExistingImages() ให้ทำงานกับ image_urls จาก Google Sheets
		function loadExistingImages(images) {
			const container = document.getElementById('roomImagesContainer');
			if (!container) {
				console.error('❌ roomImagesContainer not found');
				return;
			}
			
			container.innerHTML = '';
			
			// ตรวจสอบ images data - รองรับทั้ง images และ image_urls
			let imageUrls = [];
			if (Array.isArray(images)) {
				imageUrls = images;
			} else if (typeof images === 'string') {
				try {
					imageUrls = JSON.parse(images);
				} catch (e) {
					imageUrls = [];
				}
			}
			
			console.log('📋 Loading existing images:', imageUrls);
			
			if (imageUrls.length === 0) {
				resetImageUrlContainer();
				return;
			}
			
			// แสดง existing URLs ในฟอร์ม
			imageUrls.forEach((url, index) => {
				addImageUrlInput(url, index === imageUrls.length - 1);
			});
			
			console.log(`✅ Loaded ${imageUrls.length} image URLs into form`);
		}

		function addImageUrl() {
			addImageUrlInput('', true);
		}

		function addImageUrlInput(value = '', isLast = false) {
			const container = document.getElementById('roomImagesContainer');
			
			const div = document.createElement('div');
			div.className = 'image-url-input';
			div.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px;';
			
			div.innerHTML = `
				<input type="url" class="form-input" placeholder="https://example.com/image.jpg" 
					   value="${value}" style="flex: 1;" onchange="validateImageUrl(this)">
				<button type="button" class="btn btn-sm btn-danger" onclick="removeImageUrl(this)">
					<i class="fas fa-minus"></i>
				</button>
				${isLast ? `
				<button type="button" class="btn btn-sm btn-success" onclick="addImageUrl()">
					<i class="fas fa-plus"></i>
				</button>
				` : ''}
			`;
			
			container.appendChild(div);
		}

		function removeImageUrl(button) {
			const container = document.getElementById('roomImagesContainer');
			const inputDiv = button.closest('.image-url-input');
			
			inputDiv.remove();
			
			// If no inputs left, add one
			if (container.children.length === 0) {
				resetImageUrlContainer();
			} else {
				// Make sure the last input has an add button
				const lastInput = container.lastElementChild;
				if (!lastInput.querySelector('.btn-success')) {
					const addButton = document.createElement('button');
					addButton.type = 'button';
					addButton.className = 'btn btn-sm btn-success';
					addButton.onclick = addImageUrl;
					addButton.innerHTML = '<i class="fas fa-plus"></i>';
					lastInput.appendChild(addButton);
				}
			}
		}

		function collectImageUrls() {
			const container = document.getElementById('roomImagesContainer');
			const inputs = container.querySelectorAll('input[type="url"]');
			const urls = [];
			
			inputs.forEach(input => {
				const url = input.value.trim();
				if (url && isValidUrl(url)) {
					urls.push(url);
				}
			});
			
			return urls;
		}

		function validateImageUrl(input) {
			const url = input.value.trim();
			
			if (!url) {
				input.classList.remove('error', 'success');
				return;
			}
			
			if (isValidUrl(url)) {
				input.classList.remove('error');
				input.classList.add('success');
			} else {
				input.classList.remove('success');
				input.classList.add('error');
			}
		}

		function isValidUrl(string) {
			try {
				new URL(string);
				return true;
			} catch (_) {
				return false;
			}
		}

		// =================== Filter Modal Functions ===================

		function openFilterModal() {
			const modal = document.getElementById('filterModal');
			
			// Load current filter values
			document.getElementById('filterSearch').value = currentFilter;
			document.getElementById('filterSortField').value = currentSortField;
			document.getElementById('filterSortDirection').value = currentSortDirection;
			
			modal.style.display = 'block';
			document.body.style.overflow = 'hidden';
		}

		function closeFilterModal() {
			const modal = document.getElementById('filterModal');
			modal.style.display = 'none';
			document.body.style.overflow = 'auto';
		}

		function applyFilter() {
			currentFilter = document.getElementById('filterSearch').value.trim();
			currentPage = 1; // Reset to first page
			
			const activeSection = document.querySelector('.page-section.active');
			
			if (activeSection && activeSection.id === 'rooms-section') {
				loadRoomsTable();
			} else if (activeSection && activeSection.id === 'buildings-section') {
				loadBuildingsTable();
			}
		}

		function applySort() {
			currentSortField = document.getElementById('filterSortField').value;
			currentSortDirection = document.getElementById('filterSortDirection').value;
			currentPage = 1; // Reset to first page
			
			const activeSection = document.querySelector('.page-section.active');
			
			if (activeSection && activeSection.id === 'rooms-section') {
				loadRoomsTable();
			} else if (activeSection && activeSection.id === 'buildings-section') {
				loadBuildingsTable();
			}
		}

		function clearFilter() {
			currentFilter = '';
			currentSortField = '';
			currentSortDirection = 'asc';
			currentPage = 1;
			
			document.getElementById('filterSearch').value = '';
			document.getElementById('filterSortField').value = '';
			document.getElementById('filterSortDirection').value = 'asc';
			
			const activeSection = document.querySelector('.page-section.active');
			
			if (activeSection && activeSection.id === 'rooms-section') {
				loadRoomsTable();
			} else if (activeSection && activeSection.id === 'buildings-section') {
				loadBuildingsTable();
			}
		}

		// =================== Update CRUD Button Functions ===================

		function editBuilding(code) {
			openBuildingModal(code);
		}

		function editRoom(code) {
			openRoomModal(code);
		}

		// =================== Google Sheets Sync Functions ===================

		// 🔧 แก้ไข 5: ปรับฟังก์ชัน syncBuildingToSheets() ให้ส่งฟิลด์ครบ (ยืนยันว่ามี year, status, rooms)
		async function syncBuildingToSheets(buildingData, isBatch = false) {
			if (!sheetsConfig.connected || !sheetsConfig.url) {
				const error = 'ไม่ได้เชื่อมต่อ Google Sheets';
				console.warn('⚠️ Sync skipped:', error);
				if (!isBatch) showNotification(`⚠️ ${error}`, 'warning');
				return false;
			}
			
			try {
				const params = new URLSearchParams();
				params.append('action', 'addData');
				params.append('sheet', sheetsConfig.buildingsSheet);
				params.append('code', buildingData.code);
				params.append('name', buildingData.name);
				params.append('floors', buildingData.floors);
				// 🔧 ยืนยัน: ฟิลด์เหล่านี้มีใน Google Sheets แล้ว
				params.append('year', buildingData.year || new Date().getFullYear());
				params.append('description', buildingData.description || '');
				params.append('rooms', buildingData.rooms || 0);
				params.append('status', buildingData.status || 'active');
				params.append('created', buildingData.created);
				params.append('updated', buildingData.updated);

				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});

				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}

				const result = await response.json();
				
				if (result.success) {
					if (!isBatch) {
						showNotification(`✅ อาคาร ${buildingData.name} ซิงค์ไปยัง Google Sheets แล้ว`, 'success');
						addSyncHistoryItem(`📤 ซิงค์อาคาร ${buildingData.name}`, 'success');
					}
					return true;
				} else {
					throw new Error(result.error || 'Unknown sync error');
				}

			} catch (error) {
				console.error('❌ Building sync error:', error);
				if (!isBatch) {
					showNotification(`❌ ไม่สามารถซิงค์อาคาร ${buildingData.name}: ${error.message}`, 'error');
					addSyncHistoryItem(`❌ ซิงค์อาคาร ${buildingData.name} ล้มเหลว`, 'error');
				}
				return false;
			}
		}
		
		// 🔧 แก้ไข 8: เพิ่มฟังก์ชัน forceEnableAutoSync() สำหรับ manual activation
		function forceEnableAutoSync() {
			sheetsConfig.autoSync = true;
			localStorage.setItem('sheetsConfig', JSON.stringify(sheetsConfig));
			
			// Update UI checkbox if exists
			const autoSyncCheckbox = document.getElementById('autoSyncEnabled');
			if (autoSyncCheckbox) {
				autoSyncCheckbox.checked = true;
			}
			
			showNotification('✅ เปิด Auto-sync แล้ว', 'success');
			console.log('✅ Auto-sync force enabled');
		}
		
		// 🔧 แก้ไข 9: เพิ่มการตรวจสอบ Auto-sync ใน initialization
		document.addEventListener('DOMContentLoaded', function() {
			// ตรวจสอบและเปิด autoSync
			setTimeout(() => {
				ensureAutoSyncEnabled();
				
				// แสดงสถานะ Auto-sync
				console.log('🔄 Auto-sync status:', sheetsConfig.autoSync);
				console.log('🔗 Sheets connected:', sheetsConfig.connected);
			}, 1000);
		});

		// 🔧 แก้ไข 1: ปรับฟังก์ชัน syncRoomToSheets() ให้ใช้ image_urls
		async function syncRoomToSheets(roomData, isBatch = false) {
			if (!sheetsConfig.connected || !sheetsConfig.url) {
				const error = 'ไม่ได้เชื่อมต่อ Google Sheets';
				console.warn('⚠️ Sync skipped:', error);
				if (!isBatch) showNotification(`⚠️ ${error}`, 'warning');
				return false;
			}
			
			try {
				const params = new URLSearchParams();
				params.append('action', 'addData');
				params.append('sheet', sheetsConfig.roomsSheet);
				params.append('code', roomData.code);
				params.append('name', roomData.name);
				params.append('building', roomData.building);
				params.append('floor', roomData.floor);
				params.append('type', roomData.type || '');
				params.append('description', roomData.description || '');
				params.append('status', roomData.status);
				params.append('x', roomData.x || '');
				params.append('y', roomData.y || '');
				// 🔧 แก้ไข: ใช้ image_urls แทน images
				params.append('image_urls', JSON.stringify(roomData.images || []));
				params.append('created', roomData.created);
				params.append('updated', roomData.updated);

		        console.log(`params.toString: "${params.toString()}"`);
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
 
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}

				const result = await response.json();
				
				if (result.success) {
					if (!isBatch) {
						showNotification(`✅ ห้อง ${roomData.name} ซิงค์ไปยัง Google Sheets แล้ว`, 'success');
						addSyncHistoryItem(`📤 ซิงค์ห้อง ${roomData.name}`, 'success');
					}
					return true;
				} else {
					throw new Error(result.error || 'Unknown sync error');
				}

			} catch (error) {
				console.error('❌ Room sync error:', error);
				if (!isBatch) {
					showNotification(`❌ ไม่สามารถซิงค์ห้อง ${roomData.name}: ${error.message}`, 'error');
					addSyncHistoryItem(`❌ ซิงค์ห้อง ${roomData.name} ล้มเหลว`, 'error');
				}
				return false;
			}
		}

		async function deleteBuildingFromSheets(code) {
			if (!sheetsConfig.connected || !sheetsConfig.url) {
				return; // Skip if not connected
			}
			
			try {
				const params = new URLSearchParams();
				params.append('action', 'deleteData');
				params.append('sheet', sheetsConfig.buildingsSheet);
				params.append('id', code);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/x-www-form-urlencoded',
					},
					body: params.toString()
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.success) {
						addSyncHistoryItem(`🗑️ ลบอาคาร ${code} จาก Google Sheets สำเร็จ`, 'success');
					}
				}
				
			} catch (error) {
				console.error('Delete building from sheets error:', error);
				addSyncHistoryItem(`❌ ลบอาคาร ${code} จาก Google Sheets ล้มเหลว`, 'error');
			}
		}

		async function deleteRoomFromSheets(code) {
			if (!sheetsConfig.connected || !sheetsConfig.url) {
				return; // Skip if not connected
			}
			
			try {
				const params = new URLSearchParams();
				params.append('action', 'deleteData');
				params.append('sheet', sheetsConfig.roomsSheet);
				params.append('id', code);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/x-www-form-urlencoded',
					},
					body: params.toString()
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.success) {
						addSyncHistoryItem(`🗑️ ลบห้อง ${code} จาก Google Sheets สำเร็จ`, 'success');
					}
				}
				
			} catch (error) {
				console.error('Delete room from sheets error:', error);
				addSyncHistoryItem(`❌ ลบห้อง ${code} จาก Google Sheets ล้มเหลว`, 'error');
			}
		}
		
		// 🔧 แก้ไข 1: เพิ่มฟังก์ชันตรวจสอบ valid image URL
		function isValidImageUrl(url) {
			if (!url || typeof url !== 'string') return false;
			
			const trimmedUrl = url.trim();
			if (trimmedUrl === '') return false;
			
			// ⚠️ กรองค่า placeholder ออก
			const invalidValues = ['available', 'none', 'null', 'undefined', 'error', 'pending'];
			if (invalidValues.includes(trimmedUrl.toLowerCase())) {
				console.log(`🚫 Invalid placeholder detected: "${trimmedUrl}"`);
				return false;
			}
			
			// ตรวจสอบรูปแบบ URL ที่ถูกต้อง
			if (trimmedUrl.startsWith('data:image/')) return true;
			if (trimmedUrl.startsWith('http://') || trimmedUrl.startsWith('https://')) return true;
			
			// สำหรับ Web Server - relative paths
			if (Environment.isWebServer && (trimmedUrl.startsWith('./') || trimmedUrl.startsWith('../'))) {
				return true;
			}
			
			// สำหรับ Local PC - ต้องเป็น absolute URLs หรือ data URLs เท่านั้น
			if (Environment.isLocalPC) {
				return false; // Local PC ไม่รองรับ relative paths
			}
			
			return false;
		}


		// =================== Keyboard Shortcuts ===================

		document.addEventListener('keydown', function(e) {
			// Close modals with Escape key
			if (e.key === 'Escape') {
				const modals = ['buildingModal', 'roomModal', 'filterModal'];
				modals.forEach(modalId => {
					const modal = document.getElementById(modalId);
					if (modal && modal.style.display === 'block') {
						modal.style.display = 'none';
						document.body.style.overflow = 'auto';
						
						// Reset forms
						if (modalId === 'buildingModal') {
							document.getElementById('buildingForm').reset();
						} else if (modalId === 'roomModal') {
							document.getElementById('roomForm').reset();
						}
						
						isEditMode = false;
						editingItemId = null;
					}
				});
			}
			
			// Quick add shortcuts (Ctrl/Cmd + specific keys)
			if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey) {
				const activeSection = document.querySelector('.page-section.active');
				
				if (e.key === 'b' && activeSection && activeSection.id === 'buildings-section') {
					e.preventDefault();
					openBuildingModal();
				}
				
				if (e.key === 'r' && activeSection && activeSection.id === 'rooms-section') {
					e.preventDefault();
					openRoomModal();
				}
				
				if (e.key === 'f') {
					e.preventDefault();
					openFilterModal();
				}
			}
		});

		// =================== Initialize Modal Module ===================

		function initializeModalModule() {
			console.log('🔧 Initializing Modal Module...');
			try {
				// ตรวจสอบ modal elements
				const modals = document.querySelectorAll('.modal');
				console.log(`📋 Found ${modals.length} modals`);
				
				console.log('✅ Modal Module initialized');
				return true;
			} catch (error) {
				console.error('❌ Error initializing Modal module:', error);
				return false;
			}
		}	

		// =================== Enhanced Navigation Functions ===================

		// อัปเดต showSection function ให้รองรับเมนูใหม่
		function showSection(sectionId) {
		 
			console.log(`📍 Switching to section: ${sectionId}`);
			
			// Hide all sections
			document.querySelectorAll('.page-section').forEach(section => {
				section.classList.remove('active');
			});

			// Remove active class from all menu items
			document.querySelectorAll('.menu-item, .mobile-nav-item').forEach(item => {
				item.classList.remove('active');
			});

			// Show target section
			const targetSection = document.getElementById(sectionId + '-section');
			if (targetSection) {
				targetSection.classList.add('active');
				
				// Initialize section-specific modules
				if (sectionId === 'maps') {
					initializeMapsModule();
				} else if (sectionId === 'deployment') {
					initializeDeploymentModule();
				} else if (sectionId === 'sheets') {
					initializeEnhancedSheetsModule();
				}
			}

			// Add active class to clicked menu item
			const menuSelectors = [
				`.menu-item[onclick="showSection('${sectionId}')"]`,
				`.mobile-nav-item[onclick="showSection('${sectionId}')"]`
			];
			
			menuSelectors.forEach(selector => {
				const menuItem = document.querySelector(selector);
				if (menuItem) {
					menuItem.classList.add('active');
				}
			});

			// Update page title
			const titles = {
				'dashboard': 'แดชบอร์ด',
				'buildings': 'จัดการอาคาร',
				'rooms': 'จัดการห้อง',
				'maps': 'จัดการแผนที่',
				'sheets': 'Google Sheets',
				'deployment': 'คู่มือ Deploy'
			};

			const pageTitle = document.getElementById('pageTitle');
			if (pageTitle && titles[sectionId]) {
				pageTitle.textContent = titles[sectionId];
			}

			// Close mobile sidebar and more menu if open
			if (window.innerWidth <= 768) {
				const sidebar = document.getElementById('sidebar');
				if (sidebar) {
					sidebar.classList.remove('show');
				}
				closeMobileMoreMenu();
			}
			
			// Reset current page for tables
			currentPage = 1;
			currentFilter = '';
			
			// Load appropriate table
			if (sectionId === 'buildings') {
				loadBuildingsTable();
			} else if (sectionId === 'rooms') {
				loadRoomsTable();
			}
		}

		// =================== Mobile More Menu Functions ===================

		function openMoreMenu() {
			const menu = document.getElementById('mobileMoreMenu');
			if (menu.style.display === 'none' || !menu.style.display) {
				menu.style.display = 'block';
				
				// Close menu when clicking outside
				setTimeout(() => {
					document.addEventListener('click', closeMoreMenuOnOutsideClick);
				}, 100);
			} else {
				closeMobileMoreMenu();
			}
		}

		function closeMobileMoreMenu() {
			const menu = document.getElementById('mobileMoreMenu');
			menu.style.display = 'none';
			document.removeEventListener('click', closeMoreMenuOnOutsideClick);
		}

		function closeMoreMenuOnOutsideClick(e) {
			const menu = document.getElementById('mobileMoreMenu');
			const moreButton = document.querySelector('.mobile-nav-item[onclick="openMoreMenu()"]');
			
			if (!menu.contains(e.target) && !moreButton.contains(e.target)) {
				closeMobileMoreMenu();
			}
		}

		// =================== Quick Search Functions ===================

		let searchTimeout = null;

		function quickSearchBuildings(query) {
			// Debounce search
			clearTimeout(searchTimeout);
			searchTimeout = setTimeout(() => {
				currentFilter = query.trim();
				currentPage = 1;
				loadBuildingsTable();
				
				if (query.trim()) {
					showNotification(`🔍 ค้นหา: "${query}"`, 'info');
				}
			}, 300);
		}

		function quickSearchRooms(query) {
			// Debounce search
			clearTimeout(searchTimeout);
			searchTimeout = setTimeout(() => {
				currentFilter = query.trim();
				currentPage = 1;
				loadRoomsTable();
				
				if (query.trim()) {
					showNotification(`🔍 ค้นหา: "${query}"`, 'info');
				}
			}, 300);
		}

		// =================== Enhanced Table Management ===================

		// อัปเดต loadBuildingsTable ให้มี search highlight
		function loadBuildingsTableEnhanced() {
			const tbody = document.getElementById('buildingsTableBody');
			if (!tbody) return;
			
			let buildings = Object.values(buildingsData);
			
			// Apply filter
			if (currentFilter) {
				buildings = buildings.filter(building => 
					building.name.toLowerCase().includes(currentFilter.toLowerCase()) ||
					building.code.toLowerCase().includes(currentFilter.toLowerCase()) ||
					(building.description && building.description.toLowerCase().includes(currentFilter.toLowerCase()))
				);
			}
			
			// Apply sorting
			if (currentSortField) {
				buildings.sort((a, b) => {
					let aVal = a[currentSortField] || '';
					let bVal = b[currentSortField] || '';
					
					if (typeof aVal === 'string') {
						aVal = aVal.toLowerCase();
						bVal = bVal.toLowerCase();
					}
					
					if (currentSortDirection === 'asc') {
						return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
					} else {
						return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
					}
				});
			}
			
			totalItems = buildings.length;
			
			// Apply pagination
			const paginatedBuildings = paginateData(buildings, currentPage, itemsPerPage);
			
			if (paginatedBuildings.length === 0) {
				tbody.innerHTML = `
					<tr>
						<td colspan="6" style="text-align: center; padding: 40px; color: var(--text-secondary);">
							<i class="fas fa-building" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
							<p>${buildings.length === 0 ? 'ยังไม่มีข้อมูลอาคาร' : 'ไม่พบข้อมูลที่ตรงกับการค้นหา'}</p>
							${currentFilter ? `<p style="font-size: 14px; color: var(--info-color);">คำค้นหา: "${currentFilter}"</p>` : ''}
						</td>
					</tr>
				`;
			} else {
				tbody.innerHTML = paginatedBuildings.map(building => `
					<tr>
						<td><strong>${highlightSearchTerm(building.code, currentFilter)}</strong></td>
						<td>${highlightSearchTerm(building.name, currentFilter)}</td>
						<td>${building.floors} ชั้น</td>
						<td>${building.rooms || 0} ห้อง</td>
						<td>
							<span class="status-indicator ${building.status === 'active' ? 'status-active' : 'status-inactive'}">
								${building.status === 'active' ? 'ใช้งาน' : 'ไม่ใช้งาน'}
							</span>
						</td>
						<td>
							<button class="btn btn-sm btn-info" onclick="editBuilding('${building.code}')" title="แก้ไข">
								<i class="fas fa-edit"></i>
							</button>
							<button class="btn btn-sm btn-danger" onclick="confirmDeleteBuilding('${building.code}')" title="ลบ">
								<i class="fas fa-trash"></i>
							</button>
						</td>
					</tr>
				`).join('');
			}
			
			// Update pagination controls
			createPaginationControls(totalItems, currentPage, itemsPerPage, 'buildingsPagination');
			
			// Update search input if exists
			const searchInput = document.getElementById('buildingQuickSearch');
			if (searchInput && searchInput.value !== currentFilter) {
				searchInput.value = currentFilter;
			}
		}

		// อัปเดต loadRoomsTable ให้มี search highlight
		function loadRoomsTableEnhanced() {
			const tbody = document.getElementById('roomsTableBody');
			if (!tbody) return;
			
			let rooms = Object.values(roomsData);
			
			// Apply filter
			if (currentFilter) {
				rooms = rooms.filter(room => 
					room.name.toLowerCase().includes(currentFilter.toLowerCase()) ||
					room.code.toLowerCase().includes(currentFilter.toLowerCase()) ||
					(room.type && room.type.toLowerCase().includes(currentFilter.toLowerCase())) ||
					(room.building && room.building.toLowerCase().includes(currentFilter.toLowerCase())) ||
					(room.description && room.description.toLowerCase().includes(currentFilter.toLowerCase()))
				);
			}
			
			// Apply sorting
			if (currentSortField) {
				rooms.sort((a, b) => {
					let aVal = a[currentSortField] || '';
					let bVal = b[currentSortField] || '';
					
					if (typeof aVal === 'string') {
						aVal = aVal.toLowerCase();
						bVal = bVal.toLowerCase();
					}
					
					if (currentSortDirection === 'asc') {
						return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
					} else {
						return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
					}
				});
			}
			
			totalItems = rooms.length;
			
			// Apply pagination
			const paginatedRooms = paginateData(rooms, currentPage, itemsPerPage);
			
			if (paginatedRooms.length === 0) {
				tbody.innerHTML = `
					<tr>
						<td colspan="7" style="text-align: center; padding: 40px; color: var(--text-secondary);">
							<i class="fas fa-door-open" style="font-size: 32px; margin-bottom: 10px; opacity: 0.3;"></i>
							<p>${rooms.length === 0 ? 'ยังไม่มีข้อมูลห้อง' : 'ไม่พบข้อมูลที่ตรงกับการค้นหา'}</p>
							${currentFilter ? `<p style="font-size: 14px; color: var(--info-color);">คำค้นหา: "${currentFilter}"</p>` : ''}
						</td>
					</tr>
				`;
			} else {
				tbody.innerHTML = paginatedRooms.map(room => {
					const building = buildingsData[room.building];
					return `
						<tr>
							<td><strong>${highlightSearchTerm(room.code, currentFilter)}</strong></td>
							<td>${highlightSearchTerm(room.name, currentFilter)}</td>
							<td>${building ? highlightSearchTerm(building.name, currentFilter) : room.building}</td>
							<td>ชั้น ${room.floor || 'N/A'}</td>
							<td>
								<span style="background: rgba(102, 126, 234, 0.1); padding: 4px 8px; border-radius: 12px; font-size: 11px; color: var(--primary-color);">
									${highlightSearchTerm(room.type || 'ห้องเรียน', currentFilter)}
								</span>
							</td>
							<td>
								<span class="status-indicator ${getStatusClass(room.status)}">
									${getStatusText(room.status)}
								</span>
							</td>
							<td>
								<button class="btn btn-sm btn-info" onclick="editRoom('${room.code}')" title="แก้ไข">
									<i class="fas fa-edit"></i>
								</button>
								<button class="btn btn-sm btn-danger" onclick="confirmDeleteRoom('${room.code}')" title="ลบ">
									<i class="fas fa-trash"></i>
								</button>
							</td>
						</tr>
					`;
				}).join('');
			}
			
			// Update pagination controls
			createPaginationControls(totalItems, currentPage, itemsPerPage, 'roomsPagination');
			
			// Update search input if exists
			const searchInput = document.getElementById('roomQuickSearch');
			if (searchInput && searchInput.value !== currentFilter) {
				searchInput.value = currentFilter;
			}
		}

		// =================== Search Highlighting Function ===================

		function highlightSearchTerm(text, searchTerm) {
			if (!searchTerm || !text) return text;
			
			const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
			return text.replace(regex, '<mark style="background: #ffeb3b; padding: 1px 2px; border-radius: 2px;">$1</mark>');
		}

		function escapeRegExp(string) {
			return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
		}

		// =================== Enhanced Keyboard Shortcuts ===================

		document.addEventListener('keydown', function(e) {
			// Close modals with Escape key
			if (e.key === 'Escape') {
				const modals = ['buildingModal', 'roomModal', 'filterModal'];
				modals.forEach(modalId => {
					const modal = document.getElementById(modalId);
					if (modal && modal.style.display === 'block') {
						modal.style.display = 'none';
						document.body.style.overflow = 'auto';
						
						// Reset forms
						if (modalId === 'buildingModal') {
							document.getElementById('buildingForm').reset();
						} else if (modalId === 'roomModal') {
							document.getElementById('roomForm').reset();
						}
						
						isEditMode = false;
						editingItemId = null;
					}
				});
				
				// Close mobile more menu
				closeMobileMoreMenu();
			}
			
			// Section navigation shortcuts (Alt + number)
			if (e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
				const sectionKeys = {
					'1': 'dashboard',
					'2': 'buildings', 
					'3': 'rooms',
					'4': 'maps',
					'5': 'sheets',
					'6': 'deployment'
				};
				
				if (sectionKeys[e.key]) {
					e.preventDefault();
					showSection(sectionKeys[e.key]);
				}
			}
			
			// Quick add shortcuts (Ctrl/Cmd + specific keys)
			if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey) {
				const activeSection = document.querySelector('.page-section.active');
				
				if (e.key === 'b' && activeSection && activeSection.id === 'buildings-section') {
					e.preventDefault();
					openBuildingModal();
				}
				
				if (e.key === 'r' && activeSection && activeSection.id === 'rooms-section') {
					e.preventDefault();
					openRoomModal();
				}
				
				if (e.key === 'f') {
					e.preventDefault();
					openFilterModal();
				}
				
				if (e.key === 's') {
					e.preventDefault();
					sequentialLoadData();
				}
				
				if (e.key === '/') {
					e.preventDefault();
					// Focus on search input
					const activeSection = document.querySelector('.page-section.active');
					if (activeSection && activeSection.id === 'buildings-section') {
						const searchInput = document.getElementById('buildingQuickSearch');
						if (searchInput) searchInput.focus();
					} else if (activeSection && activeSection.id === 'rooms-section') {
						const searchInput = document.getElementById('roomQuickSearch');
						if (searchInput) searchInput.focus();
					}
				}
			}
		});

		// =================== Update Original Functions ===================

		// แทนที่ loadBuildingsTable เดิม
		function loadBuildingsTable() {
			loadBuildingsTableEnhanced();
		}

		// แทนที่ loadRoomsTable เดิม  
		function loadRoomsTable() {
			loadRoomsTableEnhanced();
		}

		// =================== Search and Filter State Management ===================

		function clearAllFilters() {
			currentFilter = '';
			currentSortField = '';
			currentSortDirection = 'asc';
			currentPage = 1;
			
			// Clear search inputs
			const buildingSearch = document.getElementById('buildingQuickSearch');
			const roomSearch = document.getElementById('roomQuickSearch');
			
			if (buildingSearch) buildingSearch.value = '';
			if (roomSearch) roomSearch.value = '';
			
			// Reload current table
			const activeSection = document.querySelector('.page-section.active');
			if (activeSection && activeSection.id === 'buildings-section') {
				loadBuildingsTable();
			} else if (activeSection && activeSection.id === 'rooms-section') {
				loadRoomsTable();
			}
			
			showNotification('🧹 ล้างตัวกรองทั้งหมดแล้ว', 'info');
		}

		// ✅ เพิ่มฟังก์ชันตรวจสอบว่าฟังก์ชันมีอยู่หรือไม่
		function safeCallFunction(functionName, ...args) {
			try {
				if (typeof window[functionName] === 'function') {
					return window[functionName](...args);
				} else {
					console.warn(`⚠️ Function ${functionName} not found, skipping...`);
					return true; // ส่งค่า success เพื่อไม่ให้หยุดการทำงาน
				}
			} catch (error) {
				console.error(`❌ Error calling ${functionName}:`, error);
				return false;
			}
		}

		// ✅ เพิ่มฟังก์ชันที่อาจหายไป
		function initializeEnhancedNavigationModule() {
			console.log('🧭 Initializing Enhanced Navigation Module...');
			try {
				// ตรวจสอบ navigation elements
				const sidebar = document.getElementById('sidebar');
				const menuItems = document.querySelectorAll('.menu-item');
				
				if (sidebar && menuItems.length > 0) {
					console.log('✅ Navigation elements found');
				}
				
				console.log('✅ Enhanced Navigation Module initialized');
				return true;
			} catch (error) {
				console.error('❌ Error initializing Enhanced Navigation module:', error);
				return false;
			}
		}


		// =================== Show Keyboard Shortcuts Help ===================

		function showKeyboardShortcuts() {
			const shortcuts = [
				{ key: 'Alt + 1-6', desc: 'เปลี่ยนหน้า (แดชบอร์ด, อาคาร, ห้อง, แผนที่, Sheets, Deploy)' },
				{ key: 'Ctrl + B', desc: 'เพิ่มอาคารใหม่ (ในหน้าจัดการอาคาร)' },
				{ key: 'Ctrl + R', desc: 'เพิ่มห้องใหม่ (ในหน้าจัดการห้อง)' },
				{ key: 'Ctrl + F', desc: 'เปิดตัวกรองขั้นสูง' },
				{ key: 'Ctrl + S', desc: 'โหลดข้อมูลจาก Google Sheets' },
				{ key: 'Ctrl + /', desc: 'โฟกัสช่องค้นหา' },
				{ key: 'Escape', desc: 'ปิด Modal หรือล้างการค้นหา' }
			];
			
			const modal = document.createElement('div');
			modal.style.cssText = `
				position: fixed; top: 0; left: 0; right: 0; bottom: 0;
				background: rgba(0,0,0,0.8); z-index: 9999;
				display: flex; align-items: center; justify-content: center;
				padding: 20px;
			`;
			
			modal.innerHTML = `
				<div style="background: white; border-radius: 15px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
						<h3 style="color: var(--primary-color); margin: 0;">⌨️ Keyboard Shortcuts</h3>
						<button onclick="this.closest('div').parentElement.remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">×</button>
					</div>
					
					<div style="grid-template-columns: auto 1fr; gap: 15px; display: grid; align-items: center;">
						${shortcuts.map(shortcut => `
							<div style="background: #f1f3f4; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-weight: 600; text-align: center; font-size: 14px;">
								${shortcut.key}
							</div>
							<div style="font-size: 14px;">
								${shortcut.desc}
							</div>
						`).join('')}
					</div>
					
					<div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid var(--border-color); text-align: center;">
						<button onclick="this.closest('div').parentElement.remove()" class="btn btn-primary">
							<i class="fas fa-check"></i> รับทราบ
						</button>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
		}

		// Add keyboard shortcuts help to header
		function addKeyboardShortcutsButton() {
			const headerActions = document.querySelector('.header-actions');
			if (headerActions) {
				const shortcutsBtn = document.createElement('button');
				shortcutsBtn.className = 'header-btn secondary';
				shortcutsBtn.innerHTML = '<i class="fas fa-keyboard"></i><span>Shortcuts</span>';
				shortcutsBtn.onclick = showKeyboardShortcuts;
				shortcutsBtn.title = 'แสดง Keyboard Shortcuts (Alt + H)';
				
				headerActions.insertBefore(shortcutsBtn, headerActions.lastElementChild);
			}
		}
		
		// =================== Enhanced Sequential Loader ===================

		// อัปเดต SequentialLoader ให้รวม Maps module
		SequentialLoader.prototype.updateUIStep = async function() {
			// Simulate UI update delay
			await new Promise(resolve => setTimeout(resolve, 500));
			
			// Update dashboard stats
			updateDashboardStats();
			
			// Update tables
			loadBuildingsTable();
			loadRoomsTable();
			
			// Initialize Maps module
			initializeMapsModule();
			
			// Update connection status
			updateConnectionStatus();
			
			console.log('✅ UI updated successfully with all modules');
			return true;
		};
		
		// เรียกใช้ functions เหล่านี้เมื่อ DOM โหลดเสร็จ
		document.addEventListener('DOMContentLoaded', function() {
			// Initialize debug mode from localStorage
			const savedDebugMode = localStorage.getItem('debugMode') === 'true';
			debugMode = savedDebugMode;
			
			// Initialize enhanced sheets config
			setTimeout(() => {
				loadEnhancedSheetsConfig();
			}, 1000);
			
			console.log('✅ Missing functions initialized');
		});


		// =================== Responsive Handlers ===================

		function setupResponsiveHandlers() {
			console.log('📱 Setting up responsive handlers...');
			try {
				// ตั้งค่า responsive handlers
				let resizeTimeout;
				window.addEventListener('resize', function() {
					clearTimeout(resizeTimeout);
					resizeTimeout = setTimeout(() => {
						console.log('📐 Window resized');
					}, 250);
				});
				
				console.log('✅ Responsive handlers setup complete');
				return true;
			} catch (error) {
				console.error('❌ Error setting up responsive handlers:', error);
				return false;
			}
		}

		function handleWindowResize() {
			const width = window.innerWidth;
			
			if (width > 768) {
				const sidebar = document.getElementById('sidebar');
				if (sidebar) {
					sidebar.classList.remove('show');
				}
			}
		}

		function setupTouchHandlers() {
			// Add touch feedback to buttons
			const buttons = document.querySelectorAll('.btn, .menu-item, .mobile-nav-item');
			
			buttons.forEach(button => {
				button.addEventListener('touchstart', function() {
					this.style.transform = 'scale(0.95)';
				});
				
				button.addEventListener('touchend', function() {
					this.style.transform = 'scale(1)';
				});
				
				button.addEventListener('touchcancel', function() {
					this.style.transform = 'scale(1)';
				});
			});
		}

		function adjustTableResponsiveness() {
			const tables = document.querySelectorAll('.data-table');
			
			tables.forEach(table => {
				const container = table.parentElement;
				if (window.innerWidth <= 768) {
					container.style.overflowX = 'auto';
					table.style.minWidth = '600px';
				} else {
					container.style.overflowX = 'visible';
					table.style.minWidth = 'auto';
				}
			});
		}

		// =================== Welcome Message ===================

		function showWelcomeMessage() {
			const hasSeenWelcome = localStorage.getItem('adminWelcomeSeen');
			
			if (!hasSeenWelcome) {
				const modal = document.createElement('div');
				modal.style.cssText = `
					position: fixed; top: 0; left: 0; right: 0; bottom: 0;
					background: rgba(0,0,0,0.8); z-index: 9999;
					display: flex; align-items: center; justify-content: center;
					padding: 20px; backdrop-filter: blur(10px);
				`;
				
				modal.innerHTML = `
					<div style="background: white; border-radius: 20px; padding: 40px; max-width: 500px; text-align: center; box-shadow: 0 25px 50px rgba(0,0,0,0.3);">
						<div style="font-size: 64px; margin-bottom: 20px;">🎉</div>
						
						<h2 style="color: var(--primary-color); margin-bottom: 15px;">
							ยินดีต้อนรับสู่ Admin Panel V1.3 <br>Enhanced: Dikstra Admin-Index Integrtaion Bridge!
						</h2>
						
						<p style="color: var(--text-secondary); margin-bottom: 25px; line-height: 1.6;">
							ระบบใหม่พร้อมฟีเจอร์ครบครัน: CRUD, Pagination, Maps Management, Deploy Guide และ Enhanced Google Sheets Integration
						</p>
						
						<div style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin-bottom: 25px;">
							<h4 style="color: var(--info-color); margin-bottom: 15px;">
								<i class="fas fa-lightbulb"></i> เคล็ดลับการใช้งาน
							</h4>
							<ul style="text-align: left; margin: 0; padding-left: 20px; color: var(--text-secondary);">
								<li>ใช้ <kbd>Alt + 1-6</kbd> สำหรับเปลี่ยนหน้า</li>
								<li>ใช้ <kbd>Ctrl + /</kbd> สำหรับค้นหา</li>
								<li>ใช้ <kbd>Ctrl + B/R</kbd> สำหรับเพิ่มข้อมูล</li>
								<li>คลิกปุ่ม <i class="fas fa-keyboard"></i> เพื่อดู shortcuts ทั้งหมด</li>
							</ul>
						</div>
						
						<div style="display: flex; gap: 10px; justify-content: center;">
							<button onclick="closeWelcomeMessage(false)" class="btn btn-secondary">
								ไว้ทีหลัง
							</button>
							<button onclick="closeWelcomeMessage(true)" class="btn btn-primary">
								<i class="fas fa-rocket"></i> เริ่มใช้งาน
							</button>
						</div>
					</div>
				`;
				
				document.body.appendChild(modal);
				
				// Auto-close after 30 seconds
				setTimeout(() => {
					if (document.body.contains(modal)) {
						closeWelcomeMessage(true);
					}
				}, 30000);
			}
		}

		function closeWelcomeMessage(dontShowAgain = false) {
			const modal = document.querySelector('div[style*="position: fixed"][style*="backdrop-filter"]');
			if (modal) {
				modal.remove();
			}
			
			if (dontShowAgain) {
				localStorage.setItem('adminWelcomeSeen', 'true');
			}
		}

		// =================== System Health Check ===================

		function performSystemHealthCheck() {
			const healthStatus = {
				modules: {
					navigation: !!document.getElementById('sidebar'),
					crud: typeof createBuilding === 'function',
					modals: !!document.getElementById('buildingModal'),
					maps: typeof initializeMapsModule === 'function',
					deployment: typeof initializeDeploymentModule === 'function',
					sheets: typeof initializeEnhancedSheetsModule === 'function'
				},
				data: {
					buildings: Object.keys(buildingsData || {}).length,
					rooms: Object.keys(roomsData || {}).length,
					sheetsConnected: sheetsConfig?.connected || false
				},
				ui: {
					responsive: window.innerWidth > 0,
					localStorage: typeof Storage !== 'undefined',
					fetch: typeof fetch === 'function'
				}
			};
			
			const allModulesOk = Object.values(healthStatus.modules).every(status => status);
			const allUIFeaturesOk = Object.values(healthStatus.ui).every(status => status);
			
			console.log('🏥 System Health Check:', healthStatus);
			
			if (allModulesOk && allUIFeaturesOk) {
				console.log('✅ System health: EXCELLENT');
				return { status: 'excellent', details: healthStatus };
			} else if (allUIFeaturesOk) {
				console.log('⚠️ System health: GOOD (some modules missing)');
				return { status: 'good', details: healthStatus };
			} else {
				console.log('❌ System health: POOR (critical issues)');
				return { status: 'poor', details: healthStatus };
			}
		}

		// =================== Auto-save and Recovery ===================

		function setupAutoSave() {
			console.log('💾 Setting up auto-save...');
			
			// Save state every 30 seconds
			setInterval(() => {
				const state = {
					currentPage,
					currentFilter,
					currentSortField,
					currentSortDirection,
					itemsPerPage,
					lastActive: new Date().toISOString()
				};
				
				localStorage.setItem('adminState', JSON.stringify(state));
			}, 30000);
			
			// Save on page unload
			window.addEventListener('beforeunload', function() {
				const state = {
					currentPage,
					currentFilter,
					currentSortField,
					currentSortDirection,
					itemsPerPage,
					lastActive: new Date().toISOString()
				};
				
				localStorage.setItem('adminState', JSON.stringify(state));
			});
		}

		function recoverState() {
			try {
				const saved = localStorage.getItem('adminState');
				if (saved) {
					const state = JSON.parse(saved);
					
					// Check if state is recent (less than 24 hours old)
					const lastActive = new Date(state.lastActive);
					const now = new Date();
					const hoursDiff = (now - lastActive) / (1000 * 60 * 60);
					
					if (hoursDiff < 24) {
						currentPage = state.currentPage || 1;
						currentFilter = state.currentFilter || '';
						currentSortField = state.currentSortField || '';
						currentSortDirection = state.currentSortDirection || 'asc';
						itemsPerPage = state.itemsPerPage || 20;
						
						console.log('♻️ State recovered from auto-save');
						return true;
					}
				}
			} catch (error) {
				console.warn('⚠️ Could not recover state:', error);
			}
			
			return false;
		}

		// =================== Performance Monitoring ===================

		 

		 
		// =================== Updated Event Handlers ===================

		function setupEventHandlers() {
			console.log('🔗 Setting up enhanced event handlers...');
			
			// Original keyboard shortcuts
			document.addEventListener('keydown', function(e) {
				// Global shortcuts
				if ((e.ctrlKey || e.metaKey) && e.key === 's') {
					e.preventDefault();
					sequentialLoadData();
				}
				
				if (e.altKey && e.key === 'h') {
					e.preventDefault();
					//showKeyboardShortcuts();
				}
			});
			
			// Enhanced mobile handling
			let touchStartY = 0;
			let touchEndY = 0;
			
			document.addEventListener('touchstart', function(e) {
				touchStartY = e.changedTouches[0].screenY;
			});
			
			document.addEventListener('touchend', function(e) {
				touchEndY = e.changedTouches[0].screenY;
				
				// Pull to refresh (swipe down from top)
				if (touchEndY - touchStartY > 100 && window.scrollY === 0) {
					sequentialLoadData();
				}
			});
			
			// Setup auto-save and monitoring
			setupAutoSave();  
		}

		// =================== Updated Main Initialization ===================

		document.addEventListener('DOMContentLoaded', function() {
			console.log('🎯 DOM Content Loaded - Starting initialization...');
			
			// Recover previous state if available
			recoverState();
			
			// Setup enhanced event handlers
			setupEventHandlers();
			
			// Check login status and initialize if logged in
			if (checkLoginStatus()) {
				initializeAdmin();
				
				// Perform health check after initialization
				setTimeout(() => {
					const health = performSystemHealthCheck();
					if (health.status === 'poor') {
						showNotification('⚠️ ระบบมีปัญหา กรุณาโหลดหน้าใหม่', 'warning');
					}
				}, 3000);
			}
		});
		

		// ✅ แก้ไข initializeMapsModule ให้รวมการโหลด Maps
		function initializeMapsModule() {
			console.log('🗺️ Initializing Maps Management Module...');
			
			try {
				// โหลดตาราง Maps
				loadMapsTable();
				
				// เริ่มต้น Image Upload System
				initializeImageUploadSystem();
				
				console.log('✅ Maps Management Module initialized');
			} catch (error) {
				console.error('❌ Error initializing Maps module:', error);
			}
		}
		
		// ✅ ฟังก์ชันเริ่มต้น Image Upload System
		function initializeImageUploadSystem() {
			console.log('🖼️ Initializing Image Upload System...');
			
			// ตรวจสอบความพร้อมของระบบ
			if (!checkSystemReady()) {
				console.error('❌ System not ready for image processing');
				return;
			}
			
			// โหลดการตั้งค่าจาก localStorage
			loadSheetsConfigFromStorage();
			
			// อัพเดทสถานะการเชื่อมต่อ
			updateConnectionStatus();
			
		}
		
		// ✅ แก้ไข: เพิ่มการโหลด Maps เมื่อ login สำเร็จ (แทนที่ initializeAdminWithMaps)
		function enhanceLoginHandling() {
			// เก็บ reference ของฟังก์ชัน handleLogin เดิม
			const originalHandleLogin = window.handleLogin;
			
			// สร้างฟังก์ชัน handleLogin ใหม่ที่รวม Maps loading
			window.handleLogin = function(event) {
				// เรียกฟังก์ชันเดิม
				if (originalHandleLogin) {
					originalHandleLogin.call(this, event);
				} else {
					// หากไม่มีฟังก์ชันเดิม ให้ทำ login พื้นฐาน
					performBasicLogin(event);
				}
				
				// โหลด Maps หลังจาก login สำเร็จ
				setTimeout(() => {
					const isLoggedIn = sessionStorage.getItem('adminLoggedIn') === 'true';
					if (isLoggedIn) {
						console.log('🗺️ Login successful, initializing Maps...');
						
						// โหลด Maps สำหรับการใช้งาน
						setTimeout(() => {
							initializeMapsModule();
						}, 1000);
					}
				}, 500);
			};
		}
		
		// ✅ ฟังก์ชัน login พื้นฐานสำหรับกรณีที่ไม่มี handleLogin เดิม
		function performBasicLogin(event) {
			event.preventDefault();
			
			const username = document.getElementById('loginUsername').value;
			const password = document.getElementById('loginPassword').value;
			const errorDiv = document.getElementById('loginError');
			
			if (username === 'admin' && password === '1234') {
				sessionStorage.setItem('adminLoggedIn', 'true');
				
				document.getElementById('loginContainer').style.display = 'none';
				document.getElementById('adminContainer').style.display = 'flex';
				
				// เรียก initializeAdmin หากมี
				if (typeof initializeAdmin === 'function') {
					setTimeout(() => {
						initializeAdmin();
					}, 100);
				}
				
				console.log('✅ Basic login successful');
			} else {
				errorDiv.style.display = 'block';
				errorDiv.textContent = '❌ Username หรือ Password ไม่ถูกต้อง';
				
				setTimeout(() => {
					errorDiv.style.display = 'none';
				}, 3000);
			}
		}
		
		 
		
		 
		
		// ✅ แก้ไข: เพิ่มการโหลด Maps ใน initializeAdmin
		async function initializeAdminWithMaps() {
			try {
				console.log('🚀 Initializing Complete Admin Panel System with Maps...');
				
				// เรียกฟังก์ชัน initializeAdmin เดิม
				if (typeof initializeAdmin === 'function') {
					await initializeAdmin();
				}
				
				// โหลด Maps เพิ่มเติม
				setTimeout(() => {
					console.log('🗺️ Loading Maps after admin initialization...');
					initializeMapsModule();
				}, 1000);
				
			} catch (error) {
				console.error('❌ Error initializing admin with maps:', error);
			}
		}

		 
		function loadMapSyncHistory() {
			// Maps sync history จะถูกโหลดใน addMapSyncHistoryItem function
			console.log('📊 Map sync history ready');
		}
		
		function addMapSyncHistoryItem(message, type) {
			console.log(`🗺️ Map Sync History: ${message} (${type})`);
			// สำหรับตอนนี้ใช้ console.log ก่อน
		}
		
		
		 
		// 🔧 แก้ไข 5: ปรับ loadFloorplanFromSheets() ให้จัดการ error ดีกว่า
		 async function loadFloorplanFromSheets(buildingCode) {
    if (!buildingCode) {
        showPlaceholderMap();
        return;
    }

    console.log(`🗺️ Loading floorplan for building: ${buildingCode}`);
    
    try {
        // Show loading state
        showMapLoadingState(true);
        
        // 🔧 แก้ไข: ลองใช้แผนที่จาก session storage ก่อน (จาก Maps section)
        const sessionFloorplan = sessionStorage.getItem('temp_floorplan');
        const sessionRealphoto = sessionStorage.getItem('temp_realphoto');
        
        if (sessionFloorplan && isValidImageUrl(sessionFloorplan)) {
            console.log(`💾 Using floorplan from session storage for ${buildingCode}`);
            await loadFloorplanImage(sessionFloorplan, buildingCode);
            return;
        }
        
        // ลองใช้จาก localStorage (จาก Maps section)
        const savedMap = localStorage.getItem('currentMap');
        if (savedMap) {
            try {
                const mapData = JSON.parse(savedMap);
                if (mapData.floorplan && isValidImageUrl(mapData.floorplan)) {
                    console.log(`💾 Using floorplan from localStorage for ${buildingCode}`);
                    await loadFloorplanImage(mapData.floorplan, buildingCode);
                    return;
                } else if (mapData.realphoto && isValidImageUrl(mapData.realphoto)) {
                    console.log(`💾 Using realphoto from localStorage for ${buildingCode}`);
                    await loadFloorplanImage(mapData.realphoto, buildingCode);
                    return;
                }
            } catch (error) {
                console.error('❌ Failed to parse saved map data:', error);
            }
        }
        
        // 🔧 แก้ไข: ไม่ต้องหาแผนที่เฉพาะอาคาร - แสดง placeholder แทน
        console.log(`📋 No initial map available, showing placeholder for ${buildingCode}`);
		await tryLoadFromGoogleSheets(buildingCode);
        showPlaceholderMap();
        
    } catch (error) {
        console.error('❌ Error loading floorplan:', error);
        showPlaceholderMap();
    } finally {
        showMapLoadingState(false);
    }
}

		// 🆕 เพิ่ม: Universal Google Sheets Loader  
		async function tryLoadFromGoogleSheets(buildingCode) {
			try {
				// ตรวจสอบ sheetsConfig
				if (!sheetsConfig.url) {
					console.log('⚠️ No Google Sheets URL configured, loading from storage...');
					loadSheetsConfigFromStorage();
				}
				
				if (!sheetsConfig.url) {
					console.log(`📋 No Google Sheets available, showing placeholder for ${buildingCode}`);
					showPlaceholderMap();
					return;
				}
				
				console.log('🔍 Loading map from Google Sheets...');
				
				const params = new URLSearchParams();
				params.append('action', 'getData');
				params.append('sheet', sheetsConfig.mapImagesSheet);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				
				const result = await response.json();
				
				if (result.success && result.data && result.data.length > 0) {
					const mapData = result.data.find(row => row.id === 'main_map');
					
					if (mapData && (mapData.floorplan || mapData.realphoto)) {
						console.log(`✅ Found map data from Google Sheets for ${buildingCode}`);
						
						// เลือกใช้ floorplan หรือ realphoto
						const mapImage = mapData.floorplan || mapData.realphoto;
						
						if (isValidImageUrl(mapImage)) {
							await loadFloorplanImage(mapImage, buildingCode);
							
							// บันทึกลง localStorage สำหรับครั้งถัดไป
							localStorage.setItem('currentMap', JSON.stringify(mapData));
							return;
						}
					}
				}
				
				// ถ้าไม่พบข้อมูลใน Google Sheets
				console.log(`📋 No map data found in Google Sheets, showing placeholder for ${buildingCode}`);
				showPlaceholderMap();
				
			} catch (error) {
				console.error('❌ Failed to load from Google Sheets:', error);
				console.log(`📋 Fallback to placeholder for ${buildingCode}`);
				showPlaceholderMap();
			}
		}

		// 🔧 แก้ไข 2: ปรับฟังก์ชัน fetchMapImageFromSheets() ให้ส่ง buildingCode ถูกต้อง
		async function fetchMapImageFromSheets(buildingCode) {
		try {
			const params = new URLSearchParams();
			params.append('action', 'getMapImages');
			if (buildingCode) {
				params.append('buildingCode', buildingCode);
			}

			imageLoadingAbortController = new AbortController();
			 
			const response = await fetch(sheetsConfig.url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: params.toString(),
				signal: imageLoadingAbortController.signal
			});

			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}

			const result = await response.json();
			console.log(`🗺️ Map images response for ${buildingCode}:`, result);
			
			if (result.success && result.data && result.data.length > 0) {
				// หา exact match สำหรับ buildingCode ก่อน
				let mapData = result.data.find(item => item.id === buildingCode);
				
				// ถ้าไม่เจอ ลองหา main_map หรือใช้ตัวแรก
				if (!mapData) {
					mapData = result.data.find(item => 
						item.id === 'main_map' || item.id === 'maps'
					) || result.data[0];
					
					console.log(`📋 No specific map for ${buildingCode}, using fallback:`, mapData?.id);
				}
				
				// 🔧 แก้ไข: ตรวจสอบและทำความสะอาด URLs
				if (mapData) {
					// ตรวจสอบ floorplan URL
					if (mapData.floorplan && !isValidImageUrl(mapData.floorplan)) {
						console.log(`🚫 Invalid floorplan URL: "${mapData.floorplan}"`);
						mapData.floorplan = null;
					}
					
					// ตรวจสอบ realphoto URL
					if (mapData.realphoto && !isValidImageUrl(mapData.realphoto)) {
						console.log(`🚫 Invalid realphoto URL: "${mapData.realphoto}"`);
						mapData.realphoto = null;
					}
					
					// ถ้าไม่มี valid URLs เลย
					if (!mapData.floorplan && !mapData.realphoto) {
						console.log(`⚠️ No valid image URLs found for ${buildingCode}`);
						return null;
					}
				}
				
				return mapData;
			}
			
			return null;
			
		} catch (error) {
			if (error.name === 'AbortError') {
				console.log('🚫 Image fetch aborted');
				return null;
			}
			console.error(`❌ Error fetching map for ${buildingCode}:`, error);
			throw error;
		}
	}
		
		// 🔧 แก้ไข 4: ปรับ loadFallbackFloorplan() ให้มี validation ดีกว่า
		async function loadFallbackFloorplan(buildingCode) {
			console.log(`🔄 Loading fallback floorplan for building: ${buildingCode}`);
			
			try {
				const params = new URLSearchParams();
				params.append('action', 'getMapImages');
				// ไม่ส่ง buildingCode เพื่อให้ได้ทุก maps
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});

				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}

				const result = await response.json();
				
				if (result.success && result.data && result.data.length > 0) {
					// หา main_map หรือใช้ตัวแรกที่มี valid floorplan
					let mainMap = null;
					
					// ลองหา main_map ก่อน
					mainMap = result.data.find(item => 
						(item.id === 'main_map' || item.id === 'maps') && 
						isValidImageUrl(item.floorplan)
					);
					
					// ถ้าไม่มี ลองหาอันแรกที่มี valid floorplan
					if (!mainMap) {
						mainMap = result.data.find(item => isValidImageUrl(item.floorplan));
					}
					
					if (mainMap && mainMap.floorplan) {
						console.log(`📐 Using fallback map: ${mainMap.id}`);
						
						// Cache the data
						mapImageCache.set(buildingCode, {
							url: mainMap.floorplan,
							realphoto: mainMap.realphoto,
							timestamp: Date.now()
						});
						
						// Load the image
						await loadFloorplanImage(mainMap.floorplan, buildingCode);
						showNotification(`📐 ใช้แผนผังทั่วไป สำหรับอาคาร ${buildingCode}`, 'info');
						return true;
					}
				}
				
				console.log('❌ No valid fallback floorplan found');
				return false;
				
			} catch (error) {
				console.error('❌ Fallback floorplan loading failed:', error);
				return false;
			}
		}

		// 🔧 แก้ไข 3: ปรับ loadFloorplanImage() ให้รองรับ Environment และมี validation ดีกว่า
		async function loadFloorplanImage(imageUrl, buildingCode) {
			return new Promise((resolve, reject) => {
				const img = document.getElementById('mapFloorplanImage');
				const placeholder = document.getElementById('roomMapPlaceholder');
				const controls = document.getElementById('imageControls');
				
				if (!img) {
					reject(new Error('Missing map image element'));
					return;
				}

				// 🔧 แก้ไข: ตรวจสอบ URL ก่อนโหลด
				if (!isValidImageUrl(imageUrl)) {
					console.error(`❌ Invalid image URL: "${imageUrl}"`);
					reject(new Error(`Invalid image URL: ${imageUrl}`));
					return;
				}

				console.log(`🖼️ Loading image for ${buildingCode}: ${imageUrl.substring(0, 100)}...`);

				// Create new image to test loading
				const testImg = new Image();
				
				// ⏰ ตั้ง timeout ก่อน - ป้องกัน memory leak
				const timeoutId = setTimeout(() => {
					testImg.onload = null;
					testImg.onerror = null;
					console.error(`⏰ Image loading timeout for ${buildingCode}`);
					reject(new Error('Image loading timeout'));
				}, 10000); // 10 วินาที
				
				testImg.onload = function() {
					clearTimeout(timeoutId);
					
					// Image loaded successfully
					img.src = imageUrl;
					img.style.display = 'block';
					
					if (placeholder) placeholder.style.display = 'none';
					if (controls) controls.style.display = 'flex';
					
					console.log(`✅ Image loaded successfully for ${buildingCode}`);
					showNotification(`✅ โหลดแผนผังสำหรับอาคาร ${buildingCode} สำเร็จ`, 'success');
					resolve();
				};
				
				testImg.onerror = function(event) {
					clearTimeout(timeoutId);
					
					console.error(`❌ Failed to load image for ${buildingCode}: ${imageUrl}`);
					console.error('Error event:', event);
					
					// แสดงข้อความ error ที่เป็นมิตร
					let errorMessage = 'ไม่สามารถโหลดรูปภาพได้';
					if (Environment.isLocalPC && !imageUrl.startsWith('data:')) {
						errorMessage = 'Local PC รองรับเฉพาะ Base64 images เท่านั้น';
					}
					
					showMapError(errorMessage, buildingCode);
					reject(new Error(`Failed to load image: ${imageUrl}`));
				};
				
				// เริ่มโหลดรูป
				testImg.src = imageUrl;
			});
		}
		
		

		// =================== Method 3: Upload & Preview ===================

		function initializeImageUpload() {
			const uploadZone = document.getElementById('mapUploadZone');
			const fileInput = document.getElementById('floorplanFileInput');
			
			if (!uploadZone || !fileInput) return;

			// Click to upload
			uploadZone.addEventListener('click', () => {
				fileInput.click();
			});

			// File input change
			fileInput.addEventListener('change', (e) => {
				if (e.target.files && e.target.files[0]) {
					handleImageUpload(e.target.files[0]);
				}
			});

			// Drag and drop
			uploadZone.addEventListener('dragover', (e) => {
				e.preventDefault();
				uploadZone.classList.add('dragover');
			});

			uploadZone.addEventListener('dragleave', (e) => {
				e.preventDefault();
				uploadZone.classList.remove('dragover');
			});

			uploadZone.addEventListener('drop', (e) => {
				e.preventDefault();
				uploadZone.classList.remove('dragover');
				
				const files = e.dataTransfer.files;
				if (files && files[0]) {
					handleImageUpload(files[0]);
				}
			});

			console.log('📤 Image upload initialized');
		}
		
		
		// ===== ฟังก์ชันตรวจสอบและบีบอัดรูปภาพ =====
		function checkImageSize(base64Data, maxSizeKB = 45) {
			if (!base64Data) return { valid: true, size: 0, sizeKB: 0 };
			
			const sizeBytes = base64Data.length;
			const sizeKB = Math.round(sizeBytes / 1024);
			const valid = sizeKB <= maxSizeKB;
			
			return {
				valid: valid,
				size: sizeBytes,
				sizeKB: sizeKB,
				maxSizeKB: maxSizeKB
			};
		}

		function compressImage(canvas, quality = 0.7, maxSizeKB = 45) {
			return new Promise((resolve) => {
				const tryCompress = (currentQuality) => {
					const base64 = canvas.toDataURL('image/jpeg', currentQuality);
					const check = checkImageSize(base64, maxSizeKB);
					
					console.log(`🔄 Compression attempt: quality=${currentQuality}, size=${check.sizeKB}KB`);
					
					if (check.valid || currentQuality <= 0.1) {
						resolve({
							base64: base64,
							quality: currentQuality,
							finalSize: check.sizeKB,
							compressed: currentQuality < quality
						});
					} else {
						// ลดคุณภาพลง 10%
						tryCompress(Math.max(0.1, currentQuality - 0.1));
					}
				};
				
				tryCompress(quality);
			});
		}

		async function processImageFile(file, maxSizeKB = 45, maxWidth = 1200, maxHeight = 800) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				
				reader.onload = async (e) => {
					try {
						const img = new Image();
						
						img.onload = async () => {
							try {
								console.log(`📐 Original image: ${img.width}x${img.height}`);
								
								// คำนวณขนาดใหม่
								let { width, height } = calculateNewDimensions(img.width, img.height, maxWidth, maxHeight);
								
								// สร้าง canvas
								const canvas = document.createElement('canvas');
								const ctx = canvas.getContext('2d');
								canvas.width = width;
								canvas.height = height;
								
								// วาดรูปลงใน canvas
								ctx.drawImage(img, 0, 0, width, height);
								
								// บีบอัดรูปภาพ
								const result = await compressImage(canvas, 0.8, maxSizeKB);
								
								console.log(`✅ Image processed: ${width}x${height}, quality=${result.quality}, size=${result.finalSize}KB`);
								
								resolve({
									base64: result.base64,
									width: width,
									height: height,
									quality: result.quality,
									finalSize: result.finalSize,
									compressed: result.compressed,
									originalSize: Math.round(file.size / 1024)
								});
								
							} catch (error) {
								reject(error);
							}
						};
						
						img.onerror = () => reject(new Error('Failed to load image'));
						img.src = e.target.result;
						
					} catch (error) {
						reject(error);
					}
				};
				
				reader.onerror = () => reject(new Error('Failed to read file'));
				reader.readAsDataURL(file);
			});
		}

		function calculateNewDimensions(originalWidth, originalHeight, maxWidth, maxHeight) {
			let width = originalWidth;
			let height = originalHeight;
			
			// คำนวณอัตราส่วนการย่อขนาด
			const widthRatio = maxWidth / originalWidth;
			const heightRatio = maxHeight / originalHeight;
			const ratio = Math.min(widthRatio, heightRatio, 1); // ไม่ขยายรูป
			
			width = Math.round(originalWidth * ratio);
			height = Math.round(originalHeight * ratio);
			
			return { width, height };
		}

		// =================== Placeholder Functions สำหรับ Maps ที่ยังไม่ได้ implement ===================
		// ===== แก้ไขฟังก์ชัน handleImageUpload =====
		async function handleImageUpload(input, type) {
    const file = input.files[0];
    if (!file) return;
    
    try {
        console.log(`📤 Processing ${type} image:`, file.name, `(${Math.round(file.size/1024)}KB)`);
        showNotification(`🔄 กำลังประมวลผล${type === 'floorplan' ? 'แผนผัง' : 'รูปจริง'}...`, 'info');
        
        // ตรวจสอบประเภทไฟล์
        if (!file.type.startsWith('image/')) {
            throw new Error('กรุณาเลือกไฟล์รูปภาพเท่านั้น');
        }
        
        // ตรวจสอบขนาดไฟล์ต้นฉบับ (ไม่เกิน 10MB)
        const maxFileSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxFileSize) {
            throw new Error('ไฟล์รูปภาพใหญ่เกินไป (เกิน 10MB)');
        }
        
        // ประมวลผลรูปภาพ
        const result = await processImageFile(file, 45, 1200, 800);
        
        // เก็บข้อมูลใน sessionStorage
        sessionStorage.setItem(`temp_${type}`, result.base64);
        sessionStorage.setItem(`${type}_uploaded`, 'true');
        
        // แสดงตัวอย่างรูปภาพ
        const previewId = type === 'floorplan' ? 'floorplanPreview' : 'realphotoPreview';
        updateImagePreview(previewId, result.base64, type);
        
        // แสดงข้อมูลการประมวลผล
        let message = `✅ ${type === 'floorplan' ? 'แผนผัง' : 'รูปจริง'}อัปโหลดสำเร็จ`;
        if (result.compressed) {
            message += ` (บีบอัดจาก ${result.originalSize}KB เป็น ${result.finalSize}KB)`;
        } else {
            message += ` (${result.finalSize}KB)`;
        }
        
        showNotification(message, 'success');
        console.log(`✅ ${type} upload complete:`, result);
        
    } catch (error) {
        console.error(`❌ ${type} upload error:`, error);
        showNotification(`❌ ไม่สามารถอัปโหลด${type === 'floorplan' ? 'แผนผัง' : 'รูปจริง'}ได้: ${error.message}`, 'error');
        
        // ล้างข้อมูลที่ผิดพลาด
        input.value = '';
        sessionStorage.removeItem(`temp_${type}`);
        sessionStorage.removeItem(`${type}_uploaded`);
    }
}
				
		 
		// =================== UI State Management ===================

		function showMapLoadingState(show, message = 'กำลังโหลดแผนที่...') {
			const overlay = document.getElementById('mapLoadingOverlay');
			if (overlay) {
				if (show) {
					overlay.style.display = 'flex';
					const text = overlay.querySelector('p');
					if (text) text.textContent = message;
				} else {
					overlay.style.display = 'none';
				}
			}
		}

		// 🔧 แก้ไข 2: ปรับ showPlaceholderMap() ให้ไม่แสดงข้อความ upload
		function showPlaceholderMap() {
			const img = document.getElementById('mapFloorplanImage');
			const placeholder = document.getElementById('roomMapPlaceholder');
			const controls = document.getElementById('imageControls');
			
			if (img) img.style.display = 'none';
			if (controls) controls.style.display = 'none';
			
			if (placeholder) {
				placeholder.style.display = 'block';
				placeholder.innerHTML = `
					<div style="text-align: center; padding: 40px; color: #666;">
						<i class="fas fa-map" style="font-size: 48px; margin-bottom: 15px; opacity: 0.3;"></i>
						<p style="margin: 0; font-size: 16px;">แผนที่อาคาร</p>
						<small style="opacity: 0.7;">คลิกเลือกตำแหน่งห้องบนแผนที่</small>
					</div>
				`;
			}
		}
		
		
		// 🔧 แก้ไข 4: เพิ่มฟังก์ชันโหลด image_urls จาก rooms data
		function loadRoomImageUrls(roomCode) {
			if (!roomCode || !roomsData[roomCode]) {
				console.log('⚠️ No room data found for:', roomCode);
				return;
			}
			
			const room = roomsData[roomCode];
			console.log(`📋 Loading image URLs for room ${roomCode}:`, room);
			
			// ตรวจสอบว่ามี images หรือ image_urls
			const imageUrls = room.images || room.image_urls || [];
			
			if (Array.isArray(imageUrls) && imageUrls.length > 0) {
				console.log(`🖼️ Found ${imageUrls.length} image URLs for room ${roomCode}`);
				
				// แสดงใน form - ถ้ามี element สำหรับแสดง image URLs
				displayRoomImages(imageUrls, roomCode);
			} else {
				console.log(`📷 No image URLs found for room ${roomCode}`);
				clearRoomImages();
			}
		}
		
		// 🔧 แก้ไข 5: เพิ่มฟังก์ชันแสดง room images ใน form
		function displayRoomImages(imageUrls, roomCode) {
			// หาจุดที่จะแสดง images ใน room form
			const imageContainer = document.getElementById('roomImageContainer') || 
								  document.querySelector('.room-images') ||
								  document.querySelector('#roomModal .modal-body');
			
			if (!imageContainer) {
				console.log('⚠️ No image container found in room form');
				return;
			}
			
			// ลบ existing images
			const existingImages = imageContainer.querySelectorAll('.room-image-preview');
			existingImages.forEach(img => img.remove());
			
			// เพิ่ม images ใหม่
			imageUrls.forEach((url, index) => {
				if (isValidImageUrl(url)) {
					const imageDiv = document.createElement('div');
					imageDiv.className = 'room-image-preview';
					imageDiv.style.cssText = `
						display: inline-block; margin: 5px; 
						border: 1px solid #ddd; border-radius: 5px; 
						padding: 5px; background: #f9f9f9;
						max-width: 150px;
					`;
					
					imageDiv.innerHTML = `
						<img src="${url}" style="max-width: 100%; height: 80px; object-fit: cover; border-radius: 3px;">
						<p style="margin: 5px 0 0 0; font-size: 11px; text-align: center;">รูปที่ ${index + 1}</p>
					`;
					
					imageContainer.appendChild(imageDiv);
				}
			});
			
			console.log(`✅ Displayed ${imageUrls.length} images for room ${roomCode}`);
		}
		
		// 🔧 แก้ไข 6: เพิ่มฟังก์ชันล้าง room images
		function clearRoomImages() {
			const imageContainer = document.getElementById('roomImageContainer') || 
								  document.querySelector('.room-images') ||
								  document.querySelector('#roomModal .modal-body');
			
			if (imageContainer) {
				const existingImages = imageContainer.querySelectorAll('.room-image-preview');
				existingImages.forEach(img => img.remove());
			}
		}


		// 🔧 แก้ไข 3: ลบ showUploadPrompt() หรือทำให้ไม่แสดงข้อความ upload
		function showUploadPrompt(buildingCode) {
			console.log(`📋 Building ${buildingCode} - showing simple placeholder instead of upload prompt`);
			showPlaceholderMap();
		}

		function showMapError(message, buildingCode) {
			const placeholder = document.getElementById('roomMapPlaceholder');
			if (placeholder) {
				placeholder.innerHTML = `
					<i class="fas fa-exclamation-triangle" style="font-size: 32px; margin-bottom: 8px; color: var(--danger-color);"></i>
					<div style="font-size: 14px; margin-bottom: 4px; color: var(--danger-color);">${message}</div>
					<div style="font-size: 11px; opacity: 0.7;">กรุณาลองใหม่อีกครั้ง</div>
				`;
				placeholder.style.display = 'block';
			}
			
			showNotification(message, 'error');
		}		
		// =================== Control Functions ===================

	
		
		// 🔧 แก้ไข 4: เพิ่มฟังก์ชัน clearMapImageCache() สำหรับ debug
		function clearMapImageCache() {
			mapImageCache.clear();
			console.log('🗑️ Map image cache cleared');
			showNotification('🗑️ ล้าง cache รูปภาพแล้ว', 'info');
		}		
		
		// 3. ✅ Helper Functions
		function fileToBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file);
			});
		}
		// 🔧 แก้ไข 5: แก้ไขปัญหา CRUD ไม่ sync ไปยัง Google Sheets ปรับ sheetsConfig เพื่อเปิด autoSync เป็นค่าเริ่มต้น
		function ensureAutoSyncEnabled() {
			// ตรวจสอบและเปิด autoSync ถ้ายังไม่ได้ตั้งค่า
			if (sheetsConfig.autoSync === undefined || sheetsConfig.autoSync === null) {
				sheetsConfig.autoSync = true;
				localStorage.setItem('sheetsConfig', JSON.stringify(sheetsConfig));
				console.log('✅ Auto-sync enabled by default');
			}
		}
		async function compressImageIfNeeded(base64, maxSizeKB = 500) {
			const currentSizeKB = Math.round(base64.length / 1024);
			
			if (currentSizeKB <= maxSizeKB) {
				return base64; // ไม่ต้องบีบอัด
			}
			
			try {
				// สร้าง canvas สำหรับบีบอัด
				const img = new Image();
				await new Promise((resolve, reject) => {
					img.onload = resolve;
					img.onerror = reject;
					img.src = base64;
				});
				
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');
				
				// คำนวณขนาดใหม่ (รักษาอัตราส่วน)
				const maxDimension = 1200;
				let { width, height } = img;
				
				if (width > height && width > maxDimension) {
					height = (height * maxDimension) / width;
					width = maxDimension;
				} else if (height > maxDimension) {
					width = (width * maxDimension) / height;
					height = maxDimension;
				}
				
				canvas.width = width;
				canvas.height = height;
				
				// วาดรูปใหม่
				ctx.drawImage(img, 0, 0, width, height);
				
				// ลดคุณภาพจนกว่าจะได้ขนาดที่ต้องการ
				let quality = 0.8;
				let compressed;
				
				do {
					compressed = canvas.toDataURL('image/jpeg', quality);
					const compressedSizeKB = Math.round(compressed.length / 1024);
					
					if (compressedSizeKB <= maxSizeKB || quality <= 0.1) {
						break;
					}
					
					quality -= 0.1;
				} while (quality > 0.1);
				
				console.log(`🗜️ บีบอัด: ${currentSizeKB}KB → ${Math.round(compressed.length / 1024)}KB`);
				return compressed;
				
			} catch (error) {
				console.error('Compression error:', error);
				return base64; // คืนค่าต้นฉบับถ้าบีบอัดไม่ได้
			}
		}
		
		// 4. ✅ Local Storage Management
		function saveToLocal(key, data) {
			try {
				localStorage.setItem(key, JSON.stringify(data));
				return true;
			} catch (error) {
				console.error('Local storage error:', error);
				return false;
			}
		}
		
		function loadFromLocal(key, defaultValue = null) {
		try {
			const data = localStorage.getItem(key);
			return data ? JSON.parse(data) : defaultValue;
		} catch (error) {
			console.error('Local storage load error:', error);
			return defaultValue;
		}
	}
			
		// ===== เพิ่มฟังก์ชันแสดงข้อมูลการบีบอัด =====
		function showCompressionInfo(originalSize, finalSize, quality) {
			const compressionRatio = Math.round((1 - finalSize/originalSize) * 100);
			console.log(`📊 Compression: ${originalSize}KB → ${finalSize}KB (${compressionRatio}% reduced, quality: ${Math.round(quality*100)}%)`);
			
			if (compressionRatio > 0) {
				showNotification(`🗜️ รูปภาพถูกบีบอัด ${compressionRatio}% (${originalSize}KB → ${finalSize}KB)`, 'info');
			}
		}

		// ===== เพิ่มฟังก์ชันตรวจสอบความพร้อมของระบบ =====
		function checkSystemReady() {
			const canvas = document.createElement('canvas');
			const canvasSupported = canvas.getContext && canvas.getContext('2d');
			
			if (!canvasSupported) {
				console.error('❌ Canvas not supported');
				showNotification('❌ เบราว์เซอร์ไม่รองรับการประมวลผลรูปภาพ', 'error');
				return false;
			}
			
			console.log('✅ Image processing system ready');
			return true;
		}

		// เรียกใช้เมื่อ page โหลด
		document.addEventListener('DOMContentLoaded', function() {
			checkSystemReady();
			
			// โหลดการตั้งค่า Google Sheets จาก localStorage
			loadSheetsConfigFromStorage();
			
			// อัพเดทสถานะการเชื่อมต่อ
			updateConnectionStatus();
		});

		// ฟังก์ชันโหลดการตั้งค่าจาก localStorage
		function loadSheetsConfigFromStorage() {
			try {
				const saved = localStorage.getItem('sheetsConfig');
				if (saved) {
					const config = JSON.parse(saved);
					sheetsConfig = { ...sheetsConfig, ...config };
					
					// อัพเดท UI ถ้ามี element
					const urlInput = document.getElementById('sheetsUrl');
					if (urlInput && sheetsConfig.url) {
						urlInput.value = sheetsConfig.url;
					}
					
					console.log('✅ Sheets config loaded from storage');
				}
			} catch (error) {
				console.error('❌ Failed to load sheets config:', error);
			}
		}

		
		
		// 4. เพิ่ม Function สำหรับลบตัวอย่างรูปภาพ
		function removeImagePreview(previewId, imageType) {
			console.log('🗑️ Removing preview:', previewId, imageType);
			
			// ลบจาก sessionStorage
			const type = previewId.includes('floorplan') ? 'floorplan' : 'realphoto';
			sessionStorage.removeItem(`temp_${type}`);
			sessionStorage.removeItem(`${type}_uploaded`);
			
			// ล้าง file input
			const inputId = type === 'floorplan' ? 'floorplanUpload' : 'realphotoUpload';
			const inputElement = document.getElementById(inputId);
			if (inputElement) {
				inputElement.value = '';
			}
			
			// รีเซ็ตตัวอย่าง
			resetImagePreview(previewId, imageType);
			
			showNotification(`🗑️ ลบ${imageType}แล้ว`, 'info');
		}

	 		
		// ✅ ฟังก์ชันใหม่: อัพเดทสถานะ form หลังบันทึกสำเร็จ
		function updateMapFormsAfterSave() {
			console.log('📝 Updating map forms after successful save...');
			
			// เพิ่มไอคอนแสดงสถานะ "บันทึกแล้ว" ใน preview
			const floorplanPreview = document.getElementById('floorplanPreview');
			const realphotoPreview = document.getElementById('realphotoPreview');
			
			// เพิ่ม badge "บันทึกแล้ว" ถ้ามีรูปภาพ
			if (floorplanPreview && sessionStorage.getItem('floorplan_uploaded') === 'true') {
				addSavedBadge(floorplanPreview);
			}
			
			if (realphotoPreview && sessionStorage.getItem('realphoto_uploaded') === 'true') {
				addSavedBadge(realphotoPreview);
			}
			
			// ปิดการใช้งานปุ่มบันทึกชั่วคราว
			const saveButton = document.querySelector('button[onclick="saveMapImages()"]');
			if (saveButton) {
				const originalText = saveButton.innerHTML;
				saveButton.innerHTML = '<i class="fas fa-check"></i> บันทึกแล้ว';
				saveButton.disabled = true;
				
				// เปิดใช้งานปุ่มใหม่หลัง 3 วินาที
				setTimeout(() => {
					saveButton.innerHTML = originalText;
					saveButton.disabled = false;
				}, 3000);
			}
			
			console.log('✅ Map forms updated after save');
		}

		// ✅ ฟังก์ชันเพิ่ม badge "บันทึกแล้ว"
		function addSavedBadge(previewElement) {
			// ลบ badge เก่าถ้ามี
			const existingBadge = previewElement.querySelector('.saved-badge');
			if (existingBadge) {
				existingBadge.remove();
			}
			
			// เพิ่ม badge ใหม่
			const badge = document.createElement('div');
			badge.className = 'saved-badge';
			badge.style.cssText = `
				position: absolute; top: 5px; right: 25px;
				background: var(--accent-color); color: white;
				padding: 2px 8px; border-radius: 12px; font-size: 10px;
				font-weight: bold; z-index: 10;
			`;
			badge.innerHTML = '<i class="fas fa-check"></i> บันทึกแล้ว';
			
			const container = previewElement.querySelector('div[style*="position: relative"]');
			if (container) {
				container.appendChild(badge);
			}
		}

		// =================== แก้ไขปัญหาที่ 2: โหลด Maps เมื่อเข้าหน้า Admin ครั้งแรก ===================

		 
		// 4. ✅ Enhanced addLoadedFromSheetsBadge
		function addLoadedFromSheetsBadge() {
			const previews = ['floorplanPreview', 'realphotoPreview'];
			
			previews.forEach(previewId => {
				const preview = document.getElementById(previewId);
				if (preview && preview.querySelector('img')) {
					// ลบ badge เก่า
					const existingBadge = preview.querySelector('.loaded-badge');
					if (existingBadge) existingBadge.remove();
					
					const badge = document.createElement('div');
					badge.className = 'loaded-badge';
					badge.style.cssText = `
						position: absolute; bottom: 5px; left: 5px;
						background: linear-gradient(45deg, #17a2b8, #007bff);
						color: white; padding: 2px 6px; border-radius: 8px; 
						font-size: 10px; font-weight: bold; z-index: 10;
						box-shadow: 0 2px 4px rgba(0,0,0,0.2);
						border: 1px solid rgba(255,255,255,0.3);
					`;
					badge.innerHTML = '<i class="fas fa-cloud-download-alt"></i> Google Sheets';
					
					const container = preview.querySelector('.image-preview-container');
					if (container) {
						container.appendChild(badge);
					}
				}
			});
		}


		// ✅ ฟังก์ชัน loadMapsTable  
		function loadMapsTable() {
			console.log('🗺️ Loading Maps table...');
			
			try {
				// ✅ เอาคอมเมนต์ออกเพื่อให้โหลดจาก Google Sheets
				loadExistingMaps();  // ← เอาคอมเมนต์ออกจากบรรทัดนี้
				
				// โหลดข้อมูลที่บันทึกใน session storage ด้วย
				loadSavedImages();
				
				// อัพเดท Sync History UI
				updateMapSyncHistoryUI();
				
				console.log('✅ Maps table loaded successfully');
				
			} catch (error) {
				console.error('❌ Error loading maps table:', error);
			}
		}


		// 2. ✅ Fixed loadExistingMaps - เพิ่มเติมใน Universal Code ให้แสดง status ชัดเจนขึ้น
		async function loadExistingMaps() {
		try {
			console.log('🗺️ Loading existing maps...');
			
			if (!sheetsConfig.url) {
				console.log('❌ No Google Sheets URL configured');
				loadSavedImages(); // ลองโหลดจาก localStorage
				return;
			}

			showNotification('🔍 กำลังโหลดแผนที่จาก Google Sheets...', 'info');

			const params = new URLSearchParams();
			params.append('action', 'getData');
			params.append('sheet', sheetsConfig.mapImagesSheet);

			const response = await fetch(sheetsConfig.url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: params.toString()
			});

			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}

			const result = await response.json();
			console.log('🗺️ Found map data:', result);

			if (result.success && result.data && result.data.length > 0) {
				const mapData = result.data.find(row => row.id === 'main_map');
				
				if (mapData) {
					console.log('🗺️ Found map data:', {
						id: mapData.id,
						hasFloorplan: !!mapData.floorplan,
						hasRealphoto: !!mapData.realphoto,
						floorplanValid: isValidImageData(mapData.floorplan),
						realphotoValid: isValidImageData(mapData.realphoto)
					});

					// ตรวจสอบและโหลด floorplan
					const floorplanStatus = isValidImageData(mapData.floorplan);
					if (floorplanStatus === true) {
						console.log('📐 Loading valid floorplan...');
						updateImagePreview('floorplanPreview', mapData.floorplan, 'floorplan');				 
					} else if (floorplanStatus === 'pending') {
						console.log('📐 Floorplan marked as available but not loaded');
						// จะมีการโหลดใน handlePendingImages()
					}
					

					// ตรวจสอบและโหลด realphoto
					const realphotoStatus = isValidImageData(mapData.realphoto);
					if (realphotoStatus === true) {
						console.log('📷 Loading valid realphoto...');
						updateImagePreview('realphotoPreview', mapData.realphoto, 'realphoto');
					} else if (realphotoStatus === 'pending') {
						console.log('📷 Realphoto marked as available but not loaded');
						// จะมีการโหลดใน handlePendingImages()
					}

					// เติม notes ถ้ามี
					if (mapData.notes) {
						const notesField = document.getElementById('mapNotes');
						if (notesField) notesField.value = mapData.notes;
					}

					// พยายามโหลดรูป pending
					await handlePendingImages();
				}
			}

			showNotification('✅ โหลดข้อมูลแผนที่เสร็จสิ้น', 'success');

		} catch (error) {
			console.error('❌ Failed to load existing maps:', error);
			showNotification(`⚠️ โหลดจาก Google Sheets ไม่สำเร็จ: ${error.message}`, 'warning');
			
			// Fallback ไปใช้ localStorage
			loadSavedImages();
		}
	}
		
		
		// 3. ✅ Fallback function สำหรับ local storage
		function loadFromLocalStorage() {
			try {
				console.log('📂 Loading from local storage with validation...');
				
				const savedMap = localStorage.getItem('currentMap');
				if (savedMap) {
					const mapData = JSON.parse(savedMap);
					
					// โหลดและ validate floorplan
					if (mapData.floorplan && isValidImageData(mapData.floorplan)) {
						sessionStorage.setItem('temp_floorplan', mapData.floorplan);
						sessionStorage.setItem('floorplan_uploaded', 'true');
						updateImagePreview('floorplanPreview', mapData.floorplan, 'floorplan');
					} else {
						resetImagePreview('floorplanPreview', 'floorplan');
					}
					
					// โหลดและ validate realphoto
					if (mapData.realphoto && isValidImageData(mapData.realphoto)) {
						sessionStorage.setItem('temp_realphoto', mapData.realphoto);
						sessionStorage.setItem('realphoto_uploaded', 'true');
						updateImagePreview('realphotoPreview', mapData.realphoto, 'realphoto');
					} else {
						resetImagePreview('realphotoPreview', 'realphoto');
					}
					
					if (mapData.notes) {
						const notesInput = document.getElementById('mapNotes');
						if (notesInput) notesInput.value = mapData.notes;
					}
					
					showNotification('✅ โหลดจากเครื่องสำเร็จ', 'success');
					console.log('✅ Loaded from local storage');
				} else {
					console.log('📝 No local data found');
					resetImagePreview('floorplanPreview', 'floorplan');
					resetImagePreview('realphotoPreview', 'realphoto');
					showNotification('📝 ไม่พบข้อมูลที่บันทึกไว้', 'info');
				}
				
			} catch (error) {
				console.error('❌ Local storage error:', error);
				resetImagePreview('floorplanPreview', 'floorplan');
				resetImagePreview('realphotoPreview', 'realphoto');
			}
		}
		
		//  ✅ Function สำหรับล้างข้อมูลทั้งหมด (Emergency cleanup)
		function cleanupAllImageData() {
			console.log('🧹 Performing complete image data cleanup...');
			
			// ล้าง sessionStorage
			const sessionKeys = ['temp_floorplan', 'temp_realphoto', 'floorplan_uploaded', 'realphoto_uploaded'];
			sessionKeys.forEach(key => sessionStorage.removeItem(key));
			
			// ล้าง file inputs
			const inputs = ['floorplanFileInput', 'realphotoFileInput'];
			inputs.forEach(id => {
				const input = document.getElementById(id);
				if (input) input.value = '';
			});
			
			// รีเซ็ต previews
			resetImagePreview('floorplanPreview', 'floorplan');
			resetImagePreview('realphotoPreview', 'realphoto');
			
			// ล้าง notes
			const notesInput = document.getElementById('mapNotes');
			if (notesInput) notesInput.value = '';
			
			showNotification('🧹 ล้างข้อมูลรูปภาพทั้งหมดแล้ว', 'info');
		}
		
		// ✅ ฟังก์ชันใหม่: อัพเดทสถานะ form หลังบันทึกสำเร็จ
		function updateMapFormsAfterSave() {
			console.log('📝 Updating map forms after successful save...');
			
			// เพิ่มไอคอนแสดงสถานะ "บันทึกแล้ว" ใน preview
			const floorplanPreview = document.getElementById('floorplanPreview');
			const realphotoPreview = document.getElementById('realphotoPreview');
			
			// เพิ่ม badge "บันทึกแล้ว" ถ้ามีรูปภาพ
			if (floorplanPreview && sessionStorage.getItem('floorplan_uploaded') === 'true') {
				addSavedBadge(floorplanPreview);
			}
			
			if (realphotoPreview && sessionStorage.getItem('realphoto_uploaded') === 'true') {
				addSavedBadge(realphotoPreview);
			}
			
			// ปิดการใช้งานปุ่มบันทึกชั่วคราว
			const saveButton = document.querySelector('button[onclick="saveMapImages()"]');
			if (saveButton) {
				const originalText = saveButton.innerHTML;
				saveButton.innerHTML = '<i class="fas fa-check"></i> บันทึกแล้ว';
				saveButton.disabled = true;
				
				// เปิดใช้งานปุ่มใหม่หลัง 3 วินาที
				setTimeout(() => {
					saveButton.innerHTML = originalText;
					saveButton.disabled = false;
				}, 3000);
			}
			
			console.log('✅ Map forms updated after save');
		}

		// ✅ ฟังก์ชันเพิ่ม badge "บันทึกแล้ว"
		function addSavedBadge(previewElement) {
			// ลบ badge เก่าถ้ามี
			const existingBadge = previewElement.querySelector('.saved-badge');
			if (existingBadge) {
				existingBadge.remove();
			}
			
			// เพิ่ม badge ใหม่
			const badge = document.createElement('div');
			badge.className = 'saved-badge';
			badge.style.cssText = `
				position: absolute; top: 5px; right: 25px;
				background: var(--accent-color); color: white;
				padding: 2px 8px; border-radius: 12px; font-size: 10px;
				font-weight: bold; z-index: 10;
			`;
			badge.innerHTML = '<i class="fas fa-check"></i> บันทึกแล้ว';
			
			const container = previewElement.querySelector('div[style*="position: relative"]');
			if (container) {
				container.appendChild(badge);
			}
		}		

		// ===== 🔧 FIXED: แก้ไขฟังก์ชัน clearMapForms() =====
		function clearMapForms() {
			console.log('🧹 Clearing map forms...');
			
			// ล้าง file inputs
			const floorplanInput = document.getElementById('floorplanUpload');
			const realphotoInput = document.getElementById('realphotoUpload');
			const notesInput = document.getElementById('mapNotes');
			
			if (floorplanInput) floorplanInput.value = '';
			if (realphotoInput) realphotoInput.value = '';
			if (notesInput) notesInput.value = '';
			
			// ✅ แก้ไข: ล้าง sessionStorage ด้วย key ที่ถูกต้อง
			sessionStorage.removeItem('temp_floorplan');
			sessionStorage.removeItem('temp_realphoto');
			sessionStorage.removeItem('floorplan_uploaded');
			sessionStorage.removeItem('realphoto_uploaded');
			
			// รีเซ็ตตัวอย่างรูปภาพ
			resetImagePreview('floorplanPreview', 'แผนผัง');
			resetImagePreview('realphotoPreview', 'รูปจริง');
			
			console.log('✅ Map forms cleared successfully');
			showNotification('🧹 ล้างข้อมูลแล้ว', 'info');
		}

		// ✅ แก้ไขฟังก์ชัน resetImagePreview()
		
		function resetImagePreview(previewId, imageType) {
			const previewElement = document.getElementById(previewId);
			if (!previewElement) return;
			
			const displayType = imageType === 'floorplan' ? 'แผนผัง' : 'รูปจริง';
			
			previewElement.innerHTML = `
				<div style="
					text-align: center; padding: 30px; 
					border: 2px dashed #ddd; border-radius: 8px;
					background: #f8f9fa; color: #6c757d;
				">
					<i class="fas fa-image" style="font-size: 32px; margin-bottom: 10px; opacity: 0.5;"></i>
					<p style="margin: 0; font-size: 14px;">ไม่มี${displayType}</p>
					<small style="opacity: 0.7;">กรุณาอัปโหลดรูปภาพ</small>
				</div>
			`;
		}

		// 3. ✅ Function สำหรับล้างข้อมูลที่ไม่ถูกต้อง
		function cleanupInvalidImageData(imageType) {
			console.log(`🧹 Cleaning up invalid ${imageType} data...`);
			
			const keys = [`temp_${imageType}`, `${imageType}_uploaded`];
			keys.forEach(key => {
				sessionStorage.removeItem(key);
			});
			
			// ล้าง input ด้วย
			const inputId = imageType === 'floorplan' ? 'floorplanFileInput' : 'realphotoFileInput';
			const input = document.getElementById(inputId);
			if (input) {
				input.value = '';
			}
		}
		
		// 10. Update Map Sync History Function
		function updateMapSyncHistory(syncData) {
			const historyContainer = document.getElementById('mapSyncHistory');
			if (!historyContainer) return;
			
			const timestamp = new Date().toLocaleString('th-TH');
			
			const historyItem = document.createElement('div');
			historyItem.style.cssText = `
				background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px;
				border-left: 4px solid var(--success-color);
			`;
			
			historyItem.innerHTML = `
				<div style="display: flex; justify-content: space-between; align-items: center;">
					<div>
						<strong>🔄 ซิงค์แผนที่สำเร็จ</strong>
						<p style="margin: 5px 0; color: var(--text-secondary); font-size: 14px;">
							แผนผัง: ${syncData.floorplan} | รูปจริง: ${syncData.realphoto}
						</p>
						${syncData.notes ? `<p style="margin: 0; font-style: italic;">หมายเหตุ: ${syncData.notes}</p>` : ''}
					</div>
					<small style="color: var(--text-secondary);">${timestamp}</small>
				</div>
			`;
			
			historyContainer.insertBefore(historyItem, historyContainer.firstChild);
			
			// Keep only last 5 history items
			const historyItems = historyContainer.children;
			while (historyItems.length > 5) {
				historyContainer.removeChild(historyItems[historyItems.length - 1]);
			}
		}
		 
		 
		// ===== 🌐 Universal Code สำหรับทั้ง Local PC และ Web Server =====

		// 1. ✅ Environment Detection System
		const Environment = {
			isLocalPC: window.location.protocol === 'file:',
			isWebServer: window.location.protocol.startsWith('http'),
			isLocalhost: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
			
			init() {
				console.log(`🌐 Environment: ${this.getType()}`);
				console.log(`📍 Protocol: ${window.location.protocol}`);
				console.log(`🏠 Host: ${window.location.hostname}`);
				
				// ตั้งค่า storage strategy
				this.setupStorageStrategy();
				
				// ตั้งค่า image handling strategy
				this.setupImageStrategy();
			},
			
			getType() {
				if (this.isLocalPC) return 'Local PC';
				if (this.isLocalhost) return 'Local Web Server';
				return 'Remote Web Server';
			},
			
			setupStorageStrategy() {
				this.storageMethod = this.isLocalPC ? 'localStorage' : 'hybrid';
				this.imageMethod = this.isLocalPC ? 'base64only' : 'smart';
			},
			
			setupImageStrategy() {
				this.maxImageSize = this.isLocalPC ? 500 : 1000; // KB
				this.preferredFormat = this.isLocalPC ? 'jpeg' : 'auto';
			}
		};

		// 2. ✅ Universal Image Preview Function  Enhanced updateImagePreview ที่จัดการ invalid data ได้ดีขึ้น
		function updateImagePreview(previewId, imageData, imageType) {
			const previewElement = document.getElementById(previewId);
			if (!previewElement) {
				console.error('❌ Preview element not found:', previewId);
				return;
			}
			
			const displayType = imageType === 'floorplan' ? 'แผนผัง' : 'รูปจริง';
			
			// 🆕 Enhanced validation
			if (!imageData || typeof imageData !== 'string' || imageData.trim() === '') {
				console.log(`📝 No ${imageType} data provided`);
				resetImagePreview(previewId, imageType);
				return;
			}
			
			// 🆕 ตรวจสอบ invalid values
			const invalidValues = ['available', 'none', 'null', 'undefined', ''];
			if (invalidValues.includes(imageData.toLowerCase().trim())) {
				console.warn(`⚠️ Invalid ${imageType} data detected:`, imageData);
				cleanupInvalidImageData(imageType);
				resetImagePreview(previewId, imageType);
				return;
			}
			
			// ตรวจสอบและจัดการ image source
			let imageSrc = '';
			let sizeKB = 0;
			let isValid = false;
			
			if (imageData.startsWith('data:image/')) {
				// Base64 - ใช้ได้ทุก environment
				imageSrc = imageData;
				sizeKB = Math.round(imageData.length / 1024);
				isValid = true;
			} else if (imageData.startsWith('http://') || imageData.startsWith('https://')) {
				// HTTP URLs - ใช้ได้ทุก environment
				imageSrc = imageData;
				sizeKB = 0;
				isValid = true;
			} else if (Environment.isWebServer && (imageData.startsWith('./') || imageData.startsWith('../') || !imageData.includes('://'))) {
				// Relative paths - ใช้ได้เฉพาะใน web server
				imageSrc = imageData;
				sizeKB = 0;
				isValid = true;
			} else {
				console.warn(`⚠️ Unsupported image source format: ${imageData}`);
				cleanupInvalidImageData(imageType);
				isValid = false;
			}
			
			if (!isValid) {
				resetImagePreview(previewId, imageType);
				return;
			}
			
			// สร้าง preview HTML
			previewElement.innerHTML = `
				<div style="position: relative;" class="image-preview-container">
					<img src="${imageSrc}" 
						 style="max-width: 100%; max-height: 150px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" 
						 alt="${displayType}"
						 onload="handleImageLoadSuccess(this, '${previewId}')"
						 onerror="handleImageLoadError(this, '${previewId}', '${displayType}')">
					<div class="image-size-badge" style="
						position: absolute; top: 5px; right: 5px; 
						background: rgba(0,0,0,0.7); color: white; 
						padding: 2px 6px; border-radius: 4px; font-size: 11px; display: none;
					">
						${sizeKB > 0 ? sizeKB + 'KB' : 'External'}
					</div>
					<button onclick="removeImagePreview('${previewId}', '${imageType}')" 
							class="remove-image-btn"
							style="
								position: absolute; top: 5px; left: 5px;
								background: rgba(220, 53, 69, 0.8); color: white;
								border: none; border-radius: 50%; width: 24px; height: 24px;
								font-size: 12px; cursor: pointer; display: none;
								align-items: center; justify-content: center;
							">×</button>
				</div>
				<p style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
					<span class="loading-text">🔄 กำลังโหลด ${displayType}...</span>
					<span class="success-text" style="display: none;">✅ ${displayType} 
						${sizeKB > 0 ? '(' + sizeKB + 'KB)' : '(External)'}</span>
					<span class="error-text" style="display: none;">❌ ไม่สามารถโหลด${displayType}ได้</span>
				</p>
			`;
		}

		// 3. ✅ Universal Image Loading Handlers
		function handleImageLoadSuccess(imgElement, previewId) {
			console.log(`✅ Image loaded successfully: ${previewId} (${Environment.getType()})`);
			
			const container = imgElement.closest('.image-preview-container');
			if (container) {
				const sizeBadge = container.querySelector('.image-size-badge');
				const removeBtn = container.querySelector('.remove-image-btn');
				if (sizeBadge) sizeBadge.style.display = 'block';
				if (removeBtn) removeBtn.style.display = 'flex';
			}
			
			const previewElement = document.getElementById(previewId);
			if (previewElement) {
				const loadingText = previewElement.querySelector('.loading-text');
				const successText = previewElement.querySelector('.success-text');
				if (loadingText) loadingText.style.display = 'none';
				if (successText) successText.style.display = 'inline';
			}
		}

		function handleImageLoadError(imgElement, previewId, displayType) {
			console.error(`❌ Image failed to load: ${previewId} (${Environment.getType()})`);
			
			const container = imgElement.closest('.image-preview-container');
			if (container) {
				container.innerHTML = `
					<div style="text-align: center; padding: 20px; border: 2px dashed #dc3545; 
								border-radius: 8px; background: rgba(220, 53, 69, 0.1);">
						<i class="fas fa-broken-image" style="font-size: 24px; color: #dc3545; margin-bottom: 8px;"></i>
						<p style="color: #dc3545; margin: 0; font-size: 12px;">ไม่สามารถโหลด${displayType}ได้</p>
						<small style="color: #666;">ตรวจสอบ URL หรือการเชื่อมต่อ</small>
					</div>
				`;
			}
			
			showNotification(`❌ ไม่สามารถโหลด${displayType}ได้`, 'error');
		}

		// 4. ✅ Universal Image File Handler (แทนที่ของเดิม)
		async function handleImageFile(file, imageType = 'floorplan') {
			if (!file || !file.type.startsWith('image/')) {
				showNotification('❌ กรุณาเลือกไฟล์รูปภาพ', 'error');
				return false;
			}
			
			const maxFileSize = 10 * 1024 * 1024; // 10MB
			if (file.size > maxFileSize) {
				showNotification('❌ ไฟล์ใหญ่เกินไป (เกิน 10MB)', 'error');
				return false;
			}
			
			try {
				showNotification('🔄 กำลังประมวลผลรูปภาพ...', 'info');
				
				// 🆕 Smart processing based on environment
				let processedImage;
				
				if (Environment.isLocalPC) {
					// Local PC: บังคับใช้ base64 + compress
					processedImage = await processImageForLocal(file);
				} else {
					// Web Server: ใช้ strategy ที่ดีที่สุด
					processedImage = await processImageForWeb(file, imageType);
				}
				
				// เก็บข้อมูลด้วยวิธีที่เหมาะสมกับ environment
				await saveImageData(imageType, processedImage);
				
				// แสดงตัวอย่าง
				const previewId = imageType === 'floorplan' ? 'floorplanPreview' : 'realphotoPreview';
				updateImagePreview(previewId, processedImage.src, imageType);
				
				showNotification(
					`✅ ${imageType === 'floorplan' ? 'แผนผัง' : 'รูปจริง'}อัปโหลดสำเร็จ (${processedImage.size})`,
					'success'
				);
				
				return true;
				
			} catch (error) {
				console.error('Image processing error:', error);
				showNotification(`❌ ไม่สามารถประมวลผลรูปภาพได้: ${error.message}`, 'error');
				return false;
			}
		}

		// 5. ✅ Environment-Specific Image Processing
		async function processImageForLocal(file) {
			// Local PC: แปลงเป็น base64 และบีบอัด
			const base64 = await fileToBase64(file);
			const compressed = await compressImageIfNeeded(base64, Environment.maxImageSize);
			
			return {
				src: compressed,
				size: Math.round(compressed.length / 1024) + 'KB',
				method: 'base64'
			};
		}

		async function processImageForWeb(file, imageType) {
			// Web Server: ลองใช้ multiple strategies
			
			// Strategy 1: ถ้าเป็น localhost และมี upload endpoint
			if (Environment.isLocalhost && await checkUploadEndpoint()) {
				try {
					const uploaded = await uploadToServer(file, imageType);
					return {
						src: uploaded.url,
						size: uploaded.size,
						method: 'server'
					};
				} catch (error) {
					console.log('📝 Server upload failed, using base64 fallback');
				}
			}
			
			// Strategy 2: Fallback to base64 (เหมือน Local PC)
			return await processImageForLocal(file);
		}

		// 6. ✅ Universal Storage System
		async function saveImageData(imageType, processedImage) {
			const storageKey = `temp_${imageType}`;
			const uploadedKey = `${imageType}_uploaded`;
			
			if (Environment.isLocalPC) {
				// Local PC: ใช้ sessionStorage เท่านั้น
				sessionStorage.setItem(storageKey, processedImage.src);
				sessionStorage.setItem(uploadedKey, 'true');
			} else {
				// Web Server: ใช้ hybrid storage
				sessionStorage.setItem(storageKey, processedImage.src);
				sessionStorage.setItem(uploadedKey, 'true');
				
				// เก็บ metadata ใน localStorage ด้วย
				const metadata = {
					type: imageType,
					size: processedImage.size,
					method: processedImage.method,
					timestamp: new Date().toISOString()
				};
				localStorage.setItem(`${imageType}_metadata`, JSON.stringify(metadata));
			}
		}

		// 7. ✅ Server Upload Functions (สำหรับ Web Server)
		async function checkUploadEndpoint() {
			try {
				const response = await fetch('/api/upload/check', { method: 'HEAD' });
				return response.ok;
			} catch {
				return false;
			}
		}

		async function uploadToServer(file, imageType) {
			const formData = new FormData();
			formData.append('image', file);
			formData.append('type', imageType);
			
			const response = await fetch('/api/upload/image', {
				method: 'POST',
				body: formData
			});
			
			if (!response.ok) {
				throw new Error(`Upload failed: ${response.status}`);
			}
			
			return await response.json(); // { url, size }
		}

		// 8. ✅ Universal Helper Functions
		function fileToBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file);
			});
		}

		async function compressImageIfNeeded(base64, maxSizeKB) {
			const currentSizeKB = Math.round(base64.length / 1024);
			
			if (currentSizeKB <= maxSizeKB) {
				return base64;
			}
			
			try {
				const img = new Image();
				await new Promise((resolve, reject) => {
					img.onload = resolve;
					img.onerror = reject;
					img.src = base64;
				});
				
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');
				
				// คำนวณขนาดใหม่
				const maxDimension = Environment.isLocalPC ? 1000 : 1500;
				let { width, height } = img;
				
				if (width > height && width > maxDimension) {
					height = (height * maxDimension) / width;
					width = maxDimension;
				} else if (height > maxDimension) {
					width = (width * maxDimension) / height;
					height = maxDimension;
				}
				
				canvas.width = width;
				canvas.height = height;
				ctx.drawImage(img, 0, 0, width, height);
				
				// ปรับ quality ตาม environment
				let quality = Environment.isLocalPC ? 0.7 : 0.8;
				let compressed;
				
				do {
					compressed = canvas.toDataURL('image/jpeg', quality);
					const compressedSizeKB = Math.round(compressed.length / 1024);
					
					if (compressedSizeKB <= maxSizeKB || quality <= 0.1) {
						break;
					}
					quality -= 0.1;
				} while (quality > 0.1);
				
				console.log(`🗜️ บีบอัด (${Environment.getType()}): ${currentSizeKB}KB → ${Math.round(compressed.length / 1024)}KB`);
				return compressed;
				
			} catch (error) {
				console.error('Compression error:', error);
				return base64;
			}
		}

		// 9. ✅ Universal Google Sheets Integration
		async function saveMapToSheets(mapData) {
			if (!sheetsConfig.url || !sheetsConfig.connected) {
				console.log(`📝 บันทึกในเครื่องเท่านั้น (${Environment.getType()})`);
				
				if (Environment.isLocalPC) {
					localStorage.setItem('currentMap', JSON.stringify(mapData));
				} else {
					localStorage.setItem('currentMap', JSON.stringify(mapData));
					await saveToServerIfAvailable(mapData);
				}
				
				return { success: true, method: 'local' };
			}
			
			try {
				console.log('💾 Saving to Google Sheets...');
				
				// 🆕 ใช้ addMapImages แทน saveMap ตาม Apps Script
				const params = new URLSearchParams();
				params.append('action', 'addMapImages');  // ← แก้ไขจาก 'saveMap'
				params.append('id', mapData.id || 'main_map');
				params.append('floorplan', mapData.floorplan || '');
				params.append('realphoto', mapData.realphoto || '');
				params.append('notes', mapData.notes || '');
				params.append('environment', Environment.getType());
				
				console.log('📤 Request data:', {
					action: 'addMapImages',
					id: mapData.id || 'main_map',
					hasFloorplan: !!mapData.floorplan,
					hasRealphoto: !!mapData.realphoto,
					floorplanSize: mapData.floorplan ? `${Math.round(mapData.floorplan.length / 1024)}KB` : 'None',
					realphotoSize: mapData.realphoto ? `${Math.round(mapData.realphoto.length / 1024)}KB` : 'None'
				});
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				
				const result = await response.json();
				console.log('📨 Sheets response:', result);
				
				if (result.success) {
					showNotification('✅ บันทึกไป Google Sheets สำเร็จ', 'success');
					
					// เก็บ backup local ด้วย
					localStorage.setItem('currentMap', JSON.stringify(mapData));
					
					return { success: true, method: 'sheets' };
				} else {
					throw new Error(result.error || 'Unknown sheets error');
				}
				
			} catch (error) {
				console.error('❌ Sheets save error:', error);
				
				// Universal fallback - เก็บ local เสมอ
				if (Environment.isLocalPC) {
					localStorage.setItem('currentMap', JSON.stringify(mapData));
				} else {
					localStorage.setItem('currentMap', JSON.stringify(mapData));
					await saveToServerIfAvailable(mapData);
				}
				
				showNotification(`⚠️ บันทึกในเครื่องแทน: ${error.message}`, 'warning');
				return { success: true, method: 'local' };
			}
		}

		async function saveToServerIfAvailable(mapData) {
			try {
				const response = await fetch('/api/maps/save', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(mapData)
				});
				
				if (response.ok) {
					console.log('✅ Backup saved to server');
				}
			} catch {
				console.log('📝 Server backup not available');
			}
		}

		// 10. ✅ Universal Initialization 
		document.addEventListener('DOMContentLoaded', function() {
			console.log('🚀 เริ่มต้นระบบ Universal...');
			
			// ตรวจสอบและตั้งค่า environment
			Environment.init();
			
			// ตั้งค่า Image Inputs
			setupImageInput('floorplanFileInput', 'floorplan');
			setupImageInput('realphotoFileInput', 'realphoto');
			
			// โหลดการตั้งค่า Google Sheets จาก localStorage
			loadSheetsConfigFromStorage();
			
			// ⭐ สำคัญ: ต้องรอให้ระบบพร้อมก่อนโหลดข้อมูล
			setTimeout(() => {
				// ตรวจสอบการเชื่อมต่อต่างๆ แล้วค่อยโหลดข้อมูล
				initializeConnections().then(() => {
					// โหลดข้อมูลหลังจากการเชื่อมต่อเสร็จแล้ว
					loadMapsTable();
				});
			}, 1500); // รอ 1.5 วินาที ให้ระบบพร้อม
	 
		});

		function setupImageInput(inputId, imageType) {
			const input = document.getElementById(inputId);
			if (input) {
				input.addEventListener('change', async (e) => {
					const file = e.target.files[0];
					if (file) {
						await handleImageFile(file, imageType);
					}
				});
			}
		}

		// 4. ✅ Enhanced loadSavedImages ที่ validate ข้อมูลก่อน
		function loadSavedImages() { 
			
			// โหลดและ validate floorplan
			const floorplan = sessionStorage.getItem('temp_floorplan');
			if (floorplan && isValidImageData(floorplan)) {
				updateImagePreview('floorplanPreview', floorplan, 'floorplan');
				sessionStorage.setItem('floorplan_uploaded', 'true');
				 
			} else {
				if (floorplan) {
					console.warn('⚠️ Invalid floorplan data found, cleaning up:', floorplan);
					cleanupInvalidImageData('floorplan');
				}
				resetImagePreview('floorplanPreview', 'floorplan');
			}
			
			// โหลดและ validate realphoto
			const realphoto = sessionStorage.getItem('temp_realphoto');
			if (realphoto && isValidImageData(realphoto)) {
				updateImagePreview('realphotoPreview', realphoto, 'realphoto');
				sessionStorage.setItem('realphoto_uploaded', 'true');
				console.log('✅ Real photo loaded and validated');
			} else {
				if (realphoto) {
					console.warn('⚠️ Invalid realphoto data found, cleaning up:', realphoto);
					cleanupInvalidImageData('realphoto');
				}
				resetImagePreview('realphotoPreview', 'realphoto');
			}
		}
		
		// 5. ✅ Function สำหรับ validate image data ปรับฟังก์ชัน isValidImageData() ให้รองรับ Google Sheets
		function isValidImageData(data) {
			if (!data || typeof data !== 'string') return false;
			
			const trimmedData = data.trim();
			if (trimmedData === '') return false;
			
			// ⚠️ เปลี่ยนการตรวจสอบ "available" flag
			if (trimmedData.toLowerCase() === 'available') {
				console.log('📋 Found "available" flag - will attempt to load from sheets');
				return 'pending'; // ส่งกลับ 'pending' แทน false
			}
			
			// ตรวจสอบ invalid values อื่นๆ
			const invalidValues = ['none', 'null', 'undefined', 'error'];
			if (invalidValues.includes(trimmedData.toLowerCase())) return false;
			
			// ตรวจสอบรูปแบบที่ support
			if (trimmedData.startsWith('data:image/')) return true;
			if (trimmedData.startsWith('http://') || trimmedData.startsWith('https://')) return true;
			if (Environment.isWebServer && (trimmedData.startsWith('./') || trimmedData.startsWith('../'))) return true;
			
			return false;
		}
		
		// 🔧 แก้ไข 3: เพิ่มฟังก์ชัน handlePendingImages() สำหรับโหลดรูป "available"
		async function handlePendingImages() {
			console.log('🔄 Checking for pending images from Google Sheets...');
			
			try {
				if (!sheetsConfig.url) {
					console.log('❌ No Google Sheets URL configured');
					return;
				}

				// ส่งคำขอดึงข้อมูลรูปภาพจาก Google Sheets
				const params = new URLSearchParams();
				params.append('action', 'getMapImages');
				params.append('mapId', 'main_map');

				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});

				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}

				const result = await response.json();
				console.log('🖼️ Map images response:', result);

				if (result.success && result.data) {
					const mapData = result.data;
					
					// โหลด floorplan ถ้าเป็น "available"
					if (mapData.floorplan && mapData.floorplan !== 'available') {
						console.log('📐 Loading floorplan from sheets...');
						updateImagePreview('floorplanPreview', mapData.floorplan, 'floorplan'); 
					}
					
					// โหลด realphoto ถ้าเป็น "available"
					if (mapData.realphoto && mapData.realphoto !== 'available') {
						console.log('📷 Loading realphoto from sheets...');
						updateImagePreview('realphotoPreview', mapData.realphoto, 'realphoto'); 
					}

					showNotification('✅ โหลดรูปภาพจาก Google Sheets สำเร็จ', 'success');
					 // 🆕 เพิ่ม badge หลังจากโหลดเสร็จแล้ว  
					setTimeout(() => {
						addLoadedFromSheetsBadge(); // 🔧 ใช้ฟังก์ชันที่ถูกต้อง
					}, 500);
				}

			} catch (error) {
				console.error('❌ Failed to load pending images:', error);
				// ไม่แสดง notification error เพื่อไม่รบกวนผู้ใช้
			}
		}

		// 3. ✅ ปรับปรุงฟังก์ชัน initializeConnections ให้รอการเชื่อมต่อ
		async function initializeConnections() {
			try {
				console.log('🔗 Initializing connections...');
				
				// ทดสอบการเชื่อมต่อ Google Sheets เสมอ
				let sheetsOk = false;
				if (sheetsConfig.url) {
					sheetsOk = await testSheetsConnection();
				}
				
				// ทดสอบ Server APIs เฉพาะ Web Server
				let serverOk = false;
				if (!Environment.isLocalPC) {
					serverOk = await testServerAPIs();
				} else {
					console.log('🏠 Local PC - skipping server API test');
				}
				
				console.log('🔗 Connection results:', { sheetsOk, serverOk, environment: Environment.getType() });
				
				return sheetsOk || serverOk; // สำเร็จถ้าเชื่อมต่อได้อย่างน้อยหนึ่งระบบ
				
			} catch (error) {
				console.warn('⚠️ Some connections failed:', error);
				return false;
			}
		}
		
		// 4. ✅ เพิ่มฟังก์ชันสำหรับบังคับโหลดข้อมูลใหม่
		async function forceRefreshMaps() { 
		
		// ลบข้อมูลชั่วคราวใน session
		sessionStorage.removeItem('temp_floorplan');
		sessionStorage.removeItem('temp_realphoto');
		sessionStorage.removeItem('floorplan_uploaded');
		sessionStorage.removeItem('realphoto_uploaded');
		
		// รีเซ็ต preview
		resetImagePreview('floorplanPreview', 'floorplan');
		resetImagePreview('realphotoPreview', 'realphoto');
		
		// โหลดข้อมูลใหม่จาก Google Sheets (รวม pending images)
		setTimeout(async () => {
			await loadExistingMaps();
			await handlePendingImages(); // เพิ่มการโหลด pending images
		}, 500);
		
		showNotification('🔄 กำลังรีเฟรชข้อมูลจาก Google Sheets...', 'info');
	}

		
		
		// 7. ✅ Updated Universal Initialization
		document.addEventListener('DOMContentLoaded', function() {
			console.log('🚀 เริ่มต้นระบบ Universal...');
			
			// ตรวจสอบและตั้งค่า environment
			Environment.init();
			
			// ตั้งค่า Image Inputs
			setupImageInput('floorplanFileInput', 'floorplan');
			setupImageInput('realphotoFileInput', 'realphoto');
			
			// ตรวจสอบการเชื่อมต่อต่างๆ
			initializeConnections();
			
			// เริ่มต้นระบบ maps
			initializeUniversalMaps();
			
			console.log(`✅ ระบบ Universal พร้อมใช้งาน (${Environment.getType()})`);
		});

		// 8. ✅ Connection testing with proper error handling
		async function testSheetsConnection() {
			if (!sheetsConfig.url) {
				console.log(`📝 ไม่มีการตั้งค่า Google Sheets - ใช้งานแบบ Local เท่านั้น (${Environment.getType()})`);
				return;
			}
			
			try {
				console.log('🔗 Testing Google Sheets connection...');
				
				const params = new URLSearchParams();
				params.append('action', 'getMapImages'); // ใช้ action ที่มีอยู่จริง
				params.append('environment', Environment.getType());
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.success !== false) { // รับทั้ง success: true และไม่มี success field
						sheetsConfig.connected = true;
						console.log(`✅ เชื่อมต่อ Google Sheets สำเร็จ (${Environment.getType()})`);
						return true;
					}
				}
				
				throw new Error(`Connection test failed: ${response.status}`);
				
			} catch (error) {
				sheetsConfig.connected = false;
				console.log(`📝 ใช้งานแบบ Local เท่านั้น (${Environment.getType()}): ${error.message}`);
				return false;
			}
		}
		
		// 9. ✅ Manual refresh function
		async function refreshMapsFromSheets() {
			showNotification('🔄 กำลังรีเฟรชข้อมูลจาก Google Sheets...', 'info');
			
			// ล้าง session storage
			sessionStorage.removeItem('temp_floorplan');
			sessionStorage.removeItem('temp_realphoto');
			sessionStorage.removeItem('floorplan_uploaded');
			sessionStorage.removeItem('realphoto_uploaded');
			
			// ล้าง previews
			const floorplanPreview = document.getElementById('floorplanPreview');
			const realphotoPreview = document.getElementById('realphotoPreview');
			if (floorplanPreview) floorplanPreview.innerHTML = '';
			if (realphotoPreview) realphotoPreview.innerHTML = '';
			
			// โหลดใหม่
			await loadExistingMaps();
			
			showNotification('✅ รีเฟรชข้อมูลเสร็จสิ้น', 'success');
		}		

		// 🔧 แก้ไข 1: ปรับฟังก์ชัน testServerAPIs() ให้รองรับ Environment
		async function testServerAPIs() {
			try {
				// ⚠️ ตรวจสอบ Environment ก่อน - หลีกเลี่ยง CORS บน Local PC
				if (Environment.isLocalPC) {
					console.log('🏠 Local PC detected - skipping server API test');
					Environment.serverAPIs = false;
					return false;
				}

				// เฉพาะ Web Server ถึงจะทดสอบ APIs
				const response = await fetch('/api/status', {
					method: 'GET',
					headers: { 'Accept': 'application/json' }
				});
				
				if (response.ok) {
					console.log('✅ Server APIs available');
					Environment.serverAPIs = true;
					return true;
				} else {
					throw new Error(`Server returned ${response.status}`);
				}
			} catch (error) {
				console.log(`📟 Server APIs not available: ${error.message}`);
				Environment.serverAPIs = false;
				return false;
			}
		}

		// 5. ✅ Universal saveMapImages - แทนที่ของเดิม
		async function saveMapImages() {
			try {
				console.log('💾 Starting universal saveMapImages...');
				showNotification('💾 กำลังบันทึกแผนที่...', 'info');
				
				const floorplan = sessionStorage.getItem('temp_floorplan');
				const realphoto = sessionStorage.getItem('temp_realphoto');
				const notes = document.getElementById('mapNotes')?.value || '';
				
				if (!floorplan && !realphoto) {
					showNotification('⚠️ กรุณาเลือกรูปภาพก่อนบันทึก', 'warning');
					return;
				}
				
				const mapData = {
					id: 'main_map', // ใช้ fixed ID
					floorplan: floorplan || '',
					realphoto: realphoto || '',
					notes: notes,
					timestamp: new Date().toISOString(),
					environment: Environment.getType(),
					method: Environment.storageMethod
				};
				
				console.log('📋 Saving map data:', {
					hasFloorplan: !!mapData.floorplan,
					hasRealphoto: !!mapData.realphoto,
					floorplanSize: mapData.floorplan ? `${Math.round(mapData.floorplan.length / 1024)}KB` : 'None',
					realphotoSize: mapData.realphoto ? `${Math.round(mapData.realphoto.length / 1024)}KB` : 'None',
					environment: mapData.environment
				});
				
				const result = await saveMapToSheets(mapData);
				
				if (result.success) {
					const methodText = result.method === 'sheets' ? 'Google Sheets' : 
									  result.method === 'server' ? 'Server' : 'ในเครื่อง';
					showNotification(`✅ บันทึกแผนที่สำเร็จ (${methodText}) - ${Environment.getType()}`, 'success');
					
					// อัปเดต UI
					if (typeof updateMapFormsAfterSave === 'function') {
						updateMapFormsAfterSave();
					}
				}
				
			} catch (error) {
				console.error('❌ Save error:', error);
				showNotification(`❌ ไม่สามารถบันทึกได้: ${error.message}`, 'error');
			}
		}		 
		 
		 // 6. ✅ Auto-load ใน initialization
		function initializeUniversalMaps() {
			console.log('🗺️ Initializing universal maps system...');
			
			// เรียก loadExistingMaps หลังจาก environment setup
			setTimeout(async () => {
				await loadExistingMaps();
			}, 1000);
		}
			  
		// =================== Utility Functions  ===================

		function formatDateTime(isoString) {
			if (!isoString) return 'N/A';
			
			try {
				const date = new Date(isoString);
				return date.toLocaleString('th-TH', {
					year: 'numeric',
					month: 'short',
					day: 'numeric',
					hour: '2-digit',
					minute: '2-digit'
				});
			} catch (error) {
				return 'Invalid Date';
			}
		}
				
				
		// =================== Safe Element Access Functions ===================

		function safeGetElement(elementId) {
			const element = document.getElementById(elementId);
			if (!element) {
				console.warn(`⚠️ Element '${elementId}' not found`);
				return null;
			}
			return element;
		}

		function safeSetInnerHTML(elementId, content) {
			const element = safeGetElement(elementId);
			if (element) {
				element.innerHTML = content;
				return true;
			}
			return false;
		}	


		// =================== Interactive Map Picker JavaScript ===================
	
		// Global variables for room map picker
		let roomMapPicker = {
			currentX: 0,
			currentY: 0,
			zoomLevel: 1,
			gridVisible: false,
			mapContainer: null,
			marker: null,
			isDragging: false,
			hasFloorplan: false,
			buildingCode: ''
		};

		// =================== Core Map Picker Functions ===================

		 function initializeRoomMapPicker() {
			console.log('🗺️ Initializing Room Map Picker...');
			
			roomMapPicker.mapContainer = document.getElementById('roomMapContainer');
			roomMapPicker.marker = document.getElementById('roomPositionMarker');
			
			if (roomMapPicker.mapContainer) {
				setupRoomMapEventListeners();
				updateRoomCoordinateDisplay();
				console.log('✅ Room Map Picker initialized');
				return true;
			} else {
				console.warn('⚠️ Room Map Container not found');
				return false;
			}
		}

		function setupRoomMapEventListeners() {
			const container = roomMapPicker.mapContainer;
			if (!container) return;

			// Remove existing listeners to prevent duplicates
			container.removeEventListener('click', selectRoomPosition);
			container.removeEventListener('mousemove', showRoomPreviewPosition);
			container.removeEventListener('mouseleave', hideRoomPreviewPosition);

			// Add new listeners
			container.addEventListener('click', selectRoomPosition);
			container.addEventListener('mousemove', showRoomPreviewPosition);
			container.addEventListener('mouseleave', hideRoomPreviewPosition);

			// Touch events for mobile
			container.addEventListener('touchstart', handleRoomTouchStart, { passive: false });
			container.addEventListener('touchmove', handleRoomTouchMove, { passive: false });
			container.addEventListener('touchend', handleRoomTouchEnd, { passive: false });

			// Prevent context menu
			container.addEventListener('contextmenu', (e) => e.preventDefault());
		}

		function selectRoomPosition(event) {
			event.preventDefault();
			event.stopPropagation();
			
			const rect = roomMapPicker.mapContainer.getBoundingClientRect();
			const x = ((event.clientX - rect.left) / rect.width) * 100;
			const y = ((event.clientY - rect.top) / rect.height) * 100;
			
			setRoomPosition(x, y);
			animateRoomMarkerSelection();
			
			console.log(`📍 Room position selected: X=${x.toFixed(1)}, Y=${y.toFixed(1)}`);
		}

		function setRoomPosition(x, y) {
			// Constrain to map bounds
			roomMapPicker.currentX = Math.max(0, Math.min(100, x));
			roomMapPicker.currentY = Math.max(0, Math.min(100, y));
			
			// Update marker position
			updateRoomMarkerPosition();
			
			// Update form inputs
			updateRoomInputValues();
			
			// Update displays
			updateRoomCoordinateDisplay();
			
			// Show marker
			if (roomMapPicker.marker) {
				roomMapPicker.marker.style.display = 'block';
			}
		}

		function updateRoomMarkerPosition() {
			if (!roomMapPicker.marker || !roomMapPicker.mapContainer) return;
			
			roomMapPicker.marker.style.left = roomMapPicker.currentX + '%';
			roomMapPicker.marker.style.top = roomMapPicker.currentY + '%';
		}

		function updateRoomInputValues() {
			const xInput = document.getElementById('roomX');
			const yInput = document.getElementById('roomY');
			
			if (xInput) xInput.value = roomMapPicker.currentX.toFixed(1);
			if (yInput) yInput.value = roomMapPicker.currentY.toFixed(1);
		}

		function updateRoomCoordinateDisplay() {
			const display = document.getElementById('roomCoordinateDisplay');
			if (display) {
				display.textContent = `X: ${roomMapPicker.currentX.toFixed(1)}, Y: ${roomMapPicker.currentY.toFixed(1)}`;
			}
		}

		function updateRoomMarkerFromInput() {
			const xInput = document.getElementById('roomX');
			const yInput = document.getElementById('roomY');
			
			if (xInput && yInput) {
				const x = parseFloat(xInput.value) || 0;
				const y = parseFloat(yInput.value) || 0;
				
				if (x > 0 || y > 0) {
					setRoomPosition(x, y);
				} else {
					clearRoomPosition();
				}
			}
		}

		function clearRoomPosition() {
			roomMapPicker.currentX = 0;
			roomMapPicker.currentY = 0;
			
			// Hide marker
			if (roomMapPicker.marker) {
				roomMapPicker.marker.style.display = 'none';
			}
			
			// Update displays
			updateRoomCoordinateDisplay();
			
			console.log('🧹 Room position cleared');
		}

		// =================== Map Tools Functions ===================

		function animateRoomMarkerSelection() {
			if (!roomMapPicker.marker) return;
			
			// Add selection animation
			roomMapPicker.marker.style.animation = 'none';
			setTimeout(() => {
				roomMapPicker.marker.style.animation = 'markerPulse 2s infinite';
			}, 10);
		}

		// =================== Touch Event Handlers ===================

		function handleRoomTouchStart(event) {
			event.preventDefault();
			roomMapPicker.isDragging = true;
		}

		function handleRoomTouchMove(event) {
			if (!roomMapPicker.isDragging) return;
			event.preventDefault();
			
			const touch = event.touches[0];
			const rect = roomMapPicker.mapContainer.getBoundingClientRect();
			const x = ((touch.clientX - rect.left) / rect.width) * 100;
			const y = ((touch.clientY - rect.top) / rect.height) * 100;
			
			setRoomPosition(x, y);
		}

		function handleRoomTouchEnd(event) {
			event.preventDefault();
			roomMapPicker.isDragging = false;
			animateRoomMarkerSelection();
		}

		function showRoomPreviewPosition(event) {
			// Optional: Show preview marker on hover
		}

		function hideRoomPreviewPosition(event) {
			// Optional: Hide preview marker
		}
		
		
		// =================== Enhanced Integration (NO OVERRIDE) ===================

		// ✅ FIX: ใช้ MutationObserver แทนการ override function
		function setupRoomMapPickerIntegration() {
			console.log('🔧 Setting up Room Map Picker integration...');
			
			// Monitor for room modal opening
			const observer = new MutationObserver(function(mutations) {
				mutations.forEach(function(mutation) {
					if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
						const modal = document.getElementById('roomModal');
						if (modal && modal.style.display === 'block') {
							// Modal opened - initialize map picker
							setTimeout(() => {
								if (initializeRoomMapPicker()) {
									loadExistingRoomPosition();
								}
							}, 200);
						}
					}
				});
			});
			
			// Start observing room modal
			const roomModal = document.getElementById('roomModal');
			if (roomModal) {
				observer.observe(roomModal, { 
					attributes: true, 
					attributeFilter: ['style'] 
				});
				console.log('✅ Room modal observer active');
			}
		}

		function loadExistingRoomPosition() {
			try {
				// Check if we're in edit mode
				if (isEditMode && editingItemId && roomsData[editingItemId]) {
					const room = roomsData[editingItemId];
					if (room.x && room.y) {
						console.log(`📍 Loading existing position: X=${room.x}, Y=${room.y}`);
						setRoomPosition(parseFloat(room.x), parseFloat(room.y));
					}
					
					// Update building display
					if (room.building) {
						updateRoomMapBuilding(room.building);
					}
				}
			} catch (error) {
				console.warn('⚠️ Could not load existing room position:', error);
			}
		}

		// =================== Enhanced saveRoomForm Integration ===================

		// Store original saveRoomForm reference safely
		let originalSaveRoomFormRef = null;

		function initializeSaveRoomFormIntegration() {
			// Get reference to original function without overriding
			if (typeof saveRoomForm === 'function' && !originalSaveRoomFormRef) {
				originalSaveRoomFormRef = saveRoomForm;
				
				// Replace the function safely
				window.saveRoomForm = function(event) {
					event.preventDefault();
					
					try {
						const formData = {
							code: document.getElementById('roomCode').value.trim(),
							name: document.getElementById('roomName').value.trim(),
							building: document.getElementById('roomBuilding').value,
							floor: parseInt(document.getElementById('roomFloor').value),
							type: document.getElementById('roomType').value,
							status: document.getElementById('roomStatus').value,
							// ✅ ADD: Map picker coordinates
							x: roomMapPicker.currentX > 0 ? roomMapPicker.currentX : null,
							y: roomMapPicker.currentY > 0 ? roomMapPicker.currentY : null,
							description: document.getElementById('roomDescription').value.trim(),
							images: typeof collectImageUrls === 'function' ? collectImageUrls() : []
						};
						
						console.log('💾 Saving room with map coordinates:', {x: formData.x, y: formData.y});
						
						if (isEditMode && editingItemId) {
							updateRoom(editingItemId, formData);
						} else {
							createRoom(formData);
						}
						
						closeRoomModal();
						
					} catch (error) {
						console.error('❌ Save room form error:', error);
						showNotification('❌ ไม่สามารถบันทึกข้อมูลห้องได้', 'error');
					}
				};
				
				console.log('✅ saveRoomForm integration complete');
			}
		}

		// =================== Integration with Room Modal ===================

		// 🔧 แก้ไข openRoomModal() ให้โหลด image_urls ถูกต้อง
		function openRoomModal(code = null) {
			const modal = document.getElementById('roomModal');
			const title = document.getElementById('roomModalTitle');
			const form = document.getElementById('roomForm');
			
			// Reset form
			form.reset();
			
			// Populate building dropdown
			populateBuildingDropdown();
			
			// Reset image container
			resetImageUrlContainer();
			
			if (code) {
				// Edit mode
				isEditMode = true;
				editingItemId = code;
				title.textContent = 'แก้ไขห้อง';
				
				const room = roomsData[code];
				if (room) {
					document.getElementById('roomCode').value = room.code;
					document.getElementById('roomName').value = room.name;
					document.getElementById('roomBuilding').value = room.building;
					document.getElementById('roomFloor').value = room.floor || 1;
					document.getElementById('roomType').value = room.type || 'หห้องเรียน';
					document.getElementById('roomStatus').value = room.status || 'active';
					document.getElementById('roomX').value = room.x || '';
					document.getElementById('roomY').value = room.y || '';
					document.getElementById('roomDescription').value = room.description || '';
					
					// 🔧 แก้ไข: โหลด image URLs - รองรับทั้ง images และ image_urls
					const imageData = room.image_urls || room.images || [];
					console.log(`📋 Room ${code} image data:`, imageData);
					
					setTimeout(() => {
						loadExistingImages(imageData);
					}, 100);
					
					// Disable code editing in edit mode
					document.getElementById('roomCode').readOnly = true;
				}
			} else {
				// Add mode
				isEditMode = false;
				editingItemId = null;
				title.textContent = 'เพิ่มห้องใหม่';
				
				// Enable code editing in add mode
				document.getElementById('roomCode').readOnly = false;
				
				// Auto-generate code
				document.getElementById('roomCode').value = generateRoomCode();
			}
			
			modal.style.display = 'block';
			document.body.style.overflow = 'hidden';
		}

		// อัปเดต saveRoomForm function ให้รวม coordinates จาก map picker
		function saveRoomFormWithMap(event) {
			event.preventDefault();
			
			try {
				const formData = {
					code: document.getElementById('roomCode').value.trim(),
					name: document.getElementById('roomName').value.trim(),
					building: document.getElementById('roomBuilding').value,
					floor: parseInt(document.getElementById('roomFloor').value),
					type: document.getElementById('roomType').value,
					status: document.getElementById('roomStatus').value,
					x: roomMapPicker.currentX > 0 ? roomMapPicker.currentX : null,
					y: roomMapPicker.currentY > 0 ? roomMapPicker.currentY : null,
					description: document.getElementById('roomDescription').value.trim(),
					images: collectImageUrls()
				};
				
				if (isEditMode && editingItemId) {
					updateRoom(editingItemId, formData);
				} else {
					createRoom(formData);
				}
				
				closeRoomModal();
				
			} catch (error) {
				console.error('Save room form with map error:', error);
			}
		}

		// 2. Fix updateRoomMapBuilding function (แทนที่ฟังก์ชันเดิม)
		function updateRoomMapBuilding(buildingCode) {
			const buildingName = document.getElementById('currentBuildingName');
			if (buildingName && buildingsData && buildingsData[buildingCode]) {
				buildingName.textContent = buildingsData[buildingCode].name;
			}
			
			// Store building code for map picker
			roomMapPicker.buildingCode = buildingCode;
			
			console.log(`🏢 Building updated: ${buildingsData[buildingCode]?.name || buildingCode}`);
		}

		// 3. Fix openRoomModal integration (แทนที่ฟังก์ชันเดิม)
		let originalOpenRoomModal = null;

		function enhanceOpenRoomModal() {
			// Store original function reference
			if (typeof openRoomModal === 'function' && !originalOpenRoomModal) {
				originalOpenRoomModal = openRoomModal;
				
				// Replace with enhanced version
				window.openRoomModal = function(code = null) {
					console.log(`🚪 Opening room modal: ${code || 'new'}`);
					
					// Call original function
					if (originalOpenRoomModal) {
						originalOpenRoomModal.call(this, code);
					}
					
					// Initialize map system after modal opens
					setTimeout(() => {
						try {
							// Initialize room map picker
							if (initializeRoomMapPicker()) {
								console.log('✅ Room map picker initialized');
								
								// Initialize image upload system
								initializeMapImageSystem();
								
								// Load existing position if editing
								if (code && roomsData[code]) {
									const room = roomsData[code];
									
									// Load position
									if (room.x && room.y) {
										setRoomPosition(parseFloat(room.x), parseFloat(room.y));
									}
									
									// Load building floorplan
									if (room.building) {
										loadBuildingFloorplan(room.building);
									}
								}
							}
						} catch (error) {
							console.error('❌ Room modal enhancement error:', error);
						}
					}, 300);
				};
				
				console.log('✅ openRoomModal enhanced');
			}
		}

		// 4. Fix saveRoomForm integration (แทนที่ฟังก์ชันเดิม)
		let originalSaveRoomForm = null;

		function enhanceSaveRoomForm() {
			// Store original function reference
			if (typeof saveRoomForm === 'function' && !originalSaveRoomForm) {
				originalSaveRoomForm = saveRoomForm;
				
				// Replace with enhanced version
				window.saveRoomForm = function(event) {
					event.preventDefault();
					
					try {
						const formData = {
							code: document.getElementById('roomCode').value.trim(),
							name: document.getElementById('roomName').value.trim(),
							building: document.getElementById('roomBuilding').value,
							floor: parseInt(document.getElementById('roomFloor').value),
							type: document.getElementById('roomType').value,
							status: document.getElementById('roomStatus').value,
							// Add map coordinates
							x: roomMapPicker.currentX > 0 ? roomMapPicker.currentX : null,
							y: roomMapPicker.currentY > 0 ? roomMapPicker.currentY : null,
							description: document.getElementById('roomDescription').value.trim(),
							images: typeof collectImageUrls === 'function' ? collectImageUrls() : []
						};
						
						console.log('💾 Saving room with map coordinates:', {
							x: formData.x, 
							y: formData.y,
							building: formData.building
						});
						
						if (isEditMode && editingItemId) {
							updateRoom(editingItemId, formData);
						} else {
							createRoom(formData);
						}
						
						closeRoomModal();
						
					} catch (error) {
						console.error('❌ Enhanced save room form error:', error);
						showNotification('❌ ไม่สามารถบันทึกข้อมูลห้องได้', 'error');
					}
				};
				
				console.log('✅ saveRoomForm enhanced');
			}
		}

		// 5. Fix building dropdown integration
		function enhanceBuildingDropdown() {
			// Remove existing listener to prevent duplicates
			document.removeEventListener('change', handleBuildingChange);
			
			// Add new enhanced listener
			document.addEventListener('change', handleBuildingChange);
			
			console.log('✅ Building dropdown enhanced');
		}

		function handleBuildingChange(e) {
			if (e.target && e.target.id === 'roomBuilding') {
				const buildingCode = e.target.value;
				console.log(`🏢 Building selected: ${buildingCode}`);
				
				if (buildingCode) {
					updateRoomMapBuilding(buildingCode);
					loadBuildingFloorplan(buildingCode);
				} else {
					showPlaceholderMap();
				}
			}
		}

		// 6. Complete initialization function
		function initializeEnhancedMapPicker() {
			console.log('🗺️ Initializing Enhanced Map Picker...');
			
			try {
				// Enhance existing functions
				enhanceOpenRoomModal();
				enhanceSaveRoomForm();
				enhanceBuildingDropdown();
				
				console.log('✅ Enhanced Map Picker initialized successfully');
				return true;
			} catch (error) {
				console.error('❌ Enhanced Map Picker initialization failed:', error);
				return false;
			}
		}

		// 7. Auto-initialize when admin panel is ready
		function initializeMapPickerWhenReady() {
			// Wait for admin panel to be fully loaded
			if (typeof isLoggedIn !== 'undefined' && isLoggedIn) {
				initializeEnhancedMapPicker();
			} else {
				// Retry after 1 second
				setTimeout(initializeMapPickerWhenReady, 1000);
			}
		}

		// 8. Start initialization process
		document.addEventListener('DOMContentLoaded', function() {
			setTimeout(() => {
				console.log('🎯 Starting Enhanced Map Picker initialization...');
				initializeMapPickerWhenReady();
			}, 2000);
		});

		// 9. Backup initialization for late loading
		window.addEventListener('load', function() {
			setTimeout(() => {
				if (typeof initializeEnhancedMapPicker === 'function') {
					initializeEnhancedMapPicker();
					console.log('🔄 Backup Enhanced Map Picker initialization complete');
				}
			}, 3000);
		});
		// =================== INTEGRATION FIXES ===================

		// 1. Fix loadBuildingFloorplan function (แทนที่ฟังก์ชันเดิม)
		function loadBuildingFloorplan(buildingCode) {
			console.log(`🏢 Loading floorplan for building: ${buildingCode}`);
			
			if (!buildingCode) {
				showPlaceholderMap();
				return;
			}
			
			// Update building info first
			updateRoomMapBuilding(buildingCode);
			
			// Load from Google Sheets
			loadFloorplanFromSheets(buildingCode);
		}

		// Initialize when modal opens
		function initializeMapImageSystem() {
			try {
				initializeImageUpload();
				console.log('✅ Map Image System initialized');
			} catch (error) {
				console.error('❌ Map Image System initialization error:', error);
			}
		}
		
		// 🔧 แก้ไข 8: ปรับ enhanceRoomModalIntegration() ให้ใช้แผนที่จาก initial load
		function enhanceRoomModalIntegration() {
			const originalOpenRoomModal = window.openRoomModal;
			
			window.openRoomModal = function(code = null) {
				// Call original function
				if (originalOpenRoomModal) {
					originalOpenRoomModal.call(this, code);
				} else {
					// ใช้ฟังก์ชันใหม่ที่แก้ไขแล้ว
					openRoomModal(code);
				}
				
				// Initialize map system after modal opens
				setTimeout(() => {
					initializeMapImageSystem();
					
					// 🔧 แก้ไข: ใช้แผนที่จาก initial load เสมอ ไม่ต้องหาเฉพาะอาคาร
					if (code && roomsData[code] && roomsData[code].building) {
						const buildingCode = roomsData[code].building;
						console.log(`🏢 Opening room modal for building: ${buildingCode}`);
						
						// โหลดแผนที่ (จะใช้จาก session/localStorage)
						loadFloorplanFromSheets(buildingCode);
						
						// โหลด room images
						loadRoomImageUrls(code);
					} else {
						// สำหรับ add mode - โหลดแผนที่ทั่วไป
						loadFloorplanFromSheets('general');
					}
				}, 200);
			};
			
			console.log('✅ Enhanced room modal integration with initial maps');
		}

		// Auto-initialize when document ready
		document.addEventListener('DOMContentLoaded', function() {
			setTimeout(() => {
				enhanceRoomModalIntegration();
				console.log('🗺️ Enhanced Map Picker with Google Sheets & Upload ready');
			}, 1000);
		});
		
		// =================== Event Listeners ===================

		// Building dropdown change handler
		document.addEventListener('change', function(e) {
			if (e.target && e.target.id === 'roomBuilding') {
				const buildingCode = e.target.value;
				updateRoomMapBuilding(buildingCode);
				loadBuildingFloorplan(buildingCode);
			}
		});
		
		// ✅ เพิ่ม Event Listener สำหรับโหลด Maps เมื่อเปลี่ยนไปแท็บ Maps
		function enhanceNavigationWithMaps() {
			// เก็บ reference ของฟังก์ชัน showSection เดิม
			const originalShowSection = window.showSection;
			
			// สร้างฟังก์ชัน showSection ใหม่ที่รวม Maps loading
			window.showSection = function(sectionId) {
				// เรียกฟังก์ชันเดิม
				if (originalShowSection) {
					originalShowSection.call(this, sectionId);
				}
				
				// โหลด Maps เมื่อเข้าแท็บ Maps
				if (sectionId === 'maps') {
					setTimeout(() => {
						console.log('🗺️ Loading Maps for Maps section...');
						initializeMapsModule();
					}, 500);
				}
			};
		}
		// Update the building dropdown change handler
		document.addEventListener('change', function(e) {
			if (e.target && e.target.id === 'roomBuilding') {
				const buildingCode = e.target.value;
				updateRoomMapBuilding(buildingCode);
				loadBuildingFloorplan(buildingCode);
			}
		});



		// =================== Utility Functions ===================

		//function getRoomMapPickerValues() {
		//	return {
		//		x: roomMapPicker.currentX,
		//		y: roomMapPicker.currentY,
		//		hasPosition: roomMapPicker.currentX > 0 || roomMapPicker.currentY > 0,
		//		building: roomMapPicker.buildingCode
		//	};
		//}

		//function setRoomMapPickerValues(x, y, buildingCode = '') {
		//	if (x && y) {
		//		setRoomPosition(parseFloat(x), parseFloat(y));
		//	}	
		//	if (buildingCode) {
		//		updateRoomMapBuilding(buildingCode);
		//		loadBuildingFloorplan(buildingCode);
		//	}
		//}

		//function resetRoomMapPicker() {
		//	clearRoomPosition(); 
		//	roomMapPicker.gridVisible = false;	
		//	const gridOverlay = document.getElementById('roomGridOverlay');
		//	if (gridOverlay) {
		//		gridOverlay.classList.remove('show');
		//	}	
		//}
		
		// =================== Safe Initialization ===================

		// ✅ SAFE: Initialize when DOM is ready without overriding
		document.addEventListener('DOMContentLoaded', function() {
			// Wait for admin panel to be ready
			setTimeout(() => {
				try {
					setupRoomMapPickerIntegration();
					initializeSaveRoomFormIntegration();
					console.log('✅ Room Map Picker integration ready (safe mode)');
				} catch (error) {
					console.error('❌ Room Map Picker integration error:', error);
				}
			}, 1000);
		});	
		

		// ✅ SAFE: Also initialize after admin initialization
		window.addEventListener('load', function() {
			setTimeout(() => {
				try {
					if (typeof isLoggedIn !== 'undefined' && isLoggedIn) {
						setupRoomMapPickerIntegration();
						initializeSaveRoomFormIntegration();
						console.log('✅ Room Map Picker late initialization complete');
					}
				} catch (error) {
					console.warn('⚠️ Late initialization warning:', error);
				}
			}, 2000);
		});		
				

		// ========== Core Management Functions ==========

		// เพิ่มหน้าจัดการ Walkable Points
		function addWalkablePointsSection() {
			const mapsSection = document.getElementById('maps-section');
			if (!mapsSection) return;
			
			const walkableSection = document.createElement('div');
			walkableSection.className = 'walkable-section';
			walkableSection.innerHTML = `
				 
				
				<div class="walkable-stats" id="walkableStats">
					<div class="stat-card">
						<div class="stat-value" id="nodesCount">0</div>
						<div class="stat-label">จุดเดิน</div>
					</div>
					<div class="stat-card">
						<div class="stat-value" id="edgesCount">0</div>
						<div class="stat-label">เชื่อมโยง</div>
					</div>
					<div class="stat-card">
						<div class="stat-value" id="avgDistance">0m</div>
						<div class="stat-label">ระยะเฉลี่ย</div>
					</div>
					<div class="stat-card">
						<div class="stat-value" id="coveragePercent">0%</div>
						<div class="stat-label">ความครอบคลุม</div>
					</div>
				</div>
				
				<div class="walkable-controls">
				<!--
					<button class="walkable-btn" onclick="addWalkableNode()">
						<i class="fas fa-plus"></i> เพิ่มจุดเดิน
					</button>
				-->
					<button class="walkable-btn secondary" onclick="generateAutoNodes()">
						<i class="fas fa-magic"></i> สร้างอัตโนมัติ
					</button>
					<button class="walkable-btn secondary" onclick="connectSelectedNodes()">
						<i class="fas fa-link"></i> เชื่อมโยง
					</button>
					<button class="walkable-btn danger" onclick="deleteSelectedNodes()">
						<i class="fas fa-trash"></i> ลบจุดที่เลือก
					</button>
					<button class="walkable-btn" onclick="optimizeConnections()">
						<i class="fas fa-cogs"></i> ปรับปรุงเชื่อมโยง
					</button>
					<button class="walkable-btn success" onclick="saveWalkableData()">
						<i class="fas fa-save"></i> บันทึก
					</button>
				</div>
				
				<div class="walkable-settings">
					<div class="setting-group">
						<div class="setting-label">ระยะเชื่อมโยงสูงสุด</div>
						<input type="number" class="setting-input" id="maxDistance" value="25" min="10" max="50">
						<div class="setting-help">ระยะสูงสุดที่จุดจะเชื่อมโยงกันอัตโนมัติ (%)</div>
					</div>
					<div class="setting-group">
						<div class="setting-label">เมตรต่อเปอร์เซ็นต์</div>
						<input type="number" class="setting-input" id="metersPerPercent" value="1.2" step="0.1" min="0.5" max="5">
						<div class="setting-help">อัตราส่วนการแปลงเปอร์เซ็นต์เป็นเมตร</div>
					</div>
					<div class="setting-group">
						<div class="setting-label">เชื่อมโยงอัตโนมัติ</div>
						<select class="setting-input" id="autoConnect">
							<option value="true">เปิด</option>
							<option value="false">ปิด</option>
						</select>
						<div class="setting-help">เชื่อมโยงจุดใหม่กับจุดใกล้เคียงอัตโนมัติ</div>
					</div>
					<div class="setting-group">
						<div class="setting-label">แนบกริด</div>
						<select class="setting-input" id="snapToGrid">
							<option value="false">ปิด</option>
							<option value="true">เปิด</option>
						</select>
						<div class="setting-help">จัดจุดให้ตรงกับเส้นกริด</div>
					</div>
				</div>
				
				<div class="walkable-map-container" id="walkableMapContainer">
					<div class="walkable-overlay" id="walkableOverlay"></div>
				</div>
				<!--
				<div class="export-section">
					<h4><i class="fas fa-download"></i> Export/Import ข้อมูลจุดเดิน</h4>
					<textarea class="export-textarea" id="walkableExportData" placeholder="ข้อมูล JSON จะแสดงที่นี่..."></textarea>
					<div style="margin-top: 10px; display: flex; gap: 10px;">
						<button class="walkable-btn" onclick="exportWalkableData()">
							<i class="fas fa-download"></i> Export
						</button>
						<button class="walkable-btn secondary" onclick="importWalkableData()">
							<i class="fas fa-upload"></i> Import
						</button>
						<button class="walkable-btn secondary" onclick="copyWalkableData()">
							<i class="fas fa-copy"></i> Copy
						</button>
					</div>
				</div>
				-->
			`;
			
			// เพิ่มก่อน export section ใน maps
			const exportSection = mapsSection.querySelector('.export-section');
			if (exportSection) {
				mapsSection.insertBefore(walkableSection, exportSection);
			} else {
				mapsSection.appendChild(walkableSection);
			}
			
			// เริ่มต้นระบบ
			initializeWalkablePointsSystem();
		}

		// เริ่มต้นระบบจัดการจุดเดิน
		function initializeWalkablePointsSystem() {
			console.log('🚶 Initializing Walkable Points Management System...');
			
			// โหลด settings
			loadWalkableSettings();
			
			// ตั้งค่า event listeners
			setupWalkableEventListeners();
			
			// โหลดข้อมูลสำหรับอาคารปัจจุบัน
			const currentBuilding = getCurrentSelectedBuilding();
			if (currentBuilding) {
				loadWalkableDataForBuilding(currentBuilding);
			}
			
			console.log('✅ Walkable Points Management System initialized');
		}

		// ตั้งค่า Event Listeners
		function setupWalkableEventListeners() {
			const mapContainer = document.getElementById('walkableMapContainer');
			if (!mapContainer) return;
			
			// Click เพื่อเพิ่มจุด
			mapContainer.addEventListener('click', handleMapClick);
			
			// Settings change listeners
			document.getElementById('maxDistance')?.addEventListener('change', updateSettings);
			document.getElementById('metersPerPercent')?.addEventListener('change', updateSettings);
			document.getElementById('autoConnect')?.addEventListener('change', updateSettings);
			document.getElementById('snapToGrid')?.addEventListener('change', updateSettings);
		}

		// จัดการการคลิกบนแผนที่
		function handleMapClick(event) {
			const rect = event.currentTarget.getBoundingClientRect();
			const x = ((event.clientX - rect.left) / rect.width) * 100;
			const y = ((event.clientY - rect.top) / rect.height) * 100;
			
			// ตรวจสอบว่าคลิกบนจุดที่มีอยู่หรือไม่
			const clickedNode = findNodeAtPosition(x, y, 2); // tolerance 2%
			
			if (clickedNode) {
				toggleNodeSelection(clickedNode.id);
			} else {
				// เพิ่มจุดใหม่
				addWalkableNodeAt(x, y);
			}
		}

		// เพิ่มจุดเดินใหม่ที่ตำแหน่งที่กำหนด
		function addWalkableNodeAt(x, y) {
			// จัดให้ตรงกับกริดถ้าเปิดใช้
			if (walkablePointsData.settings.snapToGrid) {
				const gridSize = walkablePointsData.settings.gridSize;
				x = Math.round(x / gridSize) * gridSize;
				y = Math.round(y / gridSize) * gridSize;
			}
			
			// สร้าง ID ใหม่
			const nodeId = Date.now().toString();
			
			// เพิ่มจุดใหม่
			walkablePointsData.nodes[nodeId] = {
				id: nodeId,
				x: x,
				y: y,
				building: walkablePointsData.currentBuilding
			};
			
			// เชื่อมโยงอัตโนมัติถ้าเปิดใช้
			if (walkablePointsData.settings.autoConnect) {
				autoConnectNode(nodeId);
			}
			
			// อัพเดทการแสดงผล
			renderWalkablePoints();
			updateWalkableStats();
			
			console.log('Added walkable node:', nodeId, 'at', x, y);
		}

		// เชื่อมโยงจุดอัตโนมัติ
		function autoConnectNode(nodeId) {
			const node = walkablePointsData.nodes[nodeId];
			const maxDistance = walkablePointsData.settings.maxConnectionDistance;
			
			Object.values(walkablePointsData.nodes).forEach(otherNode => {
				if (otherNode.id === nodeId) return;
				
				const distance = calculateDistance(node, otherNode);
				
				if (distance <= maxDistance) {
					addEdgeIfNotExists(nodeId, otherNode.id, distance);
				}
			});
		}

		// คำนวณระยะทางระหว่างจุด
		function calculateDistance(nodeA, nodeB) {
			return Math.sqrt(
				Math.pow(nodeA.x - nodeB.x, 2) + 
				Math.pow(nodeA.y - nodeB.y, 2)
			);
		}

		// เพิ่ม edge ถ้ายังไม่มี
		function addEdgeIfNotExists(fromId, toId, distance) {
			const existingEdge = walkablePointsData.edges.find(edge => 
				(edge.from === fromId && edge.to === toId) ||
				(edge.from === toId && edge.to === fromId)
			);
			
			if (!existingEdge) {
				walkablePointsData.edges.push({
					from: fromId,
					to: toId,
					weight: distance * walkablePointsData.settings.metersPerPercent,
					bidirectional: true
				});
			}
		}

		// ========== Rendering Functions ==========

		// แสดงจุดเดินบนแผนที่
		function renderWalkablePoints() {
			const overlay = document.getElementById('walkableOverlay');
			if (!overlay) return;
			
			overlay.innerHTML = '';
			
			// สร้าง SVG สำหรับ edges
			const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.style.position = 'absolute';
			svg.style.top = '0';
			svg.style.left = '0';
			svg.style.width = '100%';
			svg.style.height = '100%';
			svg.setAttribute('viewBox', '0 0 100 100');
			svg.setAttribute('preserveAspectRatio', 'none');
			
			// แสดง edges
			walkablePointsData.edges.forEach(edge => {
				const fromNode = walkablePointsData.nodes[edge.from];
				const toNode = walkablePointsData.nodes[edge.to];
				
				if (fromNode && toNode) {
					const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
					line.setAttribute('x1', fromNode.x);
					line.setAttribute('y1', fromNode.y);
					line.setAttribute('x2', toNode.x);
					line.setAttribute('y2', toNode.y);
					line.setAttribute('class', 'walkable-edge');
					line.style.cursor = 'pointer';
					line.addEventListener('click', () => selectEdge(edge));
					svg.appendChild(line);
				}
			});
			
			overlay.appendChild(svg);
			
			// แสดง nodes
			Object.values(walkablePointsData.nodes).forEach(node => {
				const nodeElement = document.createElement('div');
				nodeElement.className = 'walkable-node';
				nodeElement.style.left = `${node.x}%`;
				nodeElement.style.top = `${node.y}%`;
				nodeElement.dataset.nodeId = node.id;
				
				if (walkablePointsData.selectedNodes.has(node.id)) {
					nodeElement.classList.add('selected');
				}
				
				// Event listeners
				nodeElement.addEventListener('click', (e) => {
					e.stopPropagation();
					toggleNodeSelection(node.id);
				});
				
				overlay.appendChild(nodeElement);
			});
		}

		// เลือก/ยกเลิกการเลือกจุด
		function toggleNodeSelection(nodeId) {
			if (walkablePointsData.selectedNodes.has(nodeId)) {
				walkablePointsData.selectedNodes.delete(nodeId);
			} else {
				walkablePointsData.selectedNodes.add(nodeId);
			}
			
			renderWalkablePoints();
			updateSelectionInfo();
		}

		// ========== Statistics and Info ==========

		// อัพเดทสถิติ
		function updateWalkableStats() {
			const nodesCount = Object.keys(walkablePointsData.nodes).length;
			const edgesCount = walkablePointsData.edges.length;
			
			// คำนวณระยะทางเฉลี่ย
			let totalDistance = 0;
			if (edgesCount > 0) {
				totalDistance = walkablePointsData.edges.reduce((sum, edge) => sum + edge.weight, 0);
			}
			const avgDistance = edgesCount > 0 ? (totalDistance / edgesCount).toFixed(1) : 0;
			
			// คำนวณความครอบคลุม (ประมาณ)
			const coveragePercent = Math.min(Math.round((nodesCount / 25) * 100), 100);
			
			// อัพเดท UI
			const nodesCountEl = document.getElementById('nodesCount');
			const edgesCountEl = document.getElementById('edgesCount');
			const avgDistanceEl = document.getElementById('avgDistance');
			const coveragePercentEl = document.getElementById('coveragePercent');
			
			if (nodesCountEl) nodesCountEl.textContent = nodesCount;
			if (edgesCountEl) edgesCountEl.textContent = edgesCount;
			if (avgDistanceEl) avgDistanceEl.textContent = avgDistance + 'm';
			if (coveragePercentEl) coveragePercentEl.textContent = coveragePercent + '%';
		}

		// ========== Advanced Functions ==========

		// สร้างจุดอัตโนมัติ
		function generateAutoNodes() {
			if (!confirm('สร้างจุดเดินอัตโนมัติ? จุดเดินเก่าจะถูกแทนที่')) return;
			
			// ล้างจุดเก่า
			walkablePointsData.nodes = {};
			walkablePointsData.edges = [];
			
			let nodeId = 1;
			
			// สร้าง grid pattern
			for (let x = 15; x <= 85; x += 20) {
				for (let y = 15; y <= 85; y += 20) {
					walkablePointsData.nodes[nodeId] = {
						id: nodeId.toString(),
						x: x,
						y: y,
						building: walkablePointsData.currentBuilding
					};
					nodeId++;
				}
			}
			
			// เพิ่มจุดใกล้ห้องต่างๆ
			if (window.roomsData) {
				window.roomsData.forEach(room => {
					if (room.building === walkablePointsData.currentBuilding) {
						const roomX = parseFloat(room.x);
						const roomY = parseFloat(room.y);
						
						// เพิ่มจุดรอบๆ ห้อง
						const nearbyPoints = [
							{x: roomX - 5, y: roomY},
							{x: roomX + 5, y: roomY}
						];
						
						nearbyPoints.forEach(point => {
							if (point.x >= 10 && point.x <= 90 && point.y >= 10 && point.y <= 90) {
								walkablePointsData.nodes[nodeId] = {
									id: nodeId.toString(),
									x: point.x,
									y: point.y,
									building: walkablePointsData.currentBuilding
								};
								nodeId++;
							}
						});
					}
				});
			}
			
			// เชื่อมโยงอัตโนมัติ
			optimizeConnections();
			
			renderWalkablePoints();
			updateWalkableStats();
			
			showNotification(`🎯 สร้างจุดเดิน ${Object.keys(walkablePointsData.nodes).length} จุด`, 'success');
		}

		// ปรับปรุงการเชื่อมโยง
		function optimizeConnections() {
			walkablePointsData.edges = [];
			
			const nodes = Object.values(walkablePointsData.nodes);
			const maxDistance = walkablePointsData.settings.maxConnectionDistance;
			
			for (let i = 0; i < nodes.length; i++) {
				for (let j = i + 1; j < nodes.length; j++) {
					const distance = calculateDistance(nodes[i], nodes[j]);
					
					if (distance <= maxDistance) {
						addEdgeIfNotExists(nodes[i].id, nodes[j].id, distance);
					}
				}
			}
			
			renderWalkablePoints();
			updateWalkableStats();
			
			showNotification(`🔗 สร้างการเชื่อมโยง ${walkablePointsData.edges.length} เส้น`, 'success');
		}

		// ========== Data Management ==========

		// บันทึกข้อมูล
		async function saveWalkableData() {
			try {
				const data = {
					building: walkablePointsData.currentBuilding,
					nodes: walkablePointsData.nodes,
					edges: walkablePointsData.edges,
					settings: walkablePointsData.settings,
					timestamp: new Date().toISOString()
				};
				
				// บันทึกใน localStorage
				const storageKey = `walkableData_${walkablePointsData.currentBuilding}`;
				localStorage.setItem(storageKey, JSON.stringify(data));
				
				// ส่งไปยัง Google Sheets (ถ้ามี)
				if (window.sheetsConfig && window.sheetsConfig.connected) {
					await saveWalkableDataToSheets(data);
				}
				
				showNotification('💾 บันทึกข้อมูลจุดเดินแล้ว', 'success');
				
			} catch (error) {
				console.error('Error saving walkable data:', error);
				showNotification('❌ เกิดข้อผิดพลาดในการบันทึก', 'error');
			}
		}

		// Export ข้อมูล
		function exportWalkableData() {
			const data = {
				building: walkablePointsData.currentBuilding,
				nodes: walkablePointsData.nodes,
				edges: walkablePointsData.edges,
				settings: walkablePointsData.settings,
				exported: new Date().toISOString()
			};
			
			const textarea = document.getElementById('walkableExportData');
			if (textarea) {
				textarea.value = JSON.stringify(data, null, 2);
			}
		}

		// Import ข้อมูล
		function importWalkableData() {
			const textarea = document.getElementById('walkableExportData');
			if (!textarea || !textarea.value.trim()) {
				showNotification('❌ กรุณาใส่ข้อมูล JSON', 'error');
				return;
			}
			
			try {
				const data = JSON.parse(textarea.value);
				
				if (!data.nodes || !data.edges) {
					throw new Error('ข้อมูลไม่ถูกต้อง');
				}
				
				walkablePointsData.nodes = data.nodes;
				walkablePointsData.edges = data.edges;
				
				if (data.settings) {
					walkablePointsData.settings = { ...walkablePointsData.settings, ...data.settings };
					loadWalkableSettings();
				}
				
				renderWalkablePoints();
				updateWalkableStats();
				
				showNotification('📥 Import ข้อมูลสำเร็จ', 'success');
				
			} catch (error) {
				console.error('Import error:', error);
				showNotification('❌ ข้อมูล JSON ไม่ถูกต้อง', 'error');
			}
		}

		// ========== Integration with Admin System ==========

		// Hook เข้ากับระบบ building selection ของ admin
		const originalShowSection = window.showSection;
		window.showSection = function(section) {
			if (originalShowSection) {
				originalShowSection(section);
			}
			
			if (section === 'maps') {
				// เพิ่ม walkable points section ถ้ายังไม่มี
				setTimeout(() => {
					if (!document.querySelector('.walkable-section')) {
						addWalkablePointsSection();
					}
				}, 500);
			}
		};

		// Hook เข้ากับการเปลี่ยน building
		const originalLoadMapsForBuilding = window.loadMapsForBuilding;
		window.loadMapsForBuilding = function(building) {
			if (originalLoadMapsForBuilding) {
				originalLoadMapsForBuilding(building);
			}
			
			// โหลดข้อมูล walkable points สำหรับอาคารใหม่
			walkablePointsData.currentBuilding = building;
			loadWalkableDataForBuilding(building);
		};

		// โหลดข้อมูลสำหรับอาคารที่กำหนด
		function loadWalkableDataForBuilding(building) {
			walkablePointsData.currentBuilding = building;
			
			// โหลดจาก localStorage
			const storageKey = `walkableData_${building}`;
			const saved = localStorage.getItem(storageKey);
			
			if (saved) {
				try {
					const data = JSON.parse(saved);
					walkablePointsData.nodes = data.nodes || {};
					walkablePointsData.edges = data.edges || [];
					
					if (data.settings) {
						walkablePointsData.settings = { ...walkablePointsData.settings, ...data.settings };
						loadWalkableSettings();
					}
					
					renderWalkablePoints();
					updateWalkableStats();
					
					console.log('Loaded walkable data for building:', building);
					
				} catch (error) {
					console.error('Error loading walkable data:', error);
				}
			} else {
				// ล้างข้อมูลถ้าไม่มีข้อมูลบันทึก
				walkablePointsData.nodes = {};
				walkablePointsData.edges = [];
				renderWalkablePoints();
				updateWalkableStats();
			}
		}

		// โหลด settings จาก UI
		function loadWalkableSettings() {
			try {
				// ตรวจสอบว่า settings มีอยู่และเป็น object
				if (!walkablePointsData.settings || typeof walkablePointsData.settings !== 'object') {
					console.warn('Invalid walkablePointsData.settings, using defaults');
					walkablePointsData.settings = {
						maxConnectionDistance: 25,
						metersPerPercent: 1.2,
						autoConnect: true,
						snapToGrid: false
					};
				}
				
				const settings = walkablePointsData.settings;
				
				// Safe value extraction with fallbacks
				const maxDistance = extractNumber(settings.maxConnectionDistance, 25);
				const metersPerPercent = extractNumber(settings.metersPerPercent, 1.2);
				const autoConnect = extractBoolean(settings.autoConnect, true);
				const snapToGrid = extractBoolean(settings.snapToGrid, false);
				
				// Set values safely
				const maxDistanceInput = document.getElementById('maxDistance');
				const metersPerPercentInput = document.getElementById('metersPerPercent');
				const autoConnectSelect = document.getElementById('autoConnect');
				const snapToGridSelect = document.getElementById('snapToGrid');
				
				if (maxDistanceInput) maxDistanceInput.value = maxDistance;
				if (metersPerPercentInput) metersPerPercentInput.value = metersPerPercent;
				if (autoConnectSelect) autoConnectSelect.value = autoConnect.toString();
				if (snapToGridSelect) snapToGridSelect.value = snapToGrid.toString();
				
				console.log('✅ Walkable settings loaded:', {
					maxDistance,
					metersPerPercent,
					autoConnect,
					snapToGrid
				});
				
			} catch (error) {
				console.error('Error in loadWalkableSettings:', error);
				
				// Emergency fallback - set default values
				const maxDistanceInput = document.getElementById('maxDistance');
				const metersPerPercentInput = document.getElementById('metersPerPercent');
				const autoConnectSelect = document.getElementById('autoConnect');
				const snapToGridSelect = document.getElementById('snapToGrid');
				
				if (maxDistanceInput) maxDistanceInput.value = '25';
				if (metersPerPercentInput) metersPerPercentInput.value = '1.2';
				if (autoConnectSelect) autoConnectSelect.value = 'true';
				if (snapToGridSelect) snapToGridSelect.value = 'false';
			}
		}
		
		// Helper functions สำหรับ safe value extraction
		function extractNumber(value, fallback) {
			if (typeof value === 'number' && !isNaN(value)) return value;
			if (typeof value === 'string') {
				const parsed = parseFloat(value);
				if (!isNaN(parsed)) return parsed;
			}
			if (typeof value === 'object' && value !== null && typeof value.value === 'number') {
				return value.value;
			}
			return fallback;
		}

		function extractBoolean(value, fallback) {
			if (typeof value === 'boolean') return value;
			if (typeof value === 'string') {
				return value.toLowerCase() === 'true';
			}
			if (typeof value === 'object' && value !== null && typeof value.value === 'boolean') {
				return value.value;
			}
			return fallback;
		}

		// ========== เพิ่ม Settings Validator ==========
		function validateWalkableSettings() {
			if (!walkablePointsData.settings) {
				walkablePointsData.settings = {};
			}
			
			const s = walkablePointsData.settings;
			
			// แก้ไข nested objects
			if (typeof s.maxConnectionDistance === 'object') {
				s.maxConnectionDistance = extractNumber(s.maxConnectionDistance, 25);
			}
			if (typeof s.metersPerPercent === 'object') {
				s.metersPerPercent = extractNumber(s.metersPerPercent, 1.2);
			}
			if (typeof s.autoConnect === 'object') {
				s.autoConnect = extractBoolean(s.autoConnect, true);
			}
			if (typeof s.snapToGrid === 'object') {
				s.snapToGrid = extractBoolean(s.snapToGrid, false);
			}
			
			console.log('✅ Settings validated:', s);
		}

		// เรียกใช้ validator ก่อน loadWalkableSettings
		const originalRenderUI = window.renderUI;
		window.renderUI = function() {
			validateWalkableSettings();
			if (originalRenderUI) {
				originalRenderUI();
			} else {
				if (typeof renderWalkablePoints === 'function') renderWalkablePoints();
				if (typeof updateWalkableStats === 'function') updateWalkableStats();
				if (typeof loadWalkableSettings === 'function') loadWalkableSettings();
			}
		};

		// อัพเดท settings จาก UI
		function updateSettings() {
			const maxDistance = document.getElementById('maxDistance')?.value;
			const metersPerPercent = document.getElementById('metersPerPercent')?.value;
			const autoConnect = document.getElementById('autoConnect')?.value;
			const snapToGrid = document.getElementById('snapToGrid')?.value;
			
			if (maxDistance) walkablePointsData.settings.maxConnectionDistance = parseFloat(maxDistance);
			if (metersPerPercent) walkablePointsData.settings.metersPerPercent = parseFloat(metersPerPercent);
			if (autoConnect) walkablePointsData.settings.autoConnect = autoConnect === 'true';
			if (snapToGrid) walkablePointsData.settings.snapToGrid = snapToGrid === 'true';
			
			console.log('Updated walkable settings:', walkablePointsData.settings);
		}

		// Helper Functions
		function getCurrentSelectedBuilding() {
			return window.currentSelectedBuilding || 'Main Building';
		}

		function findNodeAtPosition(x, y, tolerance = 2) {
			return Object.values(walkablePointsData.nodes).find(node => {
				const distance = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
				return distance <= tolerance;
			});
		}

		function selectEdge(edge) {
			if (confirm('ลบการเชื่อมโยงนี้?')) {
				const index = walkablePointsData.edges.indexOf(edge);
				if (index > -1) {
					walkablePointsData.edges.splice(index, 1);
					renderWalkablePoints();
					updateWalkableStats();
				}
			}
		}

		function deleteSelectedNodes() {
			if (walkablePointsData.selectedNodes.size === 0) {
				showNotification('❌ กรุณาเลือกจุดที่ต้องการลบ', 'error');
				return;
			}
			
			if (!confirm(`ลบจุดเดิน ${walkablePointsData.selectedNodes.size} จุด?`)) return;
			
			// ลบ nodes
			walkablePointsData.selectedNodes.forEach(nodeId => {
				delete walkablePointsData.nodes[nodeId];
			});
			
			// ลบ edges ที่เกี่ยวข้อง
			walkablePointsData.edges = walkablePointsData.edges.filter(edge => {
				return !walkablePointsData.selectedNodes.has(edge.from) && 
					   !walkablePointsData.selectedNodes.has(edge.to);
			});
			
			walkablePointsData.selectedNodes.clear();
			
			renderWalkablePoints();
			updateWalkableStats();
			
			showNotification('🗑️ ลบจุดเดินแล้ว', 'success');
		}

		function connectSelectedNodes() {
			const selectedArray = Array.from(walkablePointsData.selectedNodes);
			
			if (selectedArray.length < 2) {
				showNotification('❌ กรุณาเลือกอย่างน้อย 2 จุด', 'error');
				return;
			}
			
			let connectionsAdded = 0;
			
			for (let i = 0; i < selectedArray.length; i++) {
				for (let j = i + 1; j < selectedArray.length; j++) {
					const nodeA = walkablePointsData.nodes[selectedArray[i]];
					const nodeB = walkablePointsData.nodes[selectedArray[j]];
					const distance = calculateDistance(nodeA, nodeB);
					
					const existingEdge = walkablePointsData.edges.find(edge => 
						(edge.from === selectedArray[i] && edge.to === selectedArray[j]) ||
						(edge.from === selectedArray[j] && edge.to === selectedArray[i])
					);
					
					if (!existingEdge) {
						addEdgeIfNotExists(selectedArray[i], selectedArray[j], distance);
						connectionsAdded++;
					}
				}
			}
			
			renderWalkablePoints();
			updateWalkableStats();
			
			showNotification(`🔗 เชื่อมโยง ${connectionsAdded} เส้น`, 'success');
		}

		function copyWalkableData() {
			const textarea = document.getElementById('walkableExportData');
			if (textarea && textarea.value) {
				textarea.select();
				document.execCommand('copy');
				showNotification('📋 คัดลอกข้อมูลแล้ว', 'success');
			}
		}

		function updateSelectionInfo() {
			const count = walkablePointsData.selectedNodes.size;
			if (count > 0) {
				showNotification(`📍 เลือกจุดเดิน ${count} จุด`, 'info');
			}
		}

		// Export functions for global access
		window.walkablePointsAdmin = {
			addWalkablePointsSection,
			generateAutoNodes,
			optimizeConnections,
			saveWalkableData,
			exportWalkableData,
			importWalkableData,
			walkablePointsData
		};

		

	 
		
	 // =================== Initialization ===================
			// อัปเดต initializeAdmin function ให้รวมทุก module
			async function initializeAdmin() {
				try {
					console.log('🚀 Initializing Complete Admin Panel System...');
					
					// Show loading indicator
					showNotification('🔧 กำลังเริ่มต้นระบบ Admin Panel...', 'info');
					
					// 1. Load basic configuration
					console.log('📋 Loading basic configurations...');
					loadEnhancedSheetsConfig();
					
					// 2. Initialize all modules
					console.log('🔧 Initializing modules...');
					initializeEnhancedNavigationModule();
					initializeCRUDModule();
					initializeModalModule();
					initializeMapsModule();
					initializeDeploymentModule();
					initializeEnhancedSheetsModule();
					
					// 3. Add keyboard shortcuts help button
					//addKeyboardShortcutsButton();
					
					// 4. Setup responsive handlers
					setupResponsiveHandlers();
					
					// 5. Start sequential loading
					console.log('📊 Starting sequential data loading...');
					await sequentialLoader.startSequentialLoad();
					
					// 6. Post-initialization setup
					console.log('🎯 Completing initialization...');
					
					// Initialize current section
					const activeSection = document.querySelector('.page-section.active');
					if (activeSection) {
						const sectionId = activeSection.id.replace('-section', '');
						if (sectionId === 'dashboard') {
							updateDashboardStats();
						} else if (sectionId === 'buildings') {
							loadBuildingsTable();
						} else if (sectionId === 'rooms') {
							loadRoomsTable();
						}
					}
					
					// 7. Show success notification
					showNotification('✅ ระบบ Admin Panel พร้อมใช้งาน!', 'success');
					
					console.log('✅ Complete Admin Panel initialized successfully');
					
					// 8. Show welcome message with shortcuts info
					setTimeout(() => {
						showWelcomeMessage();
					}, 2000);

				} catch (error) {
					console.error('❌ Admin initialization error:', error);
					showNotification('❌ ไม่สามารถเริ่มต้นระบบได้', 'error');
					
					// Fallback initialization
					try {
						console.log('🔄 Attempting fallback initialization...');
						loadEnhancedSheetsConfig();
						updateDashboardStats();
						showNotification('⚠️ เริ่มต้นระบบในโหมดจำกัด', 'warning');
					} catch (fallbackError) {
						console.error('❌ Fallback initialization failed:', fallbackError);
					}
				}
			}
			
			
			async function initializeAdminOrg() {
				try {
					console.log('🚀 Initializing Admin Panel with Sequential Loading...');

					// Load basic settings
					loadSheetsConfig();

					// Start sequential loading
					await sequentialLoader.startSequentialLoad();

					console.log('✅ Admin Panel initialized successfully');

				} catch (error) {
					console.error('❌ Admin initialization error:', error);
					showNotification('❌ ไม่สามารถเริ่มต้นระบบได้', 'error');
				}
			}		


			// ✅ เพิ่มฟังก์ชัน initializeDeploymentModule ที่หายไป
			function initializeDeploymentModule() {
				console.log('🚀 Initializing Deployment Module...');
				
				try {
					// ตรวจสอบว่ามี section deployment หรือไม่
					const deploymentSection = document.getElementById('deployment-section');
					if (deploymentSection) {
						console.log('✅ Deployment section found');
					}
					
					console.log('✅ Deployment Module initialized');
					return true;
				} catch (error) {
					console.error('❌ Error initializing Deployment module:', error);
					return false;
				}
			}
			
			// ========== Quick Fix: getCurrentBuilding Function ==========
			// 🚨 เพิ่มก่อน Phase 2.1 code ใน admin.html เพื่อแก้ไข ReferenceError

			// ฟังก์ชัน getCurrentBuilding สำหรับใช้ใน Bridge System
			function getCurrentBuilding() {
				// ลำดับการหา current building:
				// 1. จาก walkablePointsData.currentBuilding
				// 2. จาก getCurrentSelectedBuilding() (existing function)
				// 3. จาก global variables อื่นๆ
				// 4. Default fallback
				
				try {
					// ลองจาก walkablePointsData ก่อน
					if (typeof walkablePointsData !== 'undefined' && walkablePointsData.currentBuilding) {
						return walkablePointsData.currentBuilding;
					}
					
					// ลองจาก existing function
					if (typeof getCurrentSelectedBuilding === 'function') {
						const selected = getCurrentSelectedBuilding();
						if (selected && selected !== 'undefined') {
							return selected;
						}
					}
					
					// ลองจาก global variables
					if (typeof window.currentSelectedBuilding !== 'undefined' && window.currentSelectedBuilding) {
						return window.currentSelectedBuilding;
					}
					
					if (typeof window.currentBuilding !== 'undefined' && window.currentBuilding) {
						return window.currentBuilding;
					}
					
					// ลองจาก DOM elements
					const buildingSelect = document.getElementById('buildingSelect');
					if (buildingSelect && buildingSelect.value) {
						return buildingSelect.value;
					}
					
					// ลองจาก หัวข้อหรือ title elements
					const buildingTitle = document.querySelector('[data-building]') || 
										 document.querySelector('.building-title') ||
										 document.querySelector('.current-building');
					
					if (buildingTitle && buildingTitle.textContent) {
						return buildingTitle.textContent.trim();
					}
					
				} catch (error) {
					console.warn('Error in getCurrentBuilding:', error);
				}
				
				// Default fallback
				return 'Main Building';
			}

			// เพิ่ม getCurrentBuildingName เป็น alias (สำหรับ Phase 2.1 code)
			function getCurrentBuildingName() {
				return getCurrentBuilding();
			}

			// Safe wrapper สำหรับ getCurrentSelectedBuilding  
			function safeGetCurrentSelectedBuilding() {
				try {
					if (typeof getCurrentSelectedBuilding === 'function') {
						return getCurrentSelectedBuilding();
					}
					return getCurrentBuilding();
				} catch (error) {
					console.warn('Error in safeGetCurrentSelectedBuilding:', error);
					return getCurrentBuilding();
				}
			}
	  
			
			// ========== Phase 2.1: Storage Key Separation + Complete Data Bridge ==========
			// 🎯 Mission: แก้ไข storage conflicts และสร้าง complete data conversion bridge
			// 🔧 Target: admin.html + index.html ใช้ storage keys แยกกันและ sync ได้

			// ========== 1. Enhanced ADMIN_INDEX_BRIDGE ==========
			// ========== 2. Safe Storage Key Functions ==========

			// ดึง storage key ที่ถูกต้องตาม environment
			function getSafeStorageKey(building, forceMode = null) {
				if (!building) building = getCurrentBuildingName();
				
				let mode;
				if (forceMode) {
					mode = forceMode;
				} else if (ADMIN_INDEX_BRIDGE.isAdminMode()) {
					mode = 'admin';
				} else if (ADMIN_INDEX_BRIDGE.isIndexMode()) {
					mode = 'index';
				} else {
					mode = 'unknown';
				}
				
				return ADMIN_INDEX_BRIDGE.getStorageKey(building, mode);
			}

			// หา building name จาก environment
			function getCurrentBuildingName() {
				// ลองหาจาก global variables
				if (typeof walkablePointsData !== 'undefined' && walkablePointsData.currentBuilding) {
					return walkablePointsData.currentBuilding;
				}
				if (typeof walkableRoutingData !== 'undefined' && walkableRoutingData.currentBuilding) {
					return walkableRoutingData.currentBuilding;
				}
				if (typeof currentBuilding !== 'undefined') {
					return currentBuilding;
				}
				
				// ลองหาจาก DOM elements
				const buildingSelect = document.getElementById('buildingSelect') || 
									  document.querySelector('[data-building]') ||
									  document.querySelector('.building-selector');
				
				if (buildingSelect && buildingSelect.value) {
					return buildingSelect.value;
				}
				
				// Default fallback
				return 'Main Building';
			}

			// ========== 3. Complete Data Format Converters ==========

			// แปลงจาก admin format เป็น index format (COMPLETE VERSION)
			function convertAdminToIndexFormat(adminData) {
				if (!adminData || typeof adminData !== 'object') {
					debugLog('❌ Invalid admin data for conversion');
					return null;
				}
				
				try {
					ADMIN_INDEX_BRIDGE.conversionCount++;
					debugLog('🔄 Converting admin data to index format...', {
						adminNodes: Object.keys(adminData.nodes || {}).length,
						adminEdges: (adminData.edges || []).length,
						conversionId: ADMIN_INDEX_BRIDGE.conversionCount
					});
					
					const indexData = {
						// Core structure for index.html
						nodes: {},
						edges: [],
						settings: {
							metersPerPercent: adminData.settings?.metersPerPercent || 1.2,
							maxSearchRadius: adminData.settings?.maxConnectionDistance || 25,
							gridSize: adminData.settings?.gridSize || 5,
							autoConnect: adminData.settings?.autoConnect !== false,
							snapToGrid: adminData.settings?.snapToGrid || false
						},
						
						// Metadata
						currentBuilding: adminData.currentBuilding || adminData.building,
						lastPath: null,
						isInitialized: true,
						
						// Bridge metadata
						dataSource: 'admin',
						syncTime: new Date().toISOString(),
						originalFormat: 'admin',
						conversionId: ADMIN_INDEX_BRIDGE.conversionCount
					};
					
					// แปลง nodes
					if (adminData.nodes && typeof adminData.nodes === 'object') {
						for (const nodeId in adminData.nodes) {
							const adminNode = adminData.nodes[nodeId];
							if (adminNode && typeof adminNode === 'object') {
								indexData.nodes[nodeId] = {
									id: nodeId,
									x: parseFloat(adminNode.x) || 0,
									y: parseFloat(adminNode.y) || 0,
									type: adminNode.type || 'grid',
									building: adminNode.building || indexData.currentBuilding,
									isActive: adminNode.isActive !== false,
									source: 'admin'
								};
							}
						}
					}
					
					// แปลง edges
					if (adminData.edges && Array.isArray(adminData.edges)) {
						adminData.edges.forEach((adminEdge, index) => {
							if (adminEdge && typeof adminEdge === 'object') {
								indexData.edges.push({
									from: adminEdge.from,
									to: adminEdge.to,
									weight: parseFloat(adminEdge.weight) || 0,
									bidirectional: adminEdge.bidirectional !== false,
									building: adminEdge.building || indexData.currentBuilding,
									isActive: adminEdge.isActive !== false,
									edgeId: adminEdge.edgeId || `E${index + 1}`,
									source: 'admin'
								});
							}
						});
					}
					
					debugLog('✅ Admin to index conversion completed:', {
						convertedNodes: Object.keys(indexData.nodes).length,
						convertedEdges: indexData.edges.length,
						building: indexData.currentBuilding
					});
					
					ADMIN_INDEX_BRIDGE.lastConversionError = null;
					return indexData;
					
				} catch (error) {
					debugLog('❌ Error in admin to index conversion:', error);
					ADMIN_INDEX_BRIDGE.lastConversionError = error.message;
					return null;
				}
			}

			// แปลงจาก index format เป็น admin format (COMPLETE VERSION)
			function convertIndexToAdminFormat(indexData) {
				if (!indexData || typeof indexData !== 'object') {
					debugLog('❌ Invalid index data for conversion');
					return null;
				}
				
				try {
					ADMIN_INDEX_BRIDGE.conversionCount++;
					debugLog('🔄 Converting index data to admin format...', {
						indexNodes: Object.keys(indexData.nodes || {}).length,
						indexEdges: (indexData.edges || []).length,
						conversionId: ADMIN_INDEX_BRIDGE.conversionCount
					});
					
					const adminData = {
						// Core structure for admin.html
						currentBuilding: indexData.currentBuilding || indexData.building,
						building: indexData.currentBuilding || indexData.building,
						nodes: {},
						edges: [],
						settings: {
							maxConnectionDistance: indexData.settings?.maxSearchRadius || 25,
							metersPerPercent: indexData.settings?.metersPerPercent || 1.2,
							autoConnect: indexData.settings?.autoConnect !== false,
							snapToGrid: indexData.settings?.snapToGrid || false,
							gridSize: indexData.settings?.gridSize || 5
						},
						
						// Admin-specific properties
						selectedNodes: new Set(),
						isDragging: false,
						dragNode: null,
						
						// Bridge metadata
						dataSource: 'index',
						syncTime: new Date().toISOString(),
						originalFormat: 'index',
						conversionId: ADMIN_INDEX_BRIDGE.conversionCount
					};
					
					// แปลง nodes
					if (indexData.nodes && typeof indexData.nodes === 'object') {
						for (const nodeId in indexData.nodes) {
							const indexNode = indexData.nodes[nodeId];
							if (indexNode && typeof indexNode === 'object') {
								adminData.nodes[nodeId] = {
									id: nodeId,
									x: parseFloat(indexNode.x) || 0,
									y: parseFloat(indexNode.y) || 0,
									type: indexNode.type || 'grid',
									building: indexNode.building || adminData.currentBuilding,
									isActive: indexNode.isActive !== false,
									source: 'index'
								};
							}
						}
					}
					
					// แปลง edges
					if (indexData.edges && Array.isArray(indexData.edges)) {
						indexData.edges.forEach((indexEdge, edgeIndex) => {
							if (indexEdge && typeof indexEdge === 'object') {
								adminData.edges.push({
									from: indexEdge.from,
									to: indexEdge.to,
									weight: parseFloat(indexEdge.weight) || 0,
									bidirectional: indexEdge.bidirectional !== false,
									building: indexEdge.building || adminData.currentBuilding,
									isActive: indexEdge.isActive !== false,
									edgeId: indexEdge.edgeId || `E${edgeIndex + 1}`,
									source: 'index'
								});
							}
						});
					}
					
					debugLog('✅ Index to admin conversion completed:', {
						convertedNodes: Object.keys(adminData.nodes).length,
						convertedEdges: adminData.edges.length,
						building: adminData.currentBuilding
					});
					
					ADMIN_INDEX_BRIDGE.lastConversionError = null;
					return adminData;
					
				} catch (error) {
					debugLog('❌ Error in index to admin conversion:', error);
					ADMIN_INDEX_BRIDGE.lastConversionError = error.message;
					return null;
				}
			}

			// ========== 4. Safe Data Sync Functions ==========

			// Sync admin data ไป index (SAFE VERSION)
			function syncAdminDataToIndex(building) {
				if (!ADMIN_INDEX_BRIDGE.isIndexMode()) {
					debugLog('⚠️ Not in index mode, sync skipped');
					return false;
				}
				
				debugLog('🔥 Syncing admin data to index...', { building });
				
				try {
					// โหลดข้อมูลจาก admin storage
					const adminKey = getSafeStorageKey(building, 'admin');
					const adminDataString = localStorage.getItem(adminKey);
					
					if (!adminDataString) {
						debugLog('ℹ️ No admin data found in storage');
						return false;
					}
					
					const adminData = JSON.parse(adminDataString);
					
					// ตรวจสอบว่าเป็นข้อมูลจาก admin หรือไม่ (ป้องกัน circular sync)
					if (adminData.dataSource === 'index') {
						debugLog('🔄 Data source is index, avoiding circular sync');
						return false;
					}
					
					// แปลงเป็น index format
					const indexData = convertAdminToIndexFormat(adminData);
					if (!indexData) {
						debugLog('❌ Failed to convert admin data to index format');
						return false;
					}
					
					// อัปเดต walkableRoutingData ถ้ามี
					if (typeof walkableRoutingData !== 'undefined') {
						Object.assign(walkableRoutingData, indexData);
						debugLog('✅ walkableRoutingData updated from admin');
					}
					
					// บันทึกใน index storage
					const indexKey = getSafeStorageKey(building, 'index');
					localStorage.setItem(indexKey, JSON.stringify(indexData));
					
					ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
					
					debugLog('✅ Admin data synced to index successfully', {
						adminKey,
						indexKey,
						nodes: Object.keys(indexData.nodes).length,
						edges: indexData.edges.length
					});
					
					return true;
					
				} catch (error) {
					debugLog('❌ Error syncing admin data to index:', error);
					return false;
				}
			}

			// Sync index data ไป admin (SAFE VERSION)  
			function syncIndexDataToAdmin(building) {
				if (!ADMIN_INDEX_BRIDGE.isAdminMode()) {
					debugLog('⚠️ Not in admin mode, sync skipped');
					return false;
				}
				
				debugLog('🔤 Syncing index data to admin...', { building });
				
				try {
					// โหลดข้อมูลจาก index storage
					const indexKey = getSafeStorageKey(building, 'index');
					const indexDataString = localStorage.getItem(indexKey);
					
					if (!indexDataString) {
						debugLog('ℹ️ No index data found in storage');
						return false;
					}
					
					const indexData = JSON.parse(indexDataString);
					
					// ตรวจสอบว่าเป็นข้อมูลจาก index หรือไม่
					if (indexData.dataSource === 'admin') {
						debugLog('🔄 Data source is admin, avoiding circular sync');
						return false;
					}
					
					// แปลงเป็น admin format
					const adminData = convertIndexToAdminFormat(indexData);
					if (!adminData) {
						debugLog('❌ Failed to convert index data to admin format');
						return false;
					}
					
					// อัปเดต walkablePointsData ถ้ามี
					if (typeof walkablePointsData !== 'undefined') {
						Object.assign(walkablePointsData, adminData);
						
						// Render ใหม่ถ้ามีฟังก์ชัน
						if (typeof renderWalkablePoints === 'function') {
							renderWalkablePoints();
						}
						if (typeof updateWalkableStats === 'function') {
							updateWalkableStats();
						}
						
						debugLog('✅ walkablePointsData updated from index');
					}
					
					// บันทึกใน admin storage
					const adminKey = getSafeStorageKey(building, 'admin');
					localStorage.setItem(adminKey, JSON.stringify(adminData));
					
					ADMIN_INDEX_BRIDGE.lastSyncTime = new Date().toISOString();
					
					debugLog('✅ Index data synced to admin successfully', {
						indexKey,
						adminKey,
						nodes: Object.keys(adminData.nodes).length,
						edges: adminData.edges.length
					});
					
					return true;
					
				} catch (error) {
					debugLog('❌ Error syncing index data to admin:', error);
					return false;
				}
			}

			// ========== 5. Enhanced Data Loading Functions ==========

			// Load data สำหรับ admin.html (แทนที่ loadWalkableDataForBuilding เดิม)
			function loadWalkableDataForBuildingV2(building) {
				building = building || getCurrentBuildingName();
				debugLog('📂 Loading walkable data for building (v2)...', { building });
				
				// อัปเดต current building
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.currentBuilding = building;
				}
				
				try {
					// ลองโหลดจาก admin storage ก่อน
					const adminKey = getSafeStorageKey(building, 'admin');
					const adminDataString = localStorage.getItem(adminKey);
					
					if (adminDataString) {
						const adminData = JSON.parse(adminDataString);
						
						// อัปเดต walkablePointsData
						if (typeof walkablePointsData !== 'undefined') {
							Object.assign(walkablePointsData, adminData);
							
							// Render ใหม่
							if (typeof renderWalkablePoints === 'function') {
								renderWalkablePoints();
							}
							if (typeof updateWalkableStats === 'function') {
								updateWalkableStats();
							}
							if (typeof loadWalkableSettings === 'function') {
								loadWalkableSettings();
							}
						}
						
						debugLog('✅ Loaded admin walkable data', {
							nodes: Object.keys(adminData.nodes || {}).length,
							edges: (adminData.edges || []).length
						});
						return;
					}
					
					// ถ้าไม่มีข้อมูล admin ลองดูว่ามี index data ไหม
					const synced = syncIndexDataToAdmin(building);
					if (synced) {
						debugLog('✅ Synced index data to admin');
						return;
					}
					
					// ถ้าไม่มีข้อมูลใดๆ ให้สร้างข้อมูลเริ่มต้น
					debugLog('📋 No existing data, creating fresh admin data');
					if (typeof walkablePointsData !== 'undefined') {
						walkablePointsData.nodes = {};
						walkablePointsData.edges = [];
						walkablePointsData.currentBuilding = building;
						
						if (typeof renderWalkablePoints === 'function') {
							renderWalkablePoints();
						}
						if (typeof updateWalkableStats === 'function') {
							updateWalkableStats();
						}
					}
					
				} catch (error) {
					debugLog('❌ Error loading walkable data for building:', error);
					
					// Error fallback
					if (typeof walkablePointsData !== 'undefined') {
						walkablePointsData.nodes = {};
						walkablePointsData.edges = [];
						walkablePointsData.currentBuilding = building;
					}
				}
			}

			// Load data สำหรับ index.html (แทนที่ loadWalkableData เดิม)
			function loadWalkableDataWithAdminSyncV2(building) {
				building = building || getCurrentBuildingName();
				debugLog('📂 Loading walkable data with admin sync (v2)...', { building });
				
				// อัปเดต current building
				if (typeof walkableRoutingData !== 'undefined') {
					walkableRoutingData.currentBuilding = building;
				}
				
				try {
					// ลองโหลดจาก admin ก่อน (admin has priority)
					const adminSynced = syncAdminDataToIndex(building);
					if (adminSynced) {
						debugLog('✅ Loaded admin-created walkable data');
						return;
					}
					
					// ถ้าไม่มีข้อมูล admin ลองโหลดจาก index cache
					const indexKey = getSafeStorageKey(building, 'index');
					const indexDataString = localStorage.getItem(indexKey);
					
					if (indexDataString) {
						const indexData = JSON.parse(indexDataString);
						
						// อัปเดต walkableRoutingData
						if (typeof walkableRoutingData !== 'undefined') {
							Object.assign(walkableRoutingData, indexData);
						}
						
						debugLog('📋 Loaded cached index walkable data', {
							nodes: Object.keys(indexData.nodes || {}).length,
							edges: (indexData.edges || []).length
						});
						return;
					}
					
					// สุดท้ายถ้าไม่มีข้อมูลใดๆ ให้สร้าง fixed grid
					debugLog('🗏️ No existing data, creating fixed grid');
					if (typeof createFixedWalkableGrid === 'function') {
						createFixedWalkableGrid();
					} else if (typeof walkableRoutingData !== 'undefined') {
						// สร้างข้อมูลเริ่มต้นถ้าไม่มีฟังก์ชัน
						walkableRoutingData.nodes = {};
						walkableRoutingData.edges = [];
						walkableRoutingData.isInitialized = true;
					}
					
				} catch (error) {
					debugLog('❌ Error loading walkable data with admin sync:', error);
					
					// Error fallback
					if (typeof walkableRoutingData !== 'undefined') {
						walkableRoutingData.nodes = {};
						walkableRoutingData.edges = [];
						walkableRoutingData.isInitialized = false;
					}
				}
			}

			// ========== 6. Enhanced Save Functions ==========

			// Save data สำหรับ admin.html (แทนที่ saveWalkableData เดิม)
			function saveWalkableDataV2() {
				const building = getCurrentBuildingName();
				debugLog('💾 Saving walkable data (v2)...', { building });
				
				try {
					if (typeof walkablePointsData === 'undefined') {
						throw new Error('walkablePointsData not found');
					}
					
					// เพิ่ม metadata
					const dataToSave = {
						...walkablePointsData,
						building: building,
						currentBuilding: building,
						dataSource: 'admin',
						syncTime: new Date().toISOString(),
						timestamp: new Date().toISOString()
					};
					
					// บันทึกใน admin storage
					const adminKey = getSafeStorageKey(building, 'admin');
					localStorage.setItem(adminKey, JSON.stringify(dataToSave));
					
					debugLog('✅ Admin data saved successfully', {
						adminKey,
						nodes: Object.keys(dataToSave.nodes || {}).length,
						edges: (dataToSave.edges || []).length
					});
					
					// Auto-sync to index ถ้าเปิดใช้งาน
					if (ADMIN_INDEX_BRIDGE.autoSyncOnChange) {
						const indexData = convertAdminToIndexFormat(dataToSave);
						if (indexData) {
							const indexKey = getSafeStorageKey(building, 'index');
							localStorage.setItem(indexKey, JSON.stringify(indexData));
							debugLog('🔄 Auto-synced to index format');
						}
					}
					
					// แสดง notification ถ้ามีฟังก์ชัน
					if (typeof showNotification === 'function') {
						showNotification('💾 บันทึกข้อมูลจุดเดินแล้ว', 'success');
					}
					
				} catch (error) {
					debugLog('❌ Error saving walkable data:', error);
					
					if (typeof showNotification === 'function') {
						showNotification('❌ เกิดข้อผิดพลาดในการบันทึก', 'error');
					}
				}
			}

			// Save data สำหรับ index.html
			function saveWalkableDataV2ForIndex() {
				const building = getCurrentBuildingName();
				debugLog('💾 Saving walkable data for index (v2)...', { building });
				
				try {
					if (typeof walkableRoutingData === 'undefined') {
						throw new Error('walkableRoutingData not found');
					}
					
					// เพิ่ม metadata
					const dataToSave = {
						...walkableRoutingData,
						currentBuilding: building,
						dataSource: 'index',
						syncTime: new Date().toISOString()
					};
					
					// บันทึกใน index storage
					const indexKey = getSafeStorageKey(building, 'index');
					localStorage.setItem(indexKey, JSON.stringify(dataToSave));
					
					debugLog('✅ Index data saved successfully', {
						indexKey,
						nodes: Object.keys(dataToSave.nodes || {}).length,
						edges: (dataToSave.edges || []).length
					});
					
				} catch (error) {
					debugLog('❌ Error saving index walkable data:', error);
				}
			}

			// ========== 7. Debug and Status Functions ==========

			// แสดงสถานะ bridge system
			function debugBridgeStatus() {
				const building = getCurrentBuildingName();
				
				console.group('🔍 Bridge System Status');
				console.log('Environment:', {
					isAdmin: ADMIN_INDEX_BRIDGE.isAdminMode(),
					isIndex: ADMIN_INDEX_BRIDGE.isIndexMode(),
					building: building
				});
				
				console.log('Storage Keys:', {
					admin: getSafeStorageKey(building, 'admin'),
					index: getSafeStorageKey(building, 'index')
				});
				
				// ตรวจสอบข้อมูลใน localStorage
				const adminKey = getSafeStorageKey(building, 'admin');
				const indexKey = getSafeStorageKey(building, 'index');
				
				const adminData = localStorage.getItem(adminKey);
				const indexData = localStorage.getItem(indexKey);
				
				console.log('Storage Status:', {
					adminData: adminData ? 'EXISTS' : 'NOT FOUND',
					indexData: indexData ? 'EXISTS' : 'NOT FOUND'
				});
				
				if (adminData) {
					try {
						const parsed = JSON.parse(adminData);
						console.log('Admin Data:', {
							nodes: Object.keys(parsed.nodes || {}).length,
							edges: (parsed.edges || []).length,
							source: parsed.dataSource,
							syncTime: parsed.syncTime
						});
					} catch (e) {
						console.warn('⚠️ Admin data parsing error:', e);
					}
				}
				
				if (indexData) {
					try {
						const parsed = JSON.parse(indexData);
						console.log('Index Data:', {
							nodes: Object.keys(parsed.nodes || {}).length,
							edges: (parsed.edges || []).length,
							source: parsed.dataSource,
							syncTime: parsed.syncTime
						});
					} catch (e) {
						console.warn('⚠️ Index data parsing error:', e);
					}
				}
				
				console.log('Bridge Status:', {
					lastSync: ADMIN_INDEX_BRIDGE.lastSyncTime,
					conversionCount: ADMIN_INDEX_BRIDGE.conversionCount,
					lastError: ADMIN_INDEX_BRIDGE.lastConversionError
				});
				
				console.groupEnd();
			}

			// ทดสอบการแปลงข้อมูล
			function testDataConversion() {
				const building = getCurrentBuildingName();
				console.group('🧪 Testing Data Conversion');
				
				// สร้างข้อมูลทดสอบ
				const testAdminData = {
					currentBuilding: building,
					nodes: {
						'test1': { id: 'test1', x: 10, y: 20, type: 'center' },
						'test2': { id: 'test2', x: 30, y: 40, type: 'grid' }
					},
					edges: [
						{ from: 'test1', to: 'test2', weight: 25.5, bidirectional: true }
					],
					settings: { maxConnectionDistance: 30, metersPerPercent: 1.5 }
				};
				
				// ทดสอบ admin → index
				console.log('Testing admin → index conversion...');
				const indexResult = convertAdminToIndexFormat(testAdminData);
				console.log('Result:', indexResult);
				
				// ทดสอบ index → admin
				if (indexResult) {
					console.log('Testing index → admin conversion...');
					const adminResult = convertIndexToAdminFormat(indexResult);
					console.log('Result:', adminResult);
				}
				
				console.groupEnd();
			}

			// ล้างข้อมูลทั้งหมด (สำหรับ debug)
			function clearAllWalkableData(building) {
				building = building || getCurrentBuildingName();
				
				const adminKey = getSafeStorageKey(building, 'admin');
				const indexKey = getSafeStorageKey(building, 'index');
				
				localStorage.removeItem(adminKey);
				localStorage.removeItem(indexKey);
				
				// ล้าง old format data ด้วย (migration)
				const oldKey = `walkableData_${building}`;
				localStorage.removeItem(oldKey);
				
				console.log('🗑️ Cleared all walkable data for building:', building);
				debugBridgeStatus();
			}

			// ========== 8. Initialization and Integration ==========

			// เรียกใช้เมื่อ DOM ready
			function initializeBridgeSystem() {
				debugLog('🚀 Initializing Bridge System...');
				
				// ตรวจสอบ environment
				if (!ADMIN_INDEX_BRIDGE.isAdminMode() && !ADMIN_INDEX_BRIDGE.isIndexMode()) {
					debugLog('⚠️ Unknown environment, bridge system inactive');
					return;
				}
				
				// เพิ่ม debug commands ใน window
				if (ADMIN_INDEX_BRIDGE.debugMode) {
					window.debugBridgeStatus = debugBridgeStatus;
					window.testDataConversion = testDataConversion;
					window.clearAllWalkableData = clearAllWalkableData;
					window.ADMIN_INDEX_BRIDGE = ADMIN_INDEX_BRIDGE;
				}
				
				debugLog('✅ Bridge System initialized successfully');
				debugLog('🔧 Available debug commands: debugBridgeStatus(), testDataConversion(), clearAllWalkableData()');
			}

			// Auto-initialize เมื่อ script load
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeBridgeSystem);
			} else {
				initializeBridgeSystem();
			}

			// ========== 9. Helper Functions ==========

			function debugLog(message, data = null) {
				if (!ADMIN_INDEX_BRIDGE.debugMode) return;
				
				const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
				const prefix = `[${timestamp}] Bridge:`;
				
				if (data) {
					console.log(prefix, message, data);
				} else {
					console.log(prefix, message);
				}
			}

			// Export functions for global use
			window.PHASE_2_1_FUNCTIONS = {
				// Storage
				getSafeStorageKey,
				getCurrentBuildingName,
				
				// Conversion
				convertAdminToIndexFormat,
				convertIndexToAdminFormat,
				
				// Sync
				syncAdminDataToIndex,
				syncIndexDataToAdmin,
				
				// Loading
				loadWalkableDataForBuildingV2,
				loadWalkableDataWithAdminSyncV2,
				
				// Saving
				saveWalkableDataV2,
				saveWalkableDataV2ForIndex,
				
				// Debug
				debugBridgeStatus,
				testDataConversion,
				clearAllWalkableData
			};
			
			// แทนที่ฟังก์ชัน loadWalkableDataForBuilding และ saveWalkableData เดิม
			window.loadWalkableDataForBuilding = loadWalkableDataForBuildingV2;
			window.saveWalkableData = saveWalkableDataV2;

		// ========== End Phase 2.1: Storage Key Separation + Complete Data Bridge ==========
			
			
		// ========== Phase 2.2A: Admin Walkable Sheets Integration ==========

		// ========== 1. Walkable Sheets Configuration ==========

		// เพิ่ม flag เพื่อป้องกัน infinite recursion
		let _saveInProgress = false;
		
		// เพิ่มใน sheetsConfig object (แก้ไข existing sheetsConfig)
		const WALKABLE_SHEETS_CONFIG = {
			// Existing sheetsConfig properties...
			...sheetsConfig,
			
			// เพิ่ม walkable-specific settings
			walkableEnabled: true,
			autoSyncWalkable: true,
			walkableTimeout: 10000,
			walkableRetryAttempts: 2,
			
			// Walkable sync status
			walkableSyncStatus: 'idle', // idle, syncing, success, error
			lastWalkableSync: null,
			walkableSyncErrors: []
		};

		// ========== 2. Core Walkable Sheets Functions ==========

		// โหลด walkable data จาก Google Sheets
		async function loadWalkableDataFromSheets(building) {
			if (!sheetsConfig.url || !sheetsConfig.connected) {
				debugLog('⚠️ Sheets not configured or connected');
				return null;
			}
			
			building = building || getCurrentBuildingName();
			WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'syncing';
			updateWalkableSyncUI();
			
			try {
				debugLog(`📥 Loading walkable data from sheets for: ${building}`);
				
				const params = new URLSearchParams();
				params.append('action', 'getWalkableData');
				params.append('building', building);
				
				const response = await Promise.race([
					fetch(sheetsConfig.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: params.toString()
					}),
					new Promise((_, reject) => 
						setTimeout(() => reject(new Error('Timeout')), WALKABLE_SHEETS_CONFIG.walkableTimeout)
					)
				]);
				
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				
				const result = await response.json();
				
				if (result.success && result.data) {
					WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'success';
					WALKABLE_SHEETS_CONFIG.lastWalkableSync = new Date().toISOString();
					
					debugLog('✅ Loaded walkable data from sheets:', {
						nodes: Object.keys(result.data.nodes || {}).length,
						edges: (result.data.edges || []).length
					});
					
					updateWalkableSyncUI();
					showWalkableNotification('📥 โหลดข้อมูลจุดเดินจาก Google Sheets สำเร็จ', 'success');
					
					return result.data;
				} else {
					throw new Error(result.error || 'Invalid response format');
				}
				
			} catch (error) {
				WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'error';
				WALKABLE_SHEETS_CONFIG.walkableSyncErrors.push({
					timestamp: new Date().toISOString(),
					operation: 'load',
					error: error.message
				});
				
				debugLog('❌ Failed to load walkable data from sheets:', error);
				updateWalkableSyncUI();
				showWalkableNotification(`❌ โหลดข้อมูลจุดเดินล้มเหลว: ${error.message}`, 'error');
				
				return null;
			}
		}

		// บันทึก walkable data ไป Google Sheets
		async function saveWalkableDataToSheets(data) {
			if (!sheetsConfig.url || !sheetsConfig.connected) {
				debugLog('⚠️ Sheets not configured or connected');
				return false;
			}
			
			if (!data || !data.nodes) {
				debugLog('❌ Invalid walkable data for saving');
				return false;
			}
			
			WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'syncing';
			updateWalkableSyncUI();
			
			try {
				const building = data.currentBuilding || data.building || getCurrentBuildingName();
				
				debugLog(`📤 Saving walkable data to sheets for: ${building}`);
				
				const params = new URLSearchParams();
				params.append('action', 'saveWalkableData');
				params.append('building', building);
				params.append('nodes', JSON.stringify(data.nodes || {}));
				params.append('edges', JSON.stringify(data.edges || []));
				params.append('settings', JSON.stringify(data.settings || {}));
				
				const response = await Promise.race([
					fetch(sheetsConfig.url, {
						method: 'POST',
						headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
						body: params.toString()
					}),
					new Promise((_, reject) => 
						setTimeout(() => reject(new Error('Timeout')), WALKABLE_SHEETS_CONFIG.walkableTimeout)
					)
				]);
				
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				
				const result = await response.json();
				
				if (result.success) {
					WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'success';
					WALKABLE_SHEETS_CONFIG.lastWalkableSync = new Date().toISOString();
					
					debugLog('✅ Saved walkable data to sheets:', result.data);
					updateWalkableSyncUI();
					showWalkableNotification('📤 บันทึกข้อมูลจุดเดินไป Google Sheets สำเร็จ', 'success');
					
					return true;
				} else {
					throw new Error(result.error || 'Save operation failed');
				}
				
			} catch (error) {
				WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'error';
				WALKABLE_SHEETS_CONFIG.walkableSyncErrors.push({
					timestamp: new Date().toISOString(),
					operation: 'save',
					error: error.message
				});
				
				debugLog('❌ Failed to save walkable data to sheets:', error);
				updateWalkableSyncUI();
				showWalkableNotification(`❌ บันทึกข้อมูลจุดเดินล้มเหลว: ${error.message}`, 'error');
				
				return false;
			}
		}

		// สร้าง walkable sheets อัตโนมัติ
		async function createWalkableSheetsAuto(building) {
			if (!sheetsConfig.url || !sheetsConfig.connected) {
				debugLog('⚠️ Cannot create sheets - not connected');
				return false;
			}
			
			building = building || getCurrentBuildingName();
			
			try {
				debugLog(`🏗️ Creating walkable sheets for: ${building}`);
				
				const params = new URLSearchParams();
				params.append('action', 'createWalkableSheets');
				params.append('building', building);
				
				const response = await fetch(sheetsConfig.url, {
					method: 'POST',
					headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
					body: params.toString()
				});
				
				if (response.ok) {
					const result = await response.json();
					if (result.success) {
						debugLog('✅ Walkable sheets created successfully');
						showWalkableNotification('🏗️ สร้าง Google Sheets สำหรับจุดเดินสำเร็จ', 'success');
						return true;
					}
				}
				
				throw new Error('Failed to create walkable sheets');
				
			} catch (error) {
				debugLog('❌ Error creating walkable sheets:', error);
				showWalkableNotification(`❌ สร้าง Google Sheets ล้มเหลว: ${error.message}`, 'error');
				return false;
			}
		}

		// ========== 3. Enhanced Save Function with Sheets Integration ==========

		// แทนที่ saveWalkableData เดิมด้วยเวอร์ชันที่รองรับ Sheets
		async function saveWalkableDataEnhanced() {
			// ป้องกัน infinite loop
			if (_saveInProgress) {
				debugLog('⚠️ Save already in progress, skipping...');
				return true;
			}
			
			_saveInProgress = true;
			
			try {
				const building = getCurrentBuildingName();
				debugLog('💾 Saving walkable data (enhanced with sheets)...', { building });
				
				if (typeof walkablePointsData === 'undefined') {
					throw new Error('walkablePointsData not found');
				}
				
				// เตรียมข้อมูลสำหรับบันทึก
				const dataToSave = {
					...walkablePointsData,
					building: building,
					currentBuilding: building,
					dataSource: 'admin',
					syncTime: new Date().toISOString(),
					timestamp: new Date().toISOString()
				};
				
				// บันทึกใน localStorage (ตาม Phase 2.1)
				const adminKey = getSafeStorageKey(building, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(dataToSave));
				
				debugLog('✅ Saved to localStorage:', { adminKey });
				
				// บันทึกไป Google Sheets (ถ้าเปิดใช้งาน)
				if (WALKABLE_SHEETS_CONFIG.walkableEnabled && sheetsConfig.connected) {
					const sheetsSuccess = await saveWalkableDataToSheets(dataToSave);
					
					if (sheetsSuccess) {
						debugLog('✅ Saved to Google Sheets successfully');
					} else {
						debugLog('⚠️ Failed to save to Google Sheets, but localStorage saved');
						showWalkableNotification('⚠️ บันทึกในเครื่องสำเร็จ แต่ Google Sheets ล้มเหลว', 'warning');
					}
				}
				
				// Auto-sync ไป index format (ตาม Phase 2.1)
				if (ADMIN_INDEX_BRIDGE.autoSyncOnChange) {
					const indexData = convertAdminToIndexFormat(dataToSave);
					if (indexData) {
						const indexKey = getSafeStorageKey(building, 'index');
						localStorage.setItem(indexKey, JSON.stringify(indexData));
						debugLog('🔄 Auto-synced to index format');
					}
				}
				
				// แสดง notification
				if (typeof showNotification === 'function') {
					showNotification('💾 บันทึกข้อมูลจุดเดินแล้ว', 'success');
				}
				
				return true;
				
			} catch (error) {
				debugLog('❌ Error in enhanced save:', error);
				
				if (typeof showNotification === 'function') {
					showNotification('❌ เกิดข้อผิดพลาดในการบันทึก', 'error');
				}
				
				return false;
			} finally {
				// ปล่อย flag
				_saveInProgress = false;
			}
		}

		// ========== 4. Enhanced Load Function with Sheets Integration ==========

		// แทนที่ loadWalkableDataForBuilding เดิมด้วยเวอร์ชันที่รองรับ Sheets
		async function loadWalkableDataForBuildingEnhanced(building) {
			building = building || getCurrentBuildingName();
			debugLog('📂 Loading walkable data (enhanced with sheets)...', { building });
			
			// อัปเดต current building
			if (typeof walkablePointsData !== 'undefined') {
				walkablePointsData.currentBuilding = building;
			}
			
			try {
				let loadedData = null;
				
				// ลำดับการโหลด: Sheets → localStorage → สร้างใหม่
				
				// 1. ลองโหลดจาก Google Sheets ก่อน (ถ้าเปิดใช้งาน)
				if (WALKABLE_SHEETS_CONFIG.walkableEnabled && sheetsConfig.connected) {
					loadedData = await loadWalkableDataFromSheets(building);
					
					if (loadedData) {
						// แปลงเป็น admin format ถ้าจำเป็น
						if (loadedData.dataSource !== 'admin') {
							loadedData = convertIndexToAdminFormat(loadedData) || loadedData;
						}
						
						// อัปเดต walkablePointsData
						if (typeof walkablePointsData !== 'undefined') {
							Object.assign(walkablePointsData, loadedData);
							renderUI();
						}
						
						debugLog('✅ Loaded from Google Sheets');
						return;
					}
				}
				
				// 2. ถ้าไม่สำเร็จ ลองโหลดจาก localStorage (ตาม Phase 2.1)
				const adminKey = getSafeStorageKey(building, 'admin');
				const adminDataString = localStorage.getItem(adminKey);
				
				if (adminDataString) {
					const adminData = JSON.parse(adminDataString);
					
					if (typeof walkablePointsData !== 'undefined') {
						Object.assign(walkablePointsData, adminData);
						renderUI();
					}
					
					debugLog('✅ Loaded from localStorage');
					return;
				}
				
				// 3. ลอง sync จาก index (ตาม Phase 2.1)
				const synced = syncIndexDataToAdmin(building);
				if (synced) {
					debugLog('✅ Synced from index data');
					return;
				}
				
				// 4. สุดท้าย สร้างข้อมูลเริ่มต้น
				debugLog('📋 Creating fresh admin data');
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.nodes = {};
					walkablePointsData.edges = [];
					walkablePointsData.currentBuilding = building;
					renderUI();
				}
				
			} catch (error) {
				debugLog('❌ Error in enhanced load:', error);
				
				// Fallback
				if (typeof walkablePointsData !== 'undefined') {
					walkablePointsData.nodes = {};
					walkablePointsData.edges = [];
					walkablePointsData.currentBuilding = building;
				}
				
				showWalkableNotification('⚠️ เกิดข้อผิดพลาดในการโหลดข้อมูล ใช้ข้อมูลเริ่มต้น', 'warning');
			}
		}

		// ========== 5. UI Helper Functions ==========

		// อัปเดต UI สำหรับ walkable sync status
		function updateWalkableSyncUI() {
			// อัปเดต sync status indicator (ถ้ามี)
			const statusElement = document.getElementById('walkableSyncStatus');
			if (statusElement) {
				const status = WALKABLE_SHEETS_CONFIG.walkableSyncStatus;
				const lastSync = WALKABLE_SHEETS_CONFIG.lastWalkableSync;
				
				let statusText = '';
				let statusClass = '';
				
				switch (status) {
					case 'syncing':
						statusText = '🔄 กำลัง sync...';
						statusClass = 'syncing';
						break;
					case 'success':
						statusText = `✅ sync สำเร็จ ${lastSync ? formatTime(lastSync) : ''}`;
						statusClass = 'success';
						break;
					case 'error':
						statusText = '❌ sync ล้มเหลว';
						statusClass = 'error';
						break;
					default:
						statusText = '⏸️ รอ sync';
						statusClass = 'idle';
				}
				
				statusElement.textContent = statusText;
				statusElement.className = `sync-status ${statusClass}`;
			}
		}

		// แสดง notification เฉพาะสำหรับ walkable
		function showWalkableNotification(message, type = 'info') {
			// ใช้ existing showNotification ถ้ามี
			if (typeof showNotification === 'function') {
				showNotification(message, type);
				return;
			}
			
			// Fallback notification
			console.log(`[${type.toUpperCase()}] ${message}`);
		}

		// Render UI elements (รวม existing functions)
		function renderUI() {
			if (typeof renderWalkablePoints === 'function') {
				renderWalkablePoints();
			}
			if (typeof updateWalkableStats === 'function') {
				updateWalkableStats();
			}
			if (typeof loadWalkableSettings === 'function') {
				loadWalkableSettings();
			}
		}

		// Format timestamp for display
		function formatTime(isoString) {
			try {
				const date = new Date(isoString);
				return date.toLocaleTimeString('th-TH', { 
					hour: '2-digit', 
					minute: '2-digit' 
				});
			} catch {
				return '';
			}
		}

		// ========== 6. Manual Sync Functions ==========

		// Manual sync ไป Google Sheets
		async function manualSyncToSheets() {
			if (!sheetsConfig.connected) {
				showWalkableNotification('❌ ไม่ได้เชื่อมต่อ Google Sheets', 'error');
				return;
			}
			
			if (typeof walkablePointsData === 'undefined' || !walkablePointsData.nodes) {
				showWalkableNotification('❌ ไม่มีข้อมูลจุดเดินสำหรับ sync', 'error');
				return;
			}
			
			showWalkableNotification('🔄 กำลัง sync ข้อมูลจุดเดินไป Google Sheets...', 'info');
			
			const success = await saveWalkableDataToSheets(walkablePointsData);
			
			if (success) {
				showWalkableNotification('✅ Sync ไป Google Sheets สำเร็จ', 'success');
			} else {
				showWalkableNotification('❌ Sync ไป Google Sheets ล้มเหลว', 'error');
			}
		}

		// Manual load จาก Google Sheets
		async function manualLoadFromSheets() {
			if (!sheetsConfig.connected) {
				showWalkableNotification('❌ ไม่ได้เชื่อมต่อ Google Sheets', 'error');
				return;
			}
			
			showWalkableNotification('🔄 กำลังโหลดข้อมูลจุดเดินจาก Google Sheets...', 'info');
			
			const building = getCurrentBuildingName();
			const data = await loadWalkableDataFromSheets(building);
			
			if (data) {
				// อัปเดต walkablePointsData
				if (typeof walkablePointsData !== 'undefined') {
					Object.assign(walkablePointsData, data);
					renderUI();
				}
				
				// บันทึกใน localStorage ด้วย
				const adminKey = getSafeStorageKey(building, 'admin');
				localStorage.setItem(adminKey, JSON.stringify(data));
				
				showWalkableNotification('✅ โหลดจาก Google Sheets สำเร็จ', 'success');
			} else {
				showWalkableNotification('❌ โหลดจาก Google Sheets ล้มเหลว', 'error');
			}
		}

		// ========== 7. Integration with Existing Functions ==========

		// แทนที่ existing functions ด้วย enhanced versions
		if (typeof window !== 'undefined') {
			// Backup original functions
			window.originalSaveWalkableData = window.saveWalkableData;
			window.originalLoadWalkableDataForBuilding = window.loadWalkableDataForBuilding;
			
			// Replace with enhanced versions
			window.saveWalkableData = saveWalkableDataEnhanced;
			window.loadWalkableDataForBuilding = loadWalkableDataForBuildingEnhanced;
			
			// Add new functions to window
			window.manualSyncToSheets = manualSyncToSheets;
			window.manualLoadFromSheets = manualLoadFromSheets;
			window.createWalkableSheetsAuto = createWalkableSheetsAuto;
		}

		// ========== 8. Auto-initialization ==========

		// Initialize enhanced walkable sheets on DOM ready
		function initializeWalkableSheets() {
			debugLog('🚀 Initializing Walkable Sheets Integration...');
			
			// ตรวจสอบว่ามี walkablePointsData
			if (typeof walkablePointsData === 'undefined') {
				debugLog('⚠️ walkablePointsData not found, walkable sheets integration inactive');
				return;
			}
			
			// เพิ่ม event listeners สำหรับ auto-sync
			if (WALKABLE_SHEETS_CONFIG.autoSyncWalkable && typeof saveWalkableData === 'function') {
				// Auto-sync เมื่อมีการเปลี่ยนแปลงข้อมูล
				const originalAddNode = window.addWalkableNode;
				const originalDeleteNode = window.deleteWalkableNode;
				
				if (originalAddNode) {
					window.addWalkableNode = function(...args) {
						const result = originalAddNode.apply(this, args);
						if (result && WALKABLE_SHEETS_CONFIG.autoSyncWalkable) {
							setTimeout(() => saveWalkableDataEnhanced(), 1000);
						}
						return result;
					};
				}
				
				if (originalDeleteNode) {
					window.deleteWalkableNode = function(...args) {
						const result = originalDeleteNode.apply(this, args);
						if (result && WALKABLE_SHEETS_CONFIG.autoSyncWalkable) {
							setTimeout(() => saveWalkableDataEnhanced(), 1000);
						}
						return result;
					};
				}
			}
			
			debugLog('✅ Walkable Sheets Integration initialized');
		}

		// Auto-initialize
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initializeWalkableSheets);
		} else {
			initializeWalkableSheets();
		}
		
		// ========== 3. Enhanced Error Handling System ==========

		const WALKABLE_ERROR_HANDLER = {
			maxErrors: 10,
			retryDelays: [1000, 2000, 5000], // milliseconds
			
			// บันทึก error และแสดงใน UI
			logError(operation, error, context = {}) {
				const timestamp = new Date().toISOString();
				const errorInfo = {
					timestamp,
					operation,
					error: error.message || error,
					context
				};
				
				// เพิ่มใน WALKABLE_SHEETS_CONFIG.walkableSyncErrors
				WALKABLE_SHEETS_CONFIG.walkableSyncErrors.push(errorInfo);
				
				// จำกัดจำนวน errors
				if (WALKABLE_SHEETS_CONFIG.walkableSyncErrors.length > this.maxErrors) {
					WALKABLE_SHEETS_CONFIG.walkableSyncErrors.shift();
				}
				
				// อัปเดต UI
				this.updateErrorUI();
				
				console.error(`[Walkable ${operation}]`, error, context);
			},
			
			// อัปเดต error log UI
			updateErrorUI() {
				const errorLog = document.getElementById('walkableErrorLog');
				const errorList = document.getElementById('walkableErrorList');
				const clearBtn = document.getElementById('clearErrorsBtn');
				
				if (!errorLog || !errorList) return;
				
				const errors = WALKABLE_SHEETS_CONFIG.walkableSyncErrors;
				
				if (errors.length === 0) {
					errorLog.style.display = 'none';
					if (clearBtn) clearBtn.style.display = 'none';
					return;
				}
				
				// แสดง error log
				errorLog.style.display = 'block';
				if (clearBtn) clearBtn.style.display = 'inline-block';
				
				// สร้างรายการ errors (แสดงล่าสุด 5 อัน)
				const recentErrors = errors.slice(-5);
				errorList.innerHTML = recentErrors.map(err => {
					const time = new Date(err.timestamp).toLocaleTimeString('th-TH', {
						hour: '2-digit', minute: '2-digit'
					});
					return `<div class="error-item">${time}: ${err.operation} - ${err.error}</div>`;
				}).join('');
			},
			
			// ลอง retry operation
			async retry(operation, maxAttempts = 3) {
				for (let attempt = 1; attempt <= maxAttempts; attempt++) {
					try {
						const result = await operation();
						return result;
					} catch (error) {
						if (attempt === maxAttempts) {
							throw error;
						}
						
						const delay = this.retryDelays[Math.min(attempt - 1, this.retryDelays.length - 1)];
						debugLog(`⏳ Retry ${attempt}/${maxAttempts} in ${delay}ms...`);
						await new Promise(resolve => setTimeout(resolve, delay));
					}
				}
			}
		};

		// ========== 4. Enhanced UI Update Functions ==========

		// อัปเดต sync status พร้อม animation
		function updateWalkableSyncUIEnhanced() {
			const statusElement = document.getElementById('walkableSyncStatus');
			const progressElement = document.getElementById('walkableSyncProgress');
			const syncBtn = document.getElementById('syncToSheetsBtn');
			const loadBtn = document.getElementById('loadFromSheetsBtn');
			
			if (!statusElement) return;
			
			const status = WALKABLE_SHEETS_CONFIG.walkableSyncStatus;
			const lastSync = WALKABLE_SHEETS_CONFIG.lastWalkableSync;
			
			// อัปเดต status text และ class
			let statusText, statusClass;
			
			switch (status) {
				case 'syncing':
					statusText = '🔄 กำลัง sync...';
					statusClass = 'syncing';
					if (progressElement) {
						progressElement.style.display = 'block';
						progressElement.querySelector('.progress-bar').style.width = '70%';
					}
					if (syncBtn) syncBtn.disabled = true;
					if (loadBtn) loadBtn.disabled = true;
					break;
					
				case 'success':
					statusText = `✅ sync สำเร็จ${lastSync ? ' ' + formatTimeShort(lastSync) : ''}`;
					statusClass = 'success';
					if (progressElement) {
						progressElement.style.display = 'none';
					}
					if (syncBtn) syncBtn.disabled = false;
					if (loadBtn) loadBtn.disabled = false;
					break;
					
				case 'error':
					statusText = '❌ sync ล้มเหลว';
					statusClass = 'error';
					if (progressElement) {
						progressElement.style.display = 'none';
					}
					if (syncBtn) syncBtn.disabled = false;
					if (loadBtn) loadBtn.disabled = false;
					break;
					
				default:
					statusText = '⏸️ รอ sync';
					statusClass = 'idle';
					if (progressElement) {
						progressElement.style.display = 'none';
					}
					if (syncBtn) syncBtn.disabled = false;
					if (loadBtn) loadBtn.disabled = false;
			}
			
			statusElement.textContent = statusText;
			statusElement.className = `sync-status ${statusClass}`;
			
			// อัปเดต auto-sync button
			const autoSyncBtn = document.getElementById('autoSyncBtn');
			if (autoSyncBtn) {
				autoSyncBtn.textContent = WALKABLE_SHEETS_CONFIG.autoSyncWalkable ? '🔄 Auto ON' : '⏸️ Auto OFF';
				autoSyncBtn.className = `btn btn-sm ${WALKABLE_SHEETS_CONFIG.autoSyncWalkable ? 'btn-success' : 'btn-secondary'}`;
			}
		}

		// ========== 5. Enhanced Functions with Error Handling ==========

		// Enhanced sync ไป Sheets พร้อม error handling
		async function manualSyncToSheetsEnhanced() {
			if (!sheetsConfig.connected) {
				showWalkableNotification('❌ ไม่ได้เชื่อมต่อ Google Sheets', 'error');
				return false;
			}
			
			if (typeof walkablePointsData === 'undefined' || !walkablePointsData.nodes) {
				showWalkableNotification('❌ ไม่มีข้อมูลจุดเดินสำหรับ sync', 'error');
				return false;
			}
			
			WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'syncing';
			updateWalkableSyncUIEnhanced();
			
			try {
				const result = await WALKABLE_ERROR_HANDLER.retry(async () => {
					return await saveWalkableDataToSheets(walkablePointsData);
				}, 2);
				
				if (result) {
					WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'success';
					WALKABLE_SHEETS_CONFIG.lastWalkableSync = new Date().toISOString();
					showWalkableNotification('✅ Sync ไป Google Sheets สำเร็จ', 'success');
				} else {
					throw new Error('Sync operation returned false');
				}
				
			} catch (error) {
				WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'error';
				WALKABLE_ERROR_HANDLER.logError('manualSync', error, {
					nodesCount: Object.keys(walkablePointsData.nodes || {}).length,
					edgesCount: (walkablePointsData.edges || []).length
				});
				showWalkableNotification(`❌ Sync ล้มเหลว: ${error.message}`, 'error');
			}
			
			updateWalkableSyncUIEnhanced();
			return WALKABLE_SHEETS_CONFIG.walkableSyncStatus === 'success';
		}

		// Enhanced load จาก Sheets พร้อม error handling
		async function manualLoadFromSheetsEnhanced() {
			if (!sheetsConfig.connected) {
				showWalkableNotification('❌ ไม่ได้เชื่อมต่อ Google Sheets', 'error');
				return false;
			}
			
			WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'syncing';
			updateWalkableSyncUIEnhanced();
			
			try {
				const building = getCurrentBuildingName();
				const data = await WALKABLE_ERROR_HANDLER.retry(async () => {
					return await loadWalkableDataFromSheets(building);
				}, 2);
				
				if (data) {
					// อัปเดต walkablePointsData
					if (typeof walkablePointsData !== 'undefined') {
						Object.assign(walkablePointsData, data);
						renderUI();
					}
					
					// บันทึกใน localStorage
					const adminKey = getSafeStorageKey(building, 'admin');
					localStorage.setItem(adminKey, JSON.stringify(data));
					
					WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'success';
					WALKABLE_SHEETS_CONFIG.lastWalkableSync = new Date().toISOString();
					showWalkableNotification('✅ โหลดจาก Google Sheets สำเร็จ', 'success');
				} else {
					throw new Error('No data received from Sheets');
				}
				
			} catch (error) {
				WALKABLE_SHEETS_CONFIG.walkableSyncStatus = 'error';
				WALKABLE_ERROR_HANDLER.logError('manualLoad', error, {
					building: getCurrentBuildingName()
				});
				showWalkableNotification(`❌ โหลดล้มเหลว: ${error.message}`, 'error');
			}
			
			updateWalkableSyncUIEnhanced();
			return WALKABLE_SHEETS_CONFIG.walkableSyncStatus === 'success';
		}

		// ========== 6. UI Control Functions ==========

		// Toggle auto-sync
		function autoSyncToggle() {
			WALKABLE_SHEETS_CONFIG.autoSyncWalkable = !WALKABLE_SHEETS_CONFIG.autoSyncWalkable;
			
			// บันทึกการตั้งค่า
			localStorage.setItem('walkableSheetsConfig', JSON.stringify(WALKABLE_SHEETS_CONFIG));
			
			updateWalkableSyncUIEnhanced();
			
			const status = WALKABLE_SHEETS_CONFIG.autoSyncWalkable ? 'เปิด' : 'ปิด';
			showWalkableNotification(`🔄 Auto-sync ${status}`, 'info');
		}

		// ล้าง error log
		function clearWalkableErrors() {
			WALKABLE_SHEETS_CONFIG.walkableSyncErrors = [];
			WALKABLE_ERROR_HANDLER.updateErrorUI();
			showWalkableNotification('🗑️ ล้าง error log แล้ว', 'info');
		}

		// ========== 7. Connection Monitor ==========

		const CONNECTION_MONITOR = {
			intervalId: null,
			checkInterval: 30000, // 30 seconds
			
			start() {
				if (this.intervalId) return;
				
				this.intervalId = setInterval(async () => {
					if (sheetsConfig.url && sheetsConfig.connected) {
						try {
							// Test connection สั้นๆ
							const params = new URLSearchParams();
							params.append('action', 'getData');
							params.append('sheet', 'Buildings');
							
							const response = await Promise.race([
								fetch(sheetsConfig.url, {
									method: 'POST',
									headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
									body: params.toString()
								}),
								new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
							]);
							
							if (!response.ok) {
								throw new Error(`HTTP ${response.status}`);
							}
							
						} catch (error) {
							console.warn('🌐 Connection check failed:', error.message);
							if (sheetsConfig.connected) {
								sheetsConfig.connected = false;
								showWalkableNotification('⚠️ การเชื่อมต่อ Google Sheets ขาดหาย', 'warning');
							}
						}
					}
				}, this.checkInterval);
			},
			
			stop() {
				if (this.intervalId) {
					clearInterval(this.intervalId);
					this.intervalId = null;
				}
			}
		};

		// ========== 8. Helper Functions ==========

		function formatTimeShort(isoString) {
			try {
				const date = new Date(isoString);
				const now = new Date();
				const diffMs = now - date;
				
				if (diffMs < 60000) return 'เมื่อสักครู่';
				if (diffMs < 3600000) return `${Math.floor(diffMs/60000)} นาทีที่แล้ว`;
				return date.toLocaleTimeString('th-TH', { hour: '2-digit', minute: '2-digit' });
			} catch {
				return '';
			}
		}

		// อัปเดต original functions
		function updateWalkableSyncUI() {
			updateWalkableSyncUIEnhanced();
		}

		// ========== 9. Initialization ==========

		function initializeWalkableUIEnhanced() {
			// เพิ่ม CSS styles
			if (!document.getElementById('walkableUIStyles')) {
				const style = document.createElement('style');
				style.id = 'walkableUIStyles';
				style.textContent = WALKABLE_UI_STYLES;
				document.head.appendChild(style);
			}
			
			// โหลดการตั้งค่า
			try {
				const savedConfig = localStorage.getItem('walkableSheetsConfig');
				if (savedConfig) {
					Object.assign(WALKABLE_SHEETS_CONFIG, JSON.parse(savedConfig));
				}
			} catch (error) {
				console.warn('Failed to load walkable sheets config:', error);
			}
			
			// เริ่ม connection monitor
			CONNECTION_MONITOR.start();
			
			// แทนที่ functions เดิม
			if (typeof window !== 'undefined') {
				//window.manualSyncToSheets = manualSyncToSheetsEnhanced;
				//window.manualLoadFromSheets = manualLoadFromSheetsEnhanced;
				//window.autoSyncToggle = autoSyncToggle;
				//window.clearWalkableErrors = clearWalkableErrors;
			}
			
			// อัปเดต UI เริ่มต้น
			updateWalkableSyncUIEnhanced();
			
			debugLog('✅ Walkable UI Enhanced initialized');
		}

		// Auto-initialize
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initializeWalkableUIEnhanced);
		} else {
			initializeWalkableUIEnhanced();
		}

		// Cleanup on page unload
		window.addEventListener('beforeunload', () => {
			CONNECTION_MONITOR.stop();
		});

		//*****************End of  Phase 2.2A: Admin Walkable Sheets Integration ==========	
			
        // =================== Initialize When Page Loads ===================
        
        document.addEventListener('DOMContentLoaded', function() {
            setupEventHandlers();
            
            if (checkLoginStatus()) {
                initializeAdmin();
            }
        });
		
		// ✅ เรียกใช้เมื่อ DOM โหลดเสร็จ (แก้ไข: ป้องกันการโหลดใน login page)
		document.addEventListener('DOMContentLoaded', function() {
			console.log('🎯 Initializing Maps fixes...');
			
			// ตรวจสอบว่าอยู่ในหน้า admin หรือไม่
			const isInAdminPage = document.getElementById('adminContainer') && 
								 document.getElementById('adminContainer').style.display !== 'none';
			
			if (isInAdminPage) {
				// เพิ่มการโหลด Maps ในระบบ navigation
				enhanceNavigationWithMaps();
				
				// ถ้าเข้าหน้า admin และ login แล้ว ให้โหลด Maps
				setTimeout(() => {
					if (typeof isLoggedIn !== 'undefined' && isLoggedIn) {
						console.log('🗺️ User logged in, initializing Maps...');
						initializeMapsModule();
					}
				}, 2000);
			} else {
				console.log('📝 In login page, skipping Maps initialization');
			}
			
			// เพิ่ม enhancement สำหรับ login และ admin initialization
			enhanceLoginHandling(); 
			
			console.log('✅ Maps fixes initialization completed');
		});
		
		// ✅ เรียกใช้เมื่อ window โหลดเสร็จ (แก้ไข: ป้องกันการโหลดใน login page)
		window.addEventListener('load', function() {
			setTimeout(() => {
				// ตรวจสอบว่าอยู่ในหน้า admin และ login แล้วหรือไม่
				const isLoggedIn = sessionStorage.getItem('adminLoggedIn') === 'true';
				const adminContainer = document.getElementById('adminContainer');
				const loginContainer = document.getElementById('loginContainer');
				
				if (isLoggedIn && adminContainer && adminContainer.style.display !== 'none') {
					console.log('🔄 Backup Maps initialization...');
					
					// ตรวจสอบว่าอยู่ในหน้า Maps หรือไม่
					const mapsSection = document.getElementById('maps-section');
					if (mapsSection) {
						initializeMapsModule();
					}
				} else {
					console.log('📝 In login page or not logged in, skipping backup Maps initialization');
				}
			}, 3000);
		});
 
// Global routing system state
window.routingSystemReady = false;
window.walkablePointsReady = false;

 

	 // 🔧 แก้ไข 10: เพิ่มฟังก์ชัน debug สำหรับ CRUD sync
function debugCRUDSync() {
    console.log('🔍 === CRUD SYNC DEBUG ===');
    console.log('Sheets Config:', {
        url: sheetsConfig.url ? 'Set' : 'Not Set',
        connected: sheetsConfig.connected,
        autoSync: sheetsConfig.autoSync,
        buildingsSheet: sheetsConfig.buildingsSheet,
        roomsSheet: sheetsConfig.roomsSheet
    });
    console.log('Data Counts:', {
        buildings: Object.keys(buildingsData).length,
        rooms: Object.keys(roomsData).length
    });
}

// เพิ่มให้ window เพื่อเรียกใช้จาก console
window.clearMapImageCache = clearMapImageCache;
window.forceEnableAutoSync = forceEnableAutoSync;
window.debugCRUDSync = debugCRUDSync;
		
		
    </script>
</body>
</html>